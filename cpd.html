<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia at 2018-06-07 
 | Rendered using Apache Maven Fluido Skin 1.4
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20180607" />
    <meta http-equiv="Content-Language" content="en" />
    <title>BlackLab &#x2013; CPD Results</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.4.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido-1.4.min.js"></script>

                          
        
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nunito:300" type="text/css"/>
          
                  </head>
        <body class="topBarDisabled">
          
                
                    
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                                                                                                <img src="images/logo-blacklab.png"  alt="BlackLab"/>
                </div>
                      </div>
        <div class="pull-right">                  <a href="http://www.inl.nl/" id="bannerRight">
                                                                                                <img src="images/logo-inl.png"  alt="INL"/>
                </a>
      </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                              <li class="">
                    <a href="http://www.inl.nl/" class="externalLink" title="INL">
        INL</a>
                    <span class="divider">/</span>
      </li>
            <li class="">
                    <a href="index.html" title="BlackLab">
        BlackLab</a>
                    <span class="divider">/</span>
      </li>
        <li class="active ">CPD Results</li>
        
                
                    
                  <li id="publishDate" class="pull-right"><span class="divider">|</span> Last Published: 2018-06-07</li>
              <li id="projectVersion" class="pull-right">
                    Version: 1.7.0
        </li>
            
                            </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
                
                    
                <ul class="nav nav-list">
                    <li class="nav-header">BlackLab</li>
                              
      <li>
  
                          <a href="index.html" title="Introduction">
          <span class="none"></span>
        Introduction</a>
            </li>
                                                                                                                                                                                                            
      <li>
  
                          <a href="learn.html" title="Learn">
          <span class="icon-chevron-down"></span>
        Learn</a>
                    <ul class="nav nav-list">
                    
      <li>
  
                          <a href="getting-started.html" title="Getting Started">
          <span class="none"></span>
        Getting Started</a>
            </li>
                    
      <li>
  
                          <a href="corpus-query-language.html" title="Corpus Query Language">
          <span class="none"></span>
        Corpus Query Language</a>
            </li>
                    
      <li>
  
                          <a href="blacklab-server-overview.html" title="BlackLab Server overview">
          <span class="none"></span>
        BlackLab Server overview</a>
            </li>
                    
      <li>
  
                          <a href="blacklab-server-different-languages.html" title="Using BlackLab Server from different languages">
          <span class="none"></span>
        Using BlackLab Server from different languages</a>
            </li>
                    
      <li>
  
                          <a href="indexing-with-blacklab.html" title="Indexing with BlackLab">
          <span class="none"></span>
        Indexing with BlackLab</a>
            </li>
                    
      <li>
  
                          <a href="add-input-format.html" title="Add An Input Format">
          <span class="none"></span>
        Add An Input Format</a>
            </li>
                    
      <li>
  
                          <a href="improve-search-speed.html" title="Improve Search Speed">
          <span class="none"></span>
        Improve Search Speed</a>
            </li>
                    
      <li>
  
                          <a href="apidocs/index.html" title="API reference">
          <span class="none"></span>
        API reference</a>
            </li>
                    
      <li>
  
                          <a href="file-formats.html" title="File formats">
          <span class="none"></span>
        File formats</a>
            </li>
              </ul>
        </li>
                
      <li>
  
                          <a href="downloads.html" title="Downloads">
          <span class="none"></span>
        Downloads</a>
            </li>
                
      <li>
  
                          <a href="faq.html" title="FAQ">
          <span class="none"></span>
        FAQ</a>
            </li>
                
      <li>
  
                          <a href="changelog.html" title="Change Log">
          <span class="none"></span>
        Change Log</a>
            </li>
                
      <li>
  
                          <a href="roadmap.html" title="Road Map">
          <span class="none"></span>
        Road Map</a>
            </li>
                
      <li>
  
                          <a href="newsletter.html" title="Newsletter">
          <span class="none"></span>
        Newsletter</a>
            </li>
                              <li class="nav-header">Project Documentation</li>
                                                                                                                                                                                                                                
      <li>
  
                          <a href="project-info.html" title="Project Information">
          <span class="icon-chevron-right"></span>
        Project Information</a>
                  </li>
                                                                                                                                                                                                                                                                
      <li>
  
                          <a href="project-reports.html" title="Project Reports">
          <span class="icon-chevron-down"></span>
        Project Reports</a>
                    <ul class="nav nav-list">
                    
      <li>
  
                          <a href="surefire-report.html" title="Surefire Report">
          <span class="none"></span>
        Surefire Report</a>
            </li>
                    
      <li>
  
                          <a href="apidocs/index.html" title="JavaDocs">
          <span class="none"></span>
        JavaDocs</a>
            </li>
                    
      <li>
  
                          <a href="xref/index.html" title="Source Xref">
          <span class="none"></span>
        Source Xref</a>
            </li>
                    
      <li>
  
                          <a href="xref-test/index.html" title="Test Source Xref">
          <span class="none"></span>
        Test Source Xref</a>
            </li>
                    
      <li>
  
                          <a href="findbugs.html" title="FindBugs">
          <span class="none"></span>
        FindBugs</a>
            </li>
                    
      <li class="active">
  
            <a href="#"><span class="none"></span>CPD</a>
          </li>
                    
      <li>
  
                          <a href="pmd.html" title="PMD">
          <span class="none"></span>
        PMD</a>
            </li>
                    
      <li>
  
                          <a href="checkstyle.html" title="Checkstyle">
          <span class="none"></span>
        Checkstyle</a>
            </li>
                    
      <li>
  
                          <a href="taglist.html" title="Tag List">
          <span class="none"></span>
        Tag List</a>
            </li>
                    
      <li>
  
                          <a href="dependency-updates-report.html" title="Dependency Updates Report">
          <span class="none"></span>
        Dependency Updates Report</a>
            </li>
                    
      <li>
  
                          <a href="plugin-updates-report.html" title="Plugin Updates Report">
          <span class="none"></span>
        Plugin Updates Report</a>
            </li>
              </ul>
        </li>
            </ul>
                
                    
                
          <hr />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span10" >
                                  
            <div class="section">
<h2><a name="CPD_Results"></a>CPD Results</h2>
<p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 5.3.2.</p></div>
<div class="section">
<h2><a name="Duplications"></a>Duplications</h2>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/SpanQuerySequence.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQuerySequence.html#L619">619</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/SpanQuerySequenceOfTwo.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQuerySequenceOfTwo.html#L266">266</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		return &quot;SEQ(&quot; + clausesToString(field) + &quot;)&quot;;
	}

	@Override
	public boolean hitsAllSameLength() {
		for (BLSpanQuery clause: clauses) {
			if (!clause.hitsAllSameLength())
				return false;
		}
		return true;
	}

	@Override
	public int hitsLengthMin() {
		int n = 0;
		for (BLSpanQuery clause: clauses) {
			n += clause.hitsLengthMin();
		}
		return n;
	}

	@Override
	public int hitsLengthMax() {
		int n = 0;
		for (BLSpanQuery clause: clauses) {
			int max = clause.hitsLengthMax();
			if (max == Integer.MAX_VALUE)
				return max; // infinite
			n += max;
		}
		return n;
	}

	@Override
	public boolean hitsEndPointSorted() {
		for (int i = 0; i &lt; clauses.size() - 1; i++) {
			if (!clauses.get(i).hitsHaveUniqueEnd())
				return false;
		}
		for (int i = 1; i &lt; clauses.size(); i++) {
			if (!clauses.get(i).hitsAllSameLength())
				return false;
		}
		return true;
	}

	@Override
	public boolean hitsStartPointSorted() {
		for (int i = 0; i &lt; clauses.size() - 1; i++) {
			if (!clauses.get(i).hitsAllSameLength())
				return false;
		}
		return true;
	}

	@Override
	public boolean hitsHaveUniqueStart() {
		for (BLSpanQuery clause: clauses) {
			if (!clause.hitsHaveUniqueStart())
				return false;
		}
		return true;
	}

	@Override
	public boolean hitsHaveUniqueEnd() {
		for (BLSpanQuery clause: clauses) {
			if (!clause.hitsHaveUniqueEnd())
				return false;
		}
		return true;

	}

	@Override
	public boolean hitsAreUnique() {
		return hitsHaveUniqueStart() || hitsHaveUniqueEnd();
	}

	@Override
	public Nfa getNfa(ForwardIndexAccessor fiAccessor, int direction) {
		Nfa frag = null;
		int start = direction == 1 ? 0 : clauses.size() - 1;
		int end = direction == 1 ? clauses.size() : -1;
		for (int i = start; i != end; i += direction) {
			BLSpanQuery clause = clauses.get(i);
			if (frag == null)
				frag = clause.getNfa(fiAccessor, direction);
			else
				frag.append(clause.getNfa(fiAccessor, direction));
		}
		return frag;
	}

	@Override
	public boolean canMakeNfa() {
		for (BLSpanQuery clause: clauses) {
			if (!clause.canMakeNfa())
				return false;
		}
		return true;
	}

	@Override
	public long reverseMatchingCost(IndexReader reader) {
		long cost = Integer.MAX_VALUE;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/index/DocIndexerPlainTextBasic.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerPlainTextBasic.html#L186">186</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/index/DocIndexerXmlHandlers.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXmlHandlers.html#L109">109</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			int lastValuePos = 0;
			for (ComplexFieldProperty prop: contentsField.getProperties()) {
				if (prop.lastValuePosition() &gt; lastValuePos)
					lastValuePos = prop.lastValuePosition();
			}

			// Make sure we always have one more token than the number of
			// words, so there's room for any tags after the last word, and we
			// know we should always skip the last token when matching.
			if (propMain.lastValuePosition() == lastValuePos)
				lastValuePos++;

			// Add empty values to all lagging properties
			for (ComplexFieldProperty prop: contentsField.getProperties()) {
				while (prop.lastValuePosition() &lt; lastValuePos) {
					prop.addValue(&quot;&quot;);
					if (prop.hasPayload())
						prop.addPayload(null);
					if (prop == propMain) {
						contentsField.addStartChar(getCharacterPosition());
						contentsField.addEndChar(getCharacterPosition());
					}
				}
			}

			// Finish storing the document in the document store (parts of it
			// may already have been written because we write in chunks to save memory),
			// retrieve the content id, and store that in Lucene.
			// (Note that we do this after adding the dummy token, so the character
			// positions for the dummy token still make (some) sense)
			int contentId = storeCapturedContent();
			currentLuceneDoc.add(new IntField(ComplexFieldUtil.contentIdField(contentsField.getName()), contentId, Store.YES));

			// Store the different properties of the complex contents field that
			// were gathered in lists while parsing.
			contentsField.addToLuceneDoc(currentLuceneDoc);

			// Add all properties to forward index
			for (ComplexFieldProperty prop: contentsField.getProperties()) {
				if (!prop.hasForwardIndex())
					continue;

				// Add property (case-sensitive tokens) to forward index and add
				// id to Lucene doc
				String propName = prop.getName();
				String fieldName = ComplexFieldUtil.propertyField(contentsField.getName(), propName);
				int fiid = indexer.addToForwardIndex(fieldName, prop);
				currentLuceneDoc.add(new IntField(ComplexFieldUtil.forwardIndexIdField(fieldName), fiid, Store.YES));
			}

			// If there's an external metadata fetcher, call it now so it can
			// add the metadata for this document and (optionally) store the
			// metadata document in the content store (and the corresponding id in the
			// Lucene doc)
			MetadataFetcher m = getMetadataFetcher();
			if (m != null) {
				m.addMetadata();
			}

			// See what metadatafields are missing or empty and add unknown value
			// if desired.
			IndexStructure struct = indexer.getSearcher().getIndexStructure();
			for (String fieldName: struct.getMetadataFields()) {
				MetadataFieldDesc fd = struct.getMetadataFieldDesc(fieldName);
				boolean missing = false, empty = false;
				String currentValue = currentLuceneDoc.get(fieldName);
				if (currentValue == null)
					missing = true;
				else if (currentValue.length() == 0)
					empty = true;
				UnknownCondition cond = fd.getUnknownCondition();
				boolean useUnknownValue = false;
				switch (cond) {
				case EMPTY:
					useUnknownValue = empty;
					break;
				case MISSING:
					useUnknownValue = missing;
					break;
				case MISSING_OR_EMPTY:
					useUnknownValue = missing | empty;
					break;
				case NEVER:
					useUnknownValue = false;
					break;
				}
				if (useUnknownValue)
					addMetadataField(fieldName, fd.getUnknownValue());
			}

			try {
				// Add Lucene doc to indexer
				indexer.add(currentLuceneDoc);
			} catch (Exception e) {
				throw ExUtil.wrapRuntimeException(e);
			}

			// Report progress
			reportCharsProcessed();
			reportTokensProcessed();

			indexer.getListener().documentDone(documentName);

			// Reset contents field for next document
			contentsField.clear(true);
			currentLuceneDoc = null;

			// Stop if required
			if (!indexer.continueIndexing())
				throw new MaxDocsReachedException();

		}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/SpanQuerySequence.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQuerySequence.html#L408">408</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/SpanQuerySequenceOfTwo.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQuerySequenceOfTwo.html#L110">110</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	}

	/**
	 * Given translated clauses, builds several alternatives and combines them with OR.
	 *
	 * This is necessary because of how sequence matching works: first the hits in each
	 * of the clauses are located, then we try to detect valid sequences by looking at these
	 * hits. But when a clause also matches the empty sequence, you may miss valid sequence
	 * matches because there's no hit in the clause to combine with the hits from other clauses.
	 *
	 * @param alternatives the alternative sequences we have built so far
	 * @param parts translation results for each of the clauses so far
	 * @param reader the index reader
	 * @return several alternatives combined with or
	 * @throws IOException
	 */
	List&lt;List&lt;BLSpanQuery&gt;&gt; makeAlternatives(List&lt;BLSpanQuery&gt; parts, IndexReader reader) throws IOException {
		if (parts.size() == 1) {
			// Last clause in the sequence; just return it
			// (noEmpty() version because we will build alternatives
			// in the caller if the input matched the empty sequence)
			return Arrays.asList(Arrays.asList(parts.get(0).noEmpty().rewrite(reader)));
		}

		// Recursively determine the query for the &quot;tail&quot; of the list,
		// and whether it matches the empty sequence or not.
		List&lt;BLSpanQuery&gt; partsTail = parts.subList(1, parts.size());
		boolean restMatchesEmpty = true;
		for (BLSpanQuery part: partsTail) {
			if (!part.matchesEmptySequence()) {
				restMatchesEmpty = false;
				break;
			}
		}
		List&lt;List&lt;BLSpanQuery&gt;&gt; altTail = makeAlternatives(partsTail, reader);

		// Now, add the head part and check if that matches the empty sequence.
		return combine(parts.get(0), altTail, restMatchesEmpty, reader);
	}

	private static List&lt;List&lt;BLSpanQuery&gt;&gt; combine(BLSpanQuery head, List&lt;List&lt;BLSpanQuery&gt;&gt; tailAlts, boolean tailMatchesEmpty,
			IndexReader reader) throws IOException {
		List&lt;List&lt;BLSpanQuery&gt;&gt; results = new ArrayList&lt;&gt;();
		BLSpanQuery headNoEmpty = head.noEmpty().rewrite(reader);
		boolean headMatchesEmpty = head.matchesEmptySequence();
		for (List&lt;BLSpanQuery&gt; tailAlt: tailAlts) {
			// Add head in front of each tail alternative
			List&lt;BLSpanQuery&gt; n = new ArrayList&lt;&gt;(tailAlt);
			n.add(0, headNoEmpty);
			results.add(n);

			// If head can be empty, also add original tail alternative
			if (headMatchesEmpty)
				results.add(tailAlt);
		}
		// If tail can be empty, also add the head separately
		if (tailMatchesEmpty)
			results.add(Arrays.asList(headNoEmpty));
		return results;
	}

	@Override
	public boolean matchesEmptySequence() {
		for (BLSpanQuery cl: clauses) {
			if (!cl.matchesEmptySequence())
				return false;
		}
		return true;
	}

	@Override
	public BLSpanQuery noEmpty() {
		if (!matchesEmptySequence())
			return this;
		throw new RuntimeException(&quot;Sequence should have been rewritten!&quot;);
	}

	@Override
	public BLSpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
		List&lt;BLSpanWeight&gt; weights = new ArrayList&lt;&gt;();
		for (BLSpanQuery clause: clauses) {
			weights.add(clause.createWeight(searcher, needsScores));
		}
		Map&lt;Term, TermContext&gt; contexts = needsScores ? getTermContexts(weights.toArray(new SpanWeight[0])) : null;
		return new SpanWeightSequence(weights, searcher, contexts);</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/util/UnicodeReader.java</td>
<td><a href="./xref/nl/inl/util/UnicodeReader.html#L69">69</a></td></tr>
<tr class="a">
<td>nl/inl/util/UnicodeStream.java</td>
<td><a href="./xref/nl/inl/util/UnicodeStream.html#L70">70</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		int unread;
		PushbackInputStream pushbackStream = new PushbackInputStream(in, BOM_SIZE);
		int n = pushbackStream.read(bom, 0, bom.length);

		// Read ahead four bytes and check for BOM marks.
		if ((bom[0] == (byte) 0xEF) &amp;&amp; (bom[1] == (byte) 0xBB) &amp;&amp; (bom[2] == (byte) 0xBF)) {
			encoding = Charset.forName(&quot;UTF-8&quot;);
			unread = n - 3;
		} else if ((bom[0] == (byte) 0xFE) &amp;&amp; (bom[1] == (byte) 0xFF)) {
			encoding = Charset.forName(&quot;UTF-16BE&quot;);
			unread = n - 2;
		} else if ((bom[0] == (byte) 0xFF) &amp;&amp; (bom[1] == (byte) 0xFE)) {
			encoding = Charset.forName(&quot;UTF-16LE&quot;);
			unread = n - 2;
		} else if ((bom[0] == (byte) 0x00) &amp;&amp; (bom[1] == (byte) 0x00) &amp;&amp; (bom[2] == (byte) 0xFE)
				&amp;&amp; (bom[3] == (byte) 0xFF)) {
			encoding = Charset.forName(&quot;UTF-32BE&quot;);
			unread = n - 4;
		} else if ((bom[0] == (byte) 0xFF) &amp;&amp; (bom[1] == (byte) 0xFE) &amp;&amp; (bom[2] == (byte) 0x00)
				&amp;&amp; (bom[3] == (byte) 0x00)) {
			encoding = Charset.forName(&quot;UTF-32LE&quot;);
			unread = n - 4;
		} else {
			encoding = defaultEncoding;
			unread = n;
		}

		// Unread bytes if necessary and skip BOM marks.
		if (unread &gt; 0) {
			pushbackStream.unread(bom, (n - unread), unread);
		} else if (unread &lt; -1) {
			pushbackStream.unread(bom, 0, 0);
		}

		// Use given encoding.
		if (encoding == null) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/fimatch/NfaStateAnd.java</td>
<td><a href="./xref/nl/inl/blacklab/search/fimatch/NfaStateAnd.html#L106">106</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/fimatch/NfaStateOr.java</td>
<td><a href="./xref/nl/inl/blacklab/search/fimatch/NfaStateOr.html#L107">107</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		}
		return true;
	}

	@Override
	public int hitsLengthMin(Set&lt;NfaState&gt; statesVisited) {
		int hitLengthMin = Integer.MAX_VALUE;
		if (statesVisited.contains(this)) {
			// We've found a cycle. Stop processing, and just return the
			// &quot;safest&quot; (least-guarantee) answer. In this case: the smallest
			// hit might be 0 long.
			return 0;
		}
		statesVisited.add(this);
		for (NfaState nextState: nextStates) {
			int i = nextState.hitsLengthMin(statesVisited);
			if (i &lt; hitLengthMin)
				hitLengthMin = i;
		}
		return hitLengthMin;
	}

	@Override
	public int hitsLengthMax(Set&lt;NfaState&gt; statesVisited) {
		int hitLengthMax = 0;
		if (statesVisited.contains(this)) {
			// We've found a cycle. Stop processing, and just return the
			// &quot;safest&quot; (least-guarantee) answer. In this case: the largest
			// hit might be &quot;infinitely&quot; large.
			return Integer.MAX_VALUE;
		}
		statesVisited.add(this);
		for (NfaState nextState: nextStates) {
			int i = nextState.hitsLengthMax(statesVisited);
			if (i &gt; hitLengthMax)
				hitLengthMax = i;
		}
		return hitLengthMax;
	}

	@Override
	protected String dumpInternal(Map&lt;NfaState, Integer&gt; stateNrs) {
		StringBuilder b = new StringBuilder();
		for (NfaState s: nextStates) {
			if (b.length() &gt; 0)
				b.append(&quot;,&quot;);
			b.append(dump(s, stateNrs));
		}
		return &quot;AND(&quot; + b.toString() + &quot;)&quot;;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L165">165</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerWhiteLab2.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerWhiteLab2.html#L221">221</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>				if (numPosAnnotations == 2 &amp;&amp; isFrog ||
					numPosAnnotations == 1 &amp;&amp; isSetLess) {
					// If there were 2 pos annotation meta declarations,
					// we should use the frog ones; if only 1, the ones
					// without a &quot;set&quot; attribute.
					pos = attributes.getValue(&quot;class&quot;);
					if (pos == null)
						pos = &quot;&quot;;
					// Capture the features inside this pos element (and add the head PoS now)
					capturePosFeatures = true;
					posFeatures.clear();
					String posHead = pos.contains(&quot;(&quot;) ? pos.substring(0, pos.indexOf(&quot;(&quot;)).trim() : pos;
					posFeatures.put(&quot;head&quot;, posHead);
				}
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				capturePosFeatures = false; // we have all the features
				super.endElement(uri, localName, qName);
			}

		});

		// pos/feat element: contains a part of speech feature
		addHandler(&quot;pos/feat&quot;, new ElementHandler() {
			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				if (capturePosFeatures) {
					String featSubset = attributes.getValue(&quot;subset&quot;);
					String featClass = attributes.getValue(&quot;class&quot;);
					posFeatures.put(featSubset, featClass);
				}
			}
		});

		// t (token) element directly under w (word) element: contains the word form
		addHandler(&quot;w/t&quot;, new ContentCapturingHandler() {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L226">226</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerWhiteLab2.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerWhiteLab2.html#L352">352</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		addHandler(&quot;s&quot;, new InlineTagHandler());

		// Paragraph tags: index as tags in the content
		addHandler(&quot;p&quot;, new InlineTagHandler());

		// &lt;event/&gt; tags: index as tags in the content
		addHandler(&quot;event&quot;, new InlineTagHandler());

		// meta elements: metadata fields
		// [NOT USED FOR OPENSONAR..?]
		addHandler(&quot;meta&quot;, new ContentCapturingHandler() {


			private String metadataFieldName;

			/** Open tag: add metadata field */
			@Override
			public void startElement(String uri, String localName, String qName, Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				metadataFieldName = attributes.getValue(&quot;id&quot;);
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (metadataFieldName != null)
					addMetadataField(metadataFieldName, getElementContent());
			}
		});
	}

	public static void main(String[] args) {
		System.out.println(&quot;NL B&quot;.replaceAll(&quot;[\\s\\./]&quot;, &quot;_&quot;));
		System.out.println(&quot;NL/B&quot;.replaceAll(&quot;[\\s\\./]&quot;, &quot;_&quot;));
		System.out.println(&quot;a.b.c.d&quot;.replaceAll(&quot;[\\s\\./]&quot;, &quot;_&quot;));
	}

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/testutil/BatchContentStore.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchContentStore.html#L68">68</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/testutil/BatchForwardIndex.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchForwardIndex.html#L62">62</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		System.err.println(&quot;done. [#docs: &quot; + cs.getDocIds().size() + &quot;]&quot;);

		System.out.println(&quot;First\tNumber\tSkip\tSnippets\tTime&quot;);

		for (String query : FileUtil.readLines(inputFile)) {
			query = query.trim();
			if (query.length() == 0 || query.charAt(0) == '#')
				continue; // skip empty lines and #-comments
			String[] numberStr = query.split(&quot;\\s+&quot;);
			int[] numbers = new int[numberStr.length];
			try {
				for (int i = 0; i &lt; numberStr.length; i++) {
					numbers[i] = Integer.parseInt(numberStr[i]);
				}

				int first = numbers[0];
				int number = numbers.length &gt; 1 ? numbers[1] : 100;
				int skip = numbers.length &gt; 2 ? numbers[2] : 0;
				int snippets = numbers.length &gt; 3 ? numbers[3] : 5;
				long time = doPerformanceTest(cs, first, number, skip, snippets);</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/MetadataFetcherCgnImdi.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/MetadataFetcherCgnImdi.html#L55">55</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/MetadataFetcherSonarCmdi.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/MetadataFetcherSonarCmdi.html#L55">55</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    public MetadataFetcherCgnImdi(DocIndexer docIndexer) {
		super(docIndexer);
		if (metadataZipFile == null) {
			String zipFilePath = docIndexer.getParameter(&quot;metadataZipFile&quot;);
			if (zipFilePath == null) {
				zipFilePath = docIndexer.getParameter(&quot;metadataDir&quot;);
				if (zipFilePath == null)
					throw new RuntimeException(
							&quot;For OpenSonar metadata, specify metadataZipFile or metadataDir in indexer.properties!&quot;);
				metadataDir = new File(zipFilePath);
			} else {
				try {
					metadataZipFile = new ZipFile(new File(zipFilePath));
				} catch (Exception e) {
					throw new RuntimeException(e);
				}
			}
		}

		metadataPathInZip = docIndexer.getParameter(&quot;metadataPath&quot;, &quot;&quot;);
		if (metadataPathInZip.length() == 0)
			metadataPathInZip = docIndexer.getParameter(&quot;metadataPathInZip&quot;, &quot;&quot;);
		if (metadataPathInZip.length() &gt; 0 &amp;&amp; !metadataPathInZip.endsWith(&quot;/&quot;))
			metadataPathInZip += &quot;/&quot;;
	}

	@Override
	public void close() {
		// TODO: make sure zip file is properly closed when done
		// (change structure so metadata fetcher isn't instantiated for each
		// document separately)
		// metadataZipFile.close();
	}

	@Override
	public void addMetadata() {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDir.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDir.html#L292">292</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.html#L652">652</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			throw ExUtil.wrapRuntimeException(e);
		}
	}

	/**
	 * Get a data File object, given the data file id.
	 *
	 * @param fileId
	 *            the data file id
	 * @return the File object
	 */
	private File getContentFile(int fileId) {
		File f = new File(dir, String.format(&quot;data%04d.dat&quot;, fileId));
		return f;
	}

	/**
	 * Retrieve content with given id
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	@Override
	public String retrieve(int id) {
		String[] rv = retrieveParts(id, new int[] { -1 }, new int[] { -1 });
		return rv == null ? null : rv[0];
	}

	/**
	 * Retrieve one or more substrings from the specified content.
	 *
	 * This is more efficient than retrieving the whole content, or retrieving parts in separate
	 * calls, because the file is only opened once and random access is used to read only the
	 * required parts.
	 *
	 * NOTE: if offset and length are both -1, retrieves the whole content. This is used by the
	 * retrieve(id) method.
	 *
	 * @param contentId
	 *            id of the entry to get substrings from
	 * @param start
	 *            the starting points of the substrings (in characters)
	 * @param end
	 *            the end points of the substrings (in characters)
	 * @return the parts
	 */
	@Override
	public synchronized String[] retrieveParts(int contentId, int[] start, int[] end) {
		try {
			TocEntry e = toc.get(contentId);
			if (e == null || e.deleted)
				return null;

			int n = start.length;
			if (n != end.length)
				throw new IllegalArgumentException(&quot;start and end must be of equal length&quot;);
			String[] result = new String[n];</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/SpanQueryFiltered.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQueryFiltered.html#L90">90</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/SpanQueryPositionFilter.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQueryPositionFilter.html#L225">225</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		return new SpanQueryFiltered(clauses.get(0).noEmpty(), filter);
	}

	@Override
	public boolean hitsAllSameLength() {
		return clauses.get(0).hitsAllSameLength();
	}

	@Override
	public int hitsLengthMin() {
		return clauses.get(0).hitsLengthMin();
	}

	@Override
	public int hitsLengthMax() {
		return clauses.get(0).hitsLengthMax();
	}

	@Override
	public boolean hitsStartPointSorted() {
		return true;
	}

	@Override
	public boolean hitsEndPointSorted() {
		return clauses.get(0).hitsEndPointSorted();
	}

	@Override
	public boolean hitsHaveUniqueStart() {
		return clauses.get(0).hitsHaveUniqueStart();
	}

	@Override
	public boolean hitsHaveUniqueEnd() {
		return clauses.get(0).hitsHaveUniqueEnd();
	}

	@Override
	public boolean hitsAreUnique() {
		return clauses.get(0).hitsAreUnique();
	}

	@Override
	public BLSpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/MetadataFetcherCgnImdi.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/MetadataFetcherCgnImdi.html#L106">106</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/MetadataFetcherSonarCmdi.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/MetadataFetcherSonarCmdi.html#L101">101</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		docIndexer.addMetadataField(&quot;AudioWebPlayFormat&quot;, &quot;mp3&quot;);

		try {
			InputStream is;
			if (metadataZipFile != null) {
				ZipEntry e = metadataZipFile.getEntry(metadataPathInZip + metadataFile);
				if (e == null) {
					// throw new RuntimeException(&quot;Entry in zip not found: &quot; +
					// metadataPathInZip + metadataFile);
					System.err.println(&quot;*** ERROR, metadata entry not found: &quot; + metadataPathInZip + metadataFile);
					return;
				}
				is = metadataZipFile.getInputStream(e);
			} else {
				File f = new File(new File(metadataDir, metadataPathInZip), metadataFile);
				is = new FileInputStream(f);
			}

			ByteArrayOutputStream cmdiBuffer = new ByteArrayOutputStream(INITIAL_CMDI_BYTEBUFFER_SIZE);
			is = new TeeInputStream(is, cmdiBuffer);
			try (BufferedReader reader = new BufferedReader(
					new InputStreamReader(is, Indexer.DEFAULT_INPUT_ENCODING))) {
				SAXParserFactory factory = SAXParserFactory.newInstance();
				factory.setNamespaceAware(true);
				SAXParser parser;
				parser = factory.newSAXParser();
				parser.parse(new InputSource(reader), new MetadataParser());
			}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L379">379</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.html#L351">351</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		nextId = 1;
	}

	private void mapToc(boolean writeable) throws IOException {
		tocRaf = new RandomAccessFile(tocFile, writeable ? &quot;rw&quot; : &quot;r&quot;);
		long fl = tocFile.length();
		if (writeable) {
			fl += writeMapReserve;
		} // leave 1M room at the end
		tocFileChannel = tocRaf.getChannel();
		tocFileBuffer = tocFileChannel.map(writeable ? MapMode.READ_WRITE : MapMode.READ_ONLY, 0, fl);
	}

	private void closeMappedToc() {
		if (tocFileBuffer == null)
			return; // not mapped
		try {
			tocFileChannel.close();
			tocFileChannel = null;
			tocRaf.close();
			tocRaf = null;

			tocFileBuffer = null;

		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Read the table of contents from the file
	 */
	private void readToc() {
		toc.clear();
		try {
			mapToc(false);
			try {
				tocFileBuffer.position(0);
				int n = tocFileBuffer.getInt();</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/MetadataFetcherCgnImdi.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/MetadataFetcherCgnImdi.html#L137">137</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/MetadataFetcherSonarCmdi.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/MetadataFetcherSonarCmdi.html#L144">144</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			ContentStore cs = docIndexer.getIndexer().getContentStore(&quot;metadata&quot;);
			int id = cs.store(cmdiBuffer.toString(Indexer.DEFAULT_INPUT_ENCODING.name()));
			luceneDoc.add(new IntField(&quot;metadataCid&quot;, id, Store.YES));

			if (metadataZipFile == null)
				is.close();
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Handles the metadata XML and adds it to the Lucene document
	 */
	class MetadataParser extends DefaultHandler {

		private StringBuilder textContent = new StringBuilder();

		private boolean hasChild = false;

		Map&lt;String, String&gt; indexFieldAs = new HashMap&lt;&gt;();

		List&lt;String&gt; elementStack = new ArrayList&lt;&gt;();

		/**
		 * Push the current element name onto the element stack
		 *
		 * @param localName
		 *            the current element name
		 */
		private void stackPush(String localName) {
			elementStack.add(localName);
		}

		/**
		 * Pop the current element name off of the element stack
		 */
		private void stackPop() {
			elementStack.remove(elementStack.size() - 1);
		}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/testutil/BatchContentStore.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchContentStore.html#L29">29</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/testutil/BatchQuery.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchQuery.html#L29">29</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>				} else {
					System.err.println(&quot;Illegal option: &quot; + arg);
					usage();
					return;
				}
			} else {
				switch (fileArgNumber) {
				case 0:
					indexDir = new File(arg);
					if (!indexDir.exists() || !indexDir.isDirectory()) {
						System.err.println(&quot;Index directory not found: &quot; + arg);
						usage();
						return;
					}
					break;
				case 1:
					inputFile = new File(arg);
					if (!inputFile.exists()) {
						System.err.println(&quot;Input file not found: &quot; + arg);
						usage();
						return;
					}
					break;
				default:
					System.err.println(&quot;Too many file arguments (supply index dir and input file)&quot;);
					usage();
					return;
				}
				fileArgNumber++;
			}
		}
		if (fileArgNumber &lt; 2) {
			System.err.println(&quot;Too few file arguments (supply index dir and input file)&quot;);
			usage();
			return;
		}

		System.err.print(&quot;Opening content store... &quot;);</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L686">686</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.html#L718">718</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			try (FileInputStream fileInputStream = new FileInputStream(contentsFile)) {
				try (FileChannel fileChannel = fileInputStream.getChannel()) {
					// Retrieve the strings requested
					for (int i = 0; i &lt; n; i++) {
						int a = start[i];
						int b = end[i];

						if (a == -1)
							a = 0;
						if (b == -1)
							b = e.entryLengthCharacters;

						// Check values
						if (a &lt; 0 || b &lt; 0) {
							throw new IllegalArgumentException(&quot;Illegal values, start = &quot; + a + &quot;, end = &quot; + b);
						}
						if (a &gt; e.entryLengthCharacters || b &gt; e.entryLengthCharacters) {
							throw new IllegalArgumentException(&quot;Value(s) out of range, start = &quot; + a
									+ &quot;, end = &quot; + b + &quot;, content length = &quot; + e.entryLengthCharacters);
						}
						if (b &lt;= a) {
							throw new IllegalArgumentException(
									&quot;Tried to read empty or negative length snippet (from &quot; + a
											+ &quot; to &quot; + b + &quot;)&quot;);
						}

						// 1 - determine what blocks to read
						int firstBlock = -1, lastBlock = -1;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/SpanQuerySorted.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQuerySorted.html#L120">120</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/SpanQueryUnique.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQueryUnique.html#L125">125</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	}

	@Override
	public boolean hitsAllSameLength() {
		return src.hitsAllSameLength();
	}

	@Override
	public int hitsLengthMin() {
		return src.hitsLengthMin();
	}

	@Override
	public int hitsLengthMax() {
		return src.hitsLengthMax();
	}

	@Override
	public boolean hitsStartPointSorted() {
		return true;
	}

	@Override
	public boolean hitsEndPointSorted() {
		return src.hitsEndPointSorted();
	}

	@Override
	public boolean hitsHaveUniqueStart() {
		return src.hitsHaveUniqueStart();
	}

	@Override
	public boolean hitsHaveUniqueEnd() {
		return src.hitsHaveUniqueEnd();
	}

	@Override
	public boolean hitsAreUnique() {
		return true;
	}

	@Override
	public long reverseMatchingCost(IndexReader reader) {
		return src.reverseMatchingCost(reader);
	}

	@Override
	public int forwardMatchingCost() {
		return src.forwardMatchingCost();
	}
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/index/DocIndexerXml.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXml.html#L160">160</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/index/DocIndexerXmlHandlers.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXmlHandlers.html#L541">541</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		escapeBuilder.delete(0, escapeBuilder.length());
		int start = 0;
		char[] srcArr = new char[source.length()];
		source.getChars(0, source.length(), srcArr, 0);
		int end = source.length();
		for (int i = 0; i &lt; end; i++) {
			char c = srcArr[i]; // source.charAt(i);
			if (c == '&lt;' || c == '&gt;' || c == '&amp;' || c == '&quot;') {
				escapeBuilder.append(srcArr, start, i - start); // source.substring(start, i));
				switch (c) {
				case '&lt;':
					escapeBuilder.append(&quot;&amp;lt;&quot;);
					break;
				case '&gt;':
					escapeBuilder.append(&quot;&amp;gt;&quot;);
					break;
				case '&amp;':
					escapeBuilder.append(&quot;&amp;amp;&quot;);
					break;
				case '&quot;':
					escapeBuilder.append(&quot;&amp;quot;&quot;);
					break;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/SpansExpansionRaw.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpansExpansionRaw.html#L95">95</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/SpansFilterNGramsRaw.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpansFilterNGramsRaw.html#L93">93</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		this.min = min;
		this.max = max == -1 ? MAX_UNLIMITED : max;
		if (min &gt; this.max)
			throw new IllegalArgumentException(&quot;min &gt; max&quot;);
		if (min &lt; 0 || this.max &lt; 0)
			throw new IllegalArgumentException(&quot;Expansions cannot be negative&quot;);
	}

	/** For test, we don't have an index reader, so use default values (all docs are 5 tokens long)
	 * @param b true if we're testing, false if not */
	public void setTest(boolean b) {
		if (lengthGetter != null)
			lengthGetter.setTest(b);
	}

	@Override
	public int docID() {
		return currentDoc;
	}

	@Override
	public int endPosition() {
		if (alreadyAtFirstHit)
			return -1; // .nextStartPosition() not called yet
		return end;
	}

	@Override
	public int nextDoc() throws IOException {
		alreadyAtFirstHit = false;
		if (currentDoc != NO_MORE_DOCS) {
			do {
				currentDoc = clause.nextDoc();
				if (currentDoc == NO_MORE_DOCS)
					return NO_MORE_DOCS;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L634">634</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.html#L666">666</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	}

	/**
	 * Retrieve content with given id
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	@Override
	public String retrieve(int id) {
		String[] rv = retrieveParts(id, new int[] { -1 }, new int[] { -1 });
		return rv == null ? null : rv[0];
	}

	/**
	 * Retrieve one or more substrings from the specified content.
	 *
	 * This is more efficient than retrieving the whole content, or retrieving parts in separate
	 * calls, because the file is only opened once and random access is used to read only the
	 * required parts.
	 *
	 * NOTE: if offset and length are both -1, retrieves the whole content. This is used by the
	 * retrieve(id) method.
	 *
	 * @param contentId
	 *            id of the entry to get substrings from
	 * @param start
	 *            the starting points of the substrings (in characters).
	 *            -1 means &quot;start of document&quot;
	 * @param end
	 *            the end points of the substrings (in characters).
	 *            -1 means &quot;end of document&quot;
	 * @return the parts
	 */
	@Override
	public synchronized String[] retrieveParts(int contentId, int[] start, int[] end) {
		try {
			// Find the correct TOC entry
			TocEntry e = toc.get(contentId);
			if (e == null || e.deleted)
				return null;

			// Sanity-check parameters
			int n = start.length;
			if (n != end.length)
				throw new IllegalArgumentException(&quot;start and end must be of equal length&quot;);

			// Create array for results
			String[] result = new String[n];

			// Open the file
			try (FileInputStream fileInputStream = new FileInputStream(contentsFile)) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/fimatch/NfaStateAndAcyclic.java</td>
<td><a href="./xref/nl/inl/blacklab/search/fimatch/NfaStateAndAcyclic.html#L73">73</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/fimatch/NfaStateOrAcyclic.java</td>
<td><a href="./xref/nl/inl/blacklab/search/fimatch/NfaStateOrAcyclic.html#L81">81</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		NfaStateAndAcyclic copy = new NfaStateAndAcyclic();
		copiesMade.put(this, copy);
		List&lt;NfaState&gt; clauseCopies = new ArrayList&lt;&gt;();
		for (NfaState clause: clauses) {
			clause = clause.copy(null, copiesMade);
			clauseCopies.add(clause);
		}
		copy.clauses.addAll(clauseCopies);
		copy.nextState = nextState;
		if (nextState == null &amp;&amp; dangling != null)
			dangling.add(copy);
		return copy;
	}

	@Override
	public void setNextState(int input, NfaState state) {
		clauses.set(input, state);
	}

	@Override
	public boolean matchesEmptySequence(Set&lt;NfaState&gt; statesVisited) {
		if (statesVisited.contains(this)) {
			// We've found a cycle. Stop processing, and just return the
			// &quot;safest&quot; (least-guarantee) answer. In this case: we can't
			// guarantee that this DOESN'T match the empty sequence.
			return true;
		}
		statesVisited.add(this);</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L451">451</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.html#L413">413</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>					freeBlocks.add(i);
			}

		} catch (Exception e) {
			throw ExUtil.wrapRuntimeException(e);
		}
	}

	private void writeToc() {
		try {
			mapToc(true);
			tocFileBuffer.putInt(toc.size());
			try {
				for (TocEntry e : toc.values()) {
					if (tocFileBuffer.remaining() &lt; e.sizeBytes()) {
						// Close and re-open with extra writing room
						int p = tocFileBuffer.position();
						closeMappedToc();
						mapToc(true);
						tocFileBuffer.position(p);
					}
					e.serialize(tocFileBuffer);
				}
			} finally {
				closeMappedToc();
			}
		} catch (Exception e) {
			throw ExUtil.wrapRuntimeException(e);
		}
		tocModified = false;
	}

	/**
	 * Close the content store. Writes the table of contents (if modified)
	 */
	@Override
	public void close() {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/index/DocIndexerXml.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXml.html#L206">206</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/index/DocIndexerXmlHandlers.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXmlHandlers.html#L588">588</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		escapeBuilder.delete(0, escapeBuilder.length());
		int end = start + length;
		for (int i = start; i &lt; end; i++) {
			char c = source[i];
			if (c == '&lt;' || c == '&gt;' || c == '&amp;' || c == '&quot;') {
				escapeBuilder.append(source, start, i - start);
				switch (c) {
				case '&lt;':
					escapeBuilder.append(&quot;&amp;lt;&quot;);
					break;
				case '&gt;':
					escapeBuilder.append(&quot;&amp;gt;&quot;);
					break;
				case '&amp;':
					escapeBuilder.append(&quot;&amp;amp;&quot;);
					break;
				case '&quot;':
					escapeBuilder.append(&quot;&amp;quot;&quot;);
					break;
				}
				start = i + 1;
			}
		}
		escapeBuilder.append(source, start, end - start);
		return escapeBuilder.toString();
	}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/matchfilter/MatchFilterAnd.java</td>
<td><a href="./xref/nl/inl/blacklab/search/matchfilter/MatchFilterAnd.html#L40">40</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/matchfilter/MatchFilterImplication.java</td>
<td><a href="./xref/nl/inl/blacklab/search/matchfilter/MatchFilterImplication.html#L40">40</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		MatchFilterAnd other = (MatchFilterAnd) obj;
		if (a == null) {
			if (other.a != null)
				return false;
		} else if (!a.equals(other.a))
			return false;
		if (b == null) {
			if (other.b != null)
				return false;
		} else if (!b.equals(other.b))
			return false;
		return true;
	}

	@Override
	public void setHitQueryContext(HitQueryContext context) {
		a.setHitQueryContext(context);
		b.setHitQueryContext(context);
	}

	@Override
	public ConstraintValue evaluate(ForwardIndexDocument fiDoc, Span[] capturedGroups) {
		ConstraintValue ra = a.evaluate(fiDoc, capturedGroups);
		if (!ra.isTruthy())
			return ra;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/index/DocIndexerPlainTextBasic.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerPlainTextBasic.html#L240">240</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/index/DocIndexerXmlHandlers.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXmlHandlers.html#L169">169</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/index/config/DocIndexerBase.java</td>
<td><a href="./xref/nl/inl/blacklab/index/config/DocIndexerBase.html#L393">393</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>			MetadataFetcher m = getMetadataFetcher();
			if (m != null) {
				m.addMetadata();
			}

			// See what metadatafields are missing or empty and add unknown value
			// if desired.
			IndexStructure struct = indexer.getSearcher().getIndexStructure();
			for (String fieldName: struct.getMetadataFields()) {
				MetadataFieldDesc fd = struct.getMetadataFieldDesc(fieldName);
				boolean missing = false, empty = false;
				String currentValue = currentLuceneDoc.get(fieldName);
				if (currentValue == null)
					missing = true;
				else if (currentValue.length() == 0)
					empty = true;
				UnknownCondition cond = fd.getUnknownCondition();
				boolean useUnknownValue = false;
				switch (cond) {
				case EMPTY:
					useUnknownValue = empty;
					break;
				case MISSING:
					useUnknownValue = missing;
					break;
				case MISSING_OR_EMPTY:
					useUnknownValue = missing | empty;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/SpanQueryTags.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQueryTags.html#L55">55</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/SpanQueryTagsOld.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQueryTagsOld.html#L75">75</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		this.attr = attr != null &amp;&amp; attr.isEmpty() ? null : attr;
	}

	@Override
	public BLSpanQuery rewrite(IndexReader reader) throws IOException {
		if (attr == null)
			return this;

		// Construct attribute filters
		List&lt;BLSpanQuery&gt; attrFilters = new ArrayList&lt;&gt;();
		for (Map.Entry&lt;String,String&gt; e: attr.entrySet()) {
			String value = &quot;@&quot; + e.getKey() + &quot;__&quot; + e.getValue();
			attrFilters.add(new BLSpanTermQuery(new Term(startTagFieldName, value)));
		}

		// Filter the tags
		// (NOTE: only works for start tags and full elements because attribute values
		//  are indexed at the start tag!)
		BLSpanQuery filter;
		if (attrFilters.size() == 1)
			filter = attrFilters.get(0);
		else
			filter = new SpanQueryAnd(attrFilters);
		return new SpanQueryPositionFilter(new SpanQueryTags(startTagFieldName, tagName, null), filter, SpanQueryPositionFilter.Operation.STARTS_AT, false);</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDir.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDir.html#L306">306</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L634">634</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>	}

	/**
	 * Retrieve content with given id
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	@Override
	public String retrieve(int id) {
		String[] rv = retrieveParts(id, new int[] { -1 }, new int[] { -1 });
		return rv == null ? null : rv[0];
	}

	/**
	 * Retrieve one or more substrings from the specified content.
	 *
	 * This is more efficient than retrieving the whole content, or retrieving parts in separate
	 * calls, because the file is only opened once and random access is used to read only the
	 * required parts.
	 *
	 * NOTE: if offset and length are both -1, retrieves the whole content. This is used by the
	 * retrieve(id) method.
	 *
	 * @param contentId
	 *            id of the entry to get substrings from
	 * @param start
	 *            the starting points of the substrings (in characters)
	 * @param end
	 *            the end points of the substrings (in characters)
	 * @return the parts
	 */
	@Override
	public synchronized String[] retrieveParts(int contentId, int[] start, int[] end) {
		try {
			TocEntry e = toc.get(contentId);
			if (e == null || e.deleted)
				return null;

			int n = start.length;
			if (n != end.length)
				throw new IllegalArgumentException(&quot;start and end must be of equal length&quot;);
			String[] result = new String[n];</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/search/matchfilter/MatchFilterAnd.java</td>
<td><a href="./xref/nl/inl/blacklab/search/matchfilter/MatchFilterAnd.html#L40">40</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/matchfilter/MatchFilterImplication.java</td>
<td><a href="./xref/nl/inl/blacklab/search/matchfilter/MatchFilterImplication.html#L40">40</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/matchfilter/MatchFilterOr.java</td>
<td><a href="./xref/nl/inl/blacklab/search/matchfilter/MatchFilterOr.html#L40">40</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		MatchFilterAnd other = (MatchFilterAnd) obj;
		if (a == null) {
			if (other.a != null)
				return false;
		} else if (!a.equals(other.a))
			return false;
		if (b == null) {
			if (other.b != null)
				return false;
		} else if (!b.equals(other.b))
			return false;
		return true;
	}

	@Override
	public void setHitQueryContext(HitQueryContext context) {
		a.setHitQueryContext(context);
		b.setHitQueryContext(context);
	}

	@Override
	public ConstraintValue evaluate(ForwardIndexDocument fiDoc, Span[] capturedGroups) {
		ConstraintValue ra = a.evaluate(fiDoc, capturedGroups);
		if (!ra.isTruthy())</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/BLSpanMultiTermQueryWrapper.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/BLSpanMultiTermQueryWrapper.html#L92">92</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/BLSpanTermQuery.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/BLSpanTermQuery.html#L139">139</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			BLSpanMultiTermQueryWrapper&lt;?&gt; other = (BLSpanMultiTermQueryWrapper&lt;?&gt;)obj;
			return query.equals(other.query);
		}
		return false;
	}

	@Override
	public boolean hitsAllSameLength() {
		return true;
	}

	@Override
	public int hitsLengthMin() {
		return 1;
	}

	@Override
	public int hitsLengthMax() {
		return 1;
	}

	@Override
	public boolean hitsEndPointSorted() {
		return true;
	}

	@Override
	public boolean hitsStartPointSorted() {
		return true;
	}

	@Override
	public boolean hitsHaveUniqueStart() {
		return true;
	}

	@Override
	public boolean hitsHaveUniqueEnd() {
		return true;
	}

	@Override
	public boolean hitsAreUnique() {
		return true;
	}

	@Override
	public Nfa getNfa(ForwardIndexAccessor fiAccessor, int direction) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirFixedBlock.html#L335">335</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirZip.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirZip.html#L51">51</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		final int POOL_SIZE = 10;
		compresserPool = new SimpleResourcePool&lt;Deflater&gt;(POOL_SIZE){
			@Override
			public Deflater createResource() {
				return new Deflater();
			}

			@Override
			public void destroyResource(Deflater resource) {
				resource.end();
			}
		};
		decompresserPool = new SimpleResourcePool&lt;Inflater&gt;(POOL_SIZE){
			@Override
			public Inflater createResource() {
				return new Inflater();
			}

			@Override
			public void destroyResource(Inflater resource) {
				resource.end();
			}
		};
		zipbufPool = new SimpleResourcePool&lt;byte[]&gt;(POOL_SIZE){
			@Override
			public byte[] createResource() {
				return new byte[MAX_BLOCK_SIZE_BYTES+1]; // one larger to detect when buffer space was insufficient</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerFolia.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerFolia.html#L102">102</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L200">200</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			}
		});

		// t (token) element directly under w (word) element: contains the word form
		addHandler(&quot;w/t&quot;, new ContentCapturingHandler() {

			/** Tokens with a class attribute are (usually?) the original scanned token before correction,
			 *  so we skip them */
			boolean isOcr;

			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				isOcr = attributes.getValue(&quot;class&quot;) != null;
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (!isOcr)
					wordform = getElementContent();
			}
		});

		// Sentence tags: index as tags in the content
		addHandler(&quot;s&quot;, new InlineTagHandler());

		// Paragraph tags: index as tags in the content
		addHandler(&quot;p&quot;, new InlineTagHandler());

		// meta elements: metadata fields
		addHandler(&quot;meta&quot;, new ContentCapturingHandler() {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/fimatch/NfaStateAnd.java</td>
<td><a href="./xref/nl/inl/blacklab/search/fimatch/NfaStateAnd.html#L154">154</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/fimatch/NfaStateOr.java</td>
<td><a href="./xref/nl/inl/blacklab/search/fimatch/NfaStateOr.html#L155">155</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		return &quot;AND(&quot; + b.toString() + &quot;)&quot;;
	}

	@Override
	void lookupPropertyNumbersInternal(ForwardIndexAccessor fiAccessor, Map&lt;NfaState, Boolean&gt; statesVisited) {
		for (NfaState s: nextStates) {
			if (s != null)
				s.lookupPropertyNumbers(fiAccessor, statesVisited);
		}
	}

	@Override
	protected void finishInternal(Set&lt;NfaState&gt; visited) {
		for (int i = 0; i &lt; nextStates.size(); i++) {
			NfaState s = nextStates.get(i);
			if (s == null)
				nextStates.set(i, match());
			else
				s.finish(visited);
		}
	}

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L144">144</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerWhiteLab2.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerWhiteLab2.html#L200">200</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>				if (numLemmaAnnotations == 2 &amp;&amp; isFrog ||
					numLemmaAnnotations == 1 &amp;&amp; isSetLess) {
					// If there were 2 lemma annotation meta declarations,
					// we should use the frog ones; if only 1, the ones
					// without a &quot;set&quot; attribute.
					lemma = attributes.getValue(&quot;class&quot;);
					if (lemma == null)
						lemma = &quot;&quot;;
				}
			}
		});

		// pos element: contains part of speech
		addHandler(&quot;pos&quot;, new ElementHandler() {
			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				String set = attributes.getValue(&quot;set&quot;);
				boolean isSetLess = set == null || set.length() == 0;
				boolean isFrog = !isSetLess &amp;&amp; set.equals(&quot;http://ilk.uvt.nl/folia/sets/frog-mbpos-cgn&quot;);
				if (numPosAnnotations == 2 &amp;&amp; isFrog ||</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/fimatch/NfaStateMultiTermPattern.java</td>
<td><a href="./xref/nl/inl/blacklab/search/fimatch/NfaStateMultiTermPattern.html#L94">94</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/fimatch/NfaStateToken.java</td>
<td><a href="./xref/nl/inl/blacklab/search/fimatch/NfaStateToken.html#L97">97</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	@Override
	public void setNextState(int i, NfaState state) {
		if (i != 0)
			throw new RuntimeException(&quot;Token state only has one next state&quot;);
		nextState = state;
	}

	@Override
	public boolean matchesEmptySequence(Set&lt;NfaState&gt; statesVisited) {
		return false;
	}

	@Override
	public boolean hitsAllSameLength(Set&lt;NfaState&gt; statesVisited) {
		return true;
	}

	@Override
	public int hitsLengthMin(Set&lt;NfaState&gt; statesVisited) {
		return 1;
	}

	@Override
	public int hitsLengthMax(Set&lt;NfaState&gt; statesVisited) {
		return 1;
	}

	@Override
	protected String dumpInternal(Map&lt;NfaState, Integer&gt; stateNrs) {
		String name = getPatternType();</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/SpanQueryConstrained.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQueryConstrained.html#L107">107</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/SpanQueryPositionFilter.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQueryPositionFilter.html#L250">250</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		return clauses.get(0).hitsStartPointSorted();
	}

	@Override
	public boolean hitsHaveUniqueStart() {
		return clauses.get(0).hitsHaveUniqueStart();
	}

	@Override
	public boolean hitsHaveUniqueEnd() {
		return clauses.get(0).hitsHaveUniqueEnd();
	}

	@Override
	public boolean hitsAreUnique() {
		return clauses.get(0).hitsAreUnique();
	}

	@Override
	public long reverseMatchingCost(IndexReader reader) {
		return clauses.get(0).reverseMatchingCost(reader);
	}

	@Override
	public int forwardMatchingCost() {
		return clauses.get(0).forwardMatchingCost();
	}

	@Override
	public String getRealField() {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/index/DocIndexerPlainTextBasic.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerPlainTextBasic.html#L91">91</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/index/DocIndexerXmlHandlers.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXmlHandlers.html#L674">674</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	MetadataFetcher getMetadataFetcher() {
		if (metadataFetcher == null) {
			@SuppressWarnings(&quot;deprecation&quot;)
            String metadataFetcherClassName = getParameter(&quot;metadataFetcherClass&quot;);
			if (metadataFetcherClassName != null) {
				try {
					Class&lt;? extends MetadataFetcher&gt; metadataFetcherClass = Class.forName(metadataFetcherClassName)
							.asSubclass(MetadataFetcher.class);
					Constructor&lt;? extends MetadataFetcher&gt; ctor = metadataFetcherClass.getConstructor(DocIndexer.class);
					metadataFetcher = ctor.newInstance(this);
				} catch (Exception e) {
					throw new RuntimeException(e);
				}
			}
		}
		return metadataFetcher;
	}

	public ComplexFieldProperty getPropPunct() {
		return propPunct;
	}

	public ComplexFieldProperty getMainProperty() {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/SpansExpansionRaw.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpansExpansionRaw.html#L297">297</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/SpansFilterNGramsRaw.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpansFilterNGramsRaw.html#L356">356</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		return &quot;SpansExpansion(&quot; + clause + &quot;, &quot; + expandToLeft + &quot;, &quot; + min + &quot;, &quot; + inf(max) + &quot;)&quot;;
	}

	@Override
	public void passHitQueryContextToClauses(HitQueryContext context) {
		clause.setHitQueryContext(context);
	}

	@Override
	public void getCapturedGroups(Span[] capturedGroups) {
		if (!childClausesCaptureGroups)
			return;
		clause.getCapturedGroups(capturedGroups);
	}

	@Override
	public int width() {
		return clause.width();
	}

	@Override
	public void collect(SpanCollector collector) throws IOException {
		clause.collect(collector);
	}

	@Override
	public float positionsCost() {
		return clause.positionsCost();
	}
}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/grouping/HitPropertyHitText.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyHitText.html#L54">54</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/grouping/HitPropertyLeftContext.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyLeftContext.html#L54">54</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/grouping/HitPropertyRightContext.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyRightContext.html#L54">54</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/grouping/HitPropertyWordLeft.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyWordLeft.html#L55">55</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/grouping/HitPropertyWordRight.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyWordRight.html#L54">54</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>	public HitPropertyHitText(Hits hits, String field, String property, boolean sensitive) {
		super(hits);
		this.searcher = hits.getSearcher();
		if (property == null || property.length() == 0) {
			this.luceneFieldName = ComplexFieldUtil.mainPropertyField(searcher.getIndexStructure(), field);
			this.propName = ComplexFieldUtil.getDefaultMainPropName();
		} else {
			this.luceneFieldName = ComplexFieldUtil.propertyField(field, property);
			this.propName = property;
		}

		this.terms = searcher.getTerms(luceneFieldName);
		this.sensitive = sensitive;
	}

	public HitPropertyHitText(Hits hits, String field, boolean sensitive) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/search/matchfilter/MatchFilterAnd.java</td>
<td><a href="./xref/nl/inl/blacklab/search/matchfilter/MatchFilterAnd.html#L20">20</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/matchfilter/MatchFilterImplication.java</td>
<td><a href="./xref/nl/inl/blacklab/search/matchfilter/MatchFilterImplication.html#L20">20</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/matchfilter/MatchFilterOr.java</td>
<td><a href="./xref/nl/inl/blacklab/search/matchfilter/MatchFilterOr.html#L20">20</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		return a + &quot; &amp; &quot; + b;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((a == null) ? 0 : a.hashCode());
		result = prime * result + ((b == null) ? 0 : b.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerFolia.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerFolia.html#L102">102</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L200">200</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerWhiteLab2.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerWhiteLab2.html#L305">305</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>			}
		});

		// t (token) element directly under w (word) element: contains the word form
		addHandler(&quot;w/t&quot;, new ContentCapturingHandler() {

			/** Tokens with a class attribute are (usually?) the original scanned token before correction,
			 *  so we skip them */
			boolean isOcr;

			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				isOcr = attributes.getValue(&quot;class&quot;) != null;
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (!isOcr)
					wordform = getElementContent();
			}
		});

		// Sentence tags: index as tags in the content
		addHandler(&quot;s&quot;, new InlineTagHandler());</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/MetadataFetcherCgnImdi.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/MetadataFetcherCgnImdi.html#L202">202</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/MetadataFetcherSonarCmdi.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/MetadataFetcherSonarCmdi.html#L224">224</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>					}

					// See if we want to index this element under a different
					// name.
					String indexAs = indexFieldAs.get(localName);
					if (indexAs == null || indexAs.length() == 0)
						indexAs = localName;

					// Leaf node with content; store as metadata field.
					if (docIndexer != null) {
						docIndexer.addMetadataField(indexAs, content);
					} else {
						// TEST; print metadata value
						System.out.println(indexAs + &quot;: &quot; + content);
					}
				}
			}

			hasChild = true; // our parent has at least one child
			stackPop();
		}

		@Override
		public void characters(char[] ch, int start, int length) {
			if (!hasChild)
				textContent.append(ch, start, length);
		}
	}

}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerFolia.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerFolia.html#L131">131</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L232">232</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerWhiteLab2.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerWhiteLab2.html#L358">358</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		addHandler(&quot;p&quot;, new InlineTagHandler());

		// meta elements: metadata fields
		addHandler(&quot;meta&quot;, new ContentCapturingHandler() {

			private String metadataFieldName;

			/** Open tag: add metadata field */
			@Override
			public void startElement(String uri, String localName, String qName, Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				metadataFieldName = attributes.getValue(&quot;id&quot;);
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (metadataFieldName != null)
					addMetadataField(metadataFieldName, getElementContent());
			}
		});
	}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L75">75</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerWhiteLab2.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerWhiteLab2.html#L101">101</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		final ComplexFieldProperty propPartOfSpeech = addProperty(&quot;pos&quot;);

		// Doc element: the individual documents to index
		addHandler(&quot;/FoLiA&quot;, new DocumentElementHandler());

		// PoS annotation metadata: see which annotation we need to use.
		addHandler(&quot;pos-annotation&quot;, new ElementHandler() {
			@Override
			public void startElement(String uri, String localName,
					String qName, Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				numPosAnnotations++;
			}
		});

		// Lemma annotation metadata: see which annotation we need to use.
		addHandler(&quot;lemma-annotation&quot;, new ElementHandler() {
			@Override
			public void startElement(String uri, String localName,
					String qName, Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				numLemmaAnnotations++;
			}
		});

		// Word elements: index as main contents
		addHandler(&quot;w&quot;, new WordHandlerBase() {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/MetadataFetcherCgnImdi.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/MetadataFetcherCgnImdi.html#L175">175</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/MetadataFetcherSonarCmdi.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/MetadataFetcherSonarCmdi.html#L191">191</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			elementStack.remove(elementStack.size() - 1);
		}

		public MetadataParser() {
			indexFieldAs.put(&quot;iso-639-3-code&quot;, &quot;Language-iso-code&quot;);
			indexFieldAs.put(&quot;Name&quot;, &quot;AuthorName&quot;);
		}

		@Override
		public void startElement(String uri, String localName, String qName, Attributes attributes) {
			stackPush(localName);
			hasChild = false; // we haven't seen a child for this element yet
			textContent.setLength(0); // clear buffer
		}

		@Override
		public void endElement(String uri, String localName, String qName) {

			if (!hasChild) {
				// See if we captured any text content
				String content = textContent.toString().trim();
				if (content.length() &gt; 0) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/BLSpanMultiTermQueryWrapper.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/BLSpanMultiTermQueryWrapper.html#L96">96</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/BLSpanTermQuery.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/BLSpanTermQuery.html#L143">143</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/SpanQueryNot.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpanQueryNot.html#L174">174</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>	}

	@Override
	public boolean hitsAllSameLength() {
		return true;
	}

	@Override
	public int hitsLengthMin() {
		return 1;
	}

	@Override
	public int hitsLengthMax() {
		return 1;
	}

	@Override
	public boolean hitsEndPointSorted() {
		return true;
	}

	@Override
	public boolean hitsStartPointSorted() {
		return true;
	}

	@Override
	public boolean hitsHaveUniqueStart() {
		return true;
	}

	@Override
	public boolean hitsHaveUniqueEnd() {
		return true;
	}

	@Override
	public boolean hitsAreUnique() {
		return true;
	}

	@Override
	public Nfa getNfa(ForwardIndexAccessor fiAccessor, int direction) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/search/lucene/SpansPositionFilter.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpansPositionFilter.html#L236">236</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/lucene/SpansPositionFilter.java</td>
<td><a href="./xref/nl/inl/blacklab/search/lucene/SpansPositionFilter.html#L292">292</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>			case CONTAINING:
				// Looking for producer hits with a filter hit inside
				while (min &lt;= max) {
					int i = (min + max) / 2;
					if (filterFixedLength &amp;&amp; filter.endPosition(i) &gt; producer.endPosition() + rightAdjust) {
						// Filter end position to the right of producer hit end position.
						max = i - 1;
					} else if (filter.startPosition(i) &lt; producerStart + leftAdjust) {
						// Filter start position to the left of producer hit start position.
						min = i + 1;
					} else {
						// Can't narrow down the edges any further; do linear search from here.
						break;
					}
				}
				for (int i = min; i &lt;= max; i++) {
					if (filter.startPosition(i) &gt;= producerStart + leftAdjust &amp;&amp; filter.endPosition(i) &lt;= producer.endPosition() + rightAdjust) {</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/testutil/BatchContentStore.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchContentStore.html#L35">35</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/testutil/BatchForwardIndex.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchForwardIndex.html#L30">30</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/testutil/BatchQuery.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchQuery.html#L35">35</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>				switch (fileArgNumber) {
				case 0:
					indexDir = new File(arg);
					if (!indexDir.exists() || !indexDir.isDirectory()) {
						System.err.println(&quot;Index directory not found: &quot; + arg);
						usage();
						return;
					}
					break;
				case 1:
					inputFile = new File(arg);
					if (!inputFile.exists()) {
						System.err.println(&quot;Input file not found: &quot; + arg);
						usage();
						return;
					}
					break;
				default:
					System.err.println(&quot;Too many file arguments (supply index dir and input file)&quot;);
					usage();
					return;
				}
				fileArgNumber++;
			}</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerFolia.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerFolia.html#L55">55</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L98">98</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		addHandler(&quot;/FoLiA&quot;, new DocumentElementHandler());

		// Word elements: index as main contents
		addHandler(&quot;w&quot;, new WordHandlerBase() {

			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				wordform = &quot;&quot;;
				pos = &quot;&quot;;
				lemma = &quot;&quot;;
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (wordform.length() &gt; 0) {
					propMain.addValue(wordform);
					propPartOfSpeech.addValue(pos);</pre></div></td></tr></table>
<table border="0" class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/util/TimeUtil.java</td>
<td><a href="./xref/nl/inl/util/TimeUtil.html#L42">42</a></td></tr>
<tr class="a">
<td>nl/inl/util/Timer.java</td>
<td><a href="./xref/nl/inl/util/Timer.html#L85">85</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		if (min &gt; 0) {
			result.append(min).append(&quot; &quot;).append(StringUtil.pluralize(&quot;minute&quot;, min)).append(&quot;, &quot;);
		}
		result.append(sec).append(&quot; &quot;).append(StringUtil.pluralize(&quot;second&quot;, sec));
		if (reportMsec) {
			result.append(&quot;, &quot;).append(msec).append(&quot; &quot;).append(StringUtil.pluralize(&quot;millisecond&quot;, msec));
		}
		return result.toString();
	}</pre></div></td></tr></table></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
                      <div class="row-fluid">
                                      <p >Copyright &copy;                    2018
                        <a href="http://www.inl.nl">Instituut voor Nederlandse Taal (INT)</a>.
            All rights reserved.      
                    
      </p>
                </div>

        
                </div>
    </footer>
        </body>
</html>
