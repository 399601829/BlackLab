<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.6 at 2015-07-28 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>BlackLab corpus search Java library &#x2013; CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20150728" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                BlackLab corpus search Java library
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 2015-07-28</span>
                  &nbsp;| <span id="projectVersion">Version: 1.2-SNAPSHOT</span>
                      </div>
            <div class="xright">                    <a href="./" title="BlackLab corpus search Java library">BlackLab corpus search Java library</a>
              
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                          <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                      <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                                                                                                                                                                  <li class="expanded">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                    <ul>
                      <li class="none">
                          <a href="surefire-report.html" title="Surefire Report">Surefire Report</a>
            </li>
                      <li class="none">
                          <a href="apidocs/index.html" title="JavaDocs">JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="xref/index.html" title="Source Xref">Source Xref</a>
            </li>
                      <li class="none">
                          <a href="xref-test/index.html" title="Test Source Xref">Test Source Xref</a>
            </li>
                      <li class="none">
                          <a href="findbugs.html" title="FindBugs">FindBugs</a>
            </li>
                      <li class="none">
            <strong>CPD</strong>
          </li>
                      <li class="none">
                          <a href="pmd.html" title="PMD">PMD</a>
            </li>
                      <li class="none">
                          <a href="checkstyle.html" title="Checkstyle">Checkstyle</a>
            </li>
                      <li class="none">
                          <a href="taglist.html" title="Tag List">Tag List</a>
            </li>
                      <li class="none">
                          <a href="dependency-updates-report.html" title="Dependency Updates Report">Dependency Updates Report</a>
            </li>
                      <li class="none">
                          <a href="plugin-updates-report.html" title="Plugin Updates Report">Plugin Updates Report</a>
            </li>
              </ul>
        </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section">
<h2><a name="CPD_Results"></a>CPD Results</h2>
<p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 5.3.2.</p></div>
<div class="section">
<h2><a name="Duplications"></a>Duplications</h2>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV2.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV2.html#L584">584</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV3.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV3.html#L709">709</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>				if (end[i] &gt;= e.length) // Can happen while making KWICs because we don't know the
										// doc length until here
					end[i] = e.length;
				if (start[i] &gt; e.length || end[i] &gt; e.length) {
					throw new RuntimeException(&quot;Value(s) out of range, start = &quot; + start[i]
							+ &quot;, end = &quot; + end[i] + &quot;, content length = &quot; + e.length);
				}
				if (end[i] &lt;= start[i]) {
					throw new RuntimeException(
							&quot;Tried to read empty or negative length snippet (from &quot; + start[i]
									+ &quot; to &quot; + end[i] + &quot;)&quot;);
				}

				// Get an IntBuffer to read the desired content
				IntBuffer ib = null;
				boolean inMem = false;
				if (tokensFileChunks != null) {
					// Yes, the tokens file has either been fully loaded into memory or
					// is mapped into memory. Get an int buffer into the file.
					inMem = true;

					// Figure out which chunk to access.
					ByteBuffer whichChunk = null;
					long chunkOffsetBytes = -1;
					long entryOffsetBytes = e.offset * SIZEOF_INT;
					for (int j = 0; j &lt; tokensFileChunkOffsetBytes.size(); j++) {
						long offsetBytes = tokensFileChunkOffsetBytes.get(j);
						ByteBuffer buffer = tokensFileChunks.get(j);
						if (offsetBytes &lt;= entryOffsetBytes + start[i] * SIZEOF_INT &amp;&amp; offsetBytes + buffer.capacity() &gt;= entryOffsetBytes + end[i] * SIZEOF_INT) {
							// This one!
							whichChunk = buffer;
							chunkOffsetBytes = offsetBytes;
							break;
						}
					}

					whichChunk.position((int) (e.offset * SIZEOF_INT - chunkOffsetBytes));
					ib = whichChunk.asIntBuffer();
				}

				int snippetLength = end[i] - start[i];
				int[] snippet = new int[snippetLength];
				if (TESTING_IO_IMPACT) {
					// We're testing how much impact forward index I/O has on sorting/grouping.
					// Fill the array with random token ids instead of reading them from the
					// file.
					int numberOfTerms = terms.numberOfTerms();
					for (int j = 0; j &lt; snippetLength; j++) {
						int randomTermId = (int) Math.random() * numberOfTerms;
						snippet[j] = randomTermId;
					}
				} else {
					if (inMem) {
						// The whole file is available in memory (or mem-mapped)
						// Position us at the correct place in the file.
						ib.position(start[i]);
					} else {
						// Not mapped. Explicitly read the part we require from disk into an int buffer.
						long offset = e.offset + start[i];

						int bytesToRead = snippetLength * SIZEOF_INT;
						ByteBuffer buffer = ByteBuffer.allocate(bytesToRead);
						int bytesRead = tokensFileChannel.read(buffer, offset * SIZEOF_INT);
						if (bytesRead &lt; bytesToRead) {
							throw new RuntimeException(&quot;Not enough bytes read: &quot; + bytesRead + &quot; &lt; &quot;
									+ bytesToRead);
						}
						buffer.position(0);
						ib = buffer.asIntBuffer();
					}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV2.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV2.html#L496">496</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV3.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV3.html#L644">644</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		} catch (IOException e1) {
			throw new RuntimeException(e1);
		}
	}

	@Override
	public synchronized int addDocument(List&lt;String&gt; content) {
		return addDocument(content, null);
	}

	@Deprecated
	@Override
	public synchronized List&lt;String[]&gt; retrieveParts(int fiid, int[] start, int[] end) {

		// First, retrieve the token ids
		List&lt;int[]&gt; resultInt = retrievePartsInt(fiid, start, end);

		// Translate them to strings using the terms index
		List&lt;String[]&gt; result = new ArrayList&lt;String[]&gt;(resultInt.size());
		for (int[] snippetInt: resultInt) {
			String[] snippet = new String[snippetInt.length];
			for (int j = 0; j &lt; snippetInt.length; j++) {
				snippet[j] = terms.get(snippetInt[j]);
			}
			result.add(snippet);
		}
		return result;
	}

	@Deprecated
	@Override
	public synchronized List&lt;int[]&gt; retrievePartsSortOrder(int fiid, int[] start, int[] end, boolean sensitive) {

		// First, retrieve the token ids
		List&lt;int[]&gt; resultInt = retrievePartsInt(fiid, start, end);

		// Translate them to sort orders
		for (int[] snippetInt: resultInt) {
			terms.toSortOrder(snippetInt, snippetInt, sensitive);
		}
		return resultInt;
	}

	@Override
	public void warmUp() throws InterruptedException {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV2.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV2.html#L305">305</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV3.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV3.html#L315">315</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			int min = 0, max = toc.size();
			while (max - min &gt; 1) {
				int middle = (min + max) / 2;
				long middleVal = toc.get(middle).offset * SIZEOF_INT;
				if (middleVal &lt;= mappedBytes) {
					min = middle;
				} else {
					max = middle;
				}
			}
			startOfNextMappingBytes = toc.get(min).offset * SIZEOF_INT;

			// Map this chunk
			long sizeBytes = tokenFileEndBytes - startOfNextMappingBytes;
			if (sizeBytes &gt; preferredChunkSizeBytes)
				sizeBytes = preferredChunkSizeBytes;

			ByteBuffer mapping;
			if (keepInMemory) {
				mapping = ByteBuffer.allocate((int)sizeBytes);
				tokensFileChannel.position(startOfNextMappingBytes);
				int bytesRead = tokensFileChannel.read(mapping);
				if (bytesRead != mapping.capacity()) {
					throw new RuntimeException(&quot;Could not read tokens file chunk into memory!&quot;);
				}
			} else {
				mapping = tokensFileChannel.map(FileChannel.MapMode.READ_ONLY, startOfNextMappingBytes,
						sizeBytes);
			}
			tokensFileChunks.add(mapping);
			tokensFileChunkOffsetBytes.add(startOfNextMappingBytes);
			mappedBytes = startOfNextMappingBytes + sizeBytes;
		}
	}

	/**
	 * Returns the total number of tokens stored in the file
	 * @return the number of tokens
	 */
	private long getTokenFileEndPosition() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/testutil/BatchContentStore.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchContentStore.html#L68">68</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/testutil/BatchForwardIndex.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchForwardIndex.html#L69">69</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		System.err.println(&quot;done. [#docs: &quot; + cs.getDocIds().size() + &quot;]&quot;);

		System.out.println(&quot;First\tNumber\tSkip\tSnippets\tTime&quot;);

		for (String query : FileUtil.readLines(inputFile)) {
			query = query.trim();
			if (query.length() == 0 || query.charAt(0) == '#')
				continue; // skip empty lines and #-comments
			String[] numberStr = query.split(&quot;\\s+&quot;);
			int[] numbers = new int[numberStr.length];
			try {
				for (int i = 0; i &lt; numberStr.length; i++) {
					numbers[i] = Integer.parseInt(numberStr[i]);
				}

				int first = numbers[0];
				int number = numbers.length &gt; 1 ? numbers[1] : 100;
				int skip = numbers.length &gt; 2 ? numbers[2] : 0;
				int snippets = numbers.length &gt; 3 ? numbers[3] : 5;
				long time = doPerformanceTest(cs, first, number, skip, snippets);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/externalstorage/ContentStoreDir.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDir.html#L307">307</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.java</td>
<td><a href="./xref/nl/inl/blacklab/externalstorage/ContentStoreDirUtf8.html#L663">663</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			throw ExUtil.wrapRuntimeException(e);
		}
	}

	/**
	 * Get a data File object, given the data file id.
	 *
	 * @param fileId
	 *            the data file id
	 * @return the File object
	 */
	private File getContentFile(int fileId) {
		File f = new File(dir, String.format(&quot;data%04d.dat&quot;, fileId));
		return f;
	}

	/**
	 * Retrieve content with given id
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	@Override
	public String retrieve(int id) {
		String[] rv = retrieveParts(id, new int[] { -1 }, new int[] { -1 });
		return rv == null ? null : rv[0];
	}

	/**
	 * Retrieve one or more substrings from the specified content.
	 *
	 * This is more efficient than retrieving the whole content, or retrieving parts in separate
	 * calls, because the file is only opened once and random access is used to read only the
	 * required parts.
	 *
	 * NOTE: if offset and length are both -1, retrieves the whole content. This is used by the
	 * retrieve(id) method.
	 *
	 * @param contentId
	 *            id of the entry to get substrings from
	 * @param start
	 *            the starting points of the substrings (in characters)
	 * @param end
	 *            the end points of the substrings (in characters)
	 * @return the parts
	 */
	@Override
	public synchronized String[] retrieveParts(int contentId, int[] start, int[] end) {
		try {
			TocEntry e = toc.get(contentId);
			if (e == null || e.deleted)
				return null;

			int n = start.length;
			if (n != end.length)
				throw new RuntimeException(&quot;start and end must be of equal length&quot;);
			String[] result = new String[n];</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/testutil/BatchContentStore.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchContentStore.html#L29">29</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/testutil/BatchForwardIndex.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchForwardIndex.html#L30">30</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/testutil/BatchQuery.java</td>
<td><a href="./xref/nl/inl/blacklab/testutil/BatchQuery.html#L29">29</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>				} else {
					System.err.println(&quot;Illegal option: &quot; + arg);
					usage();
					return;
				}
			} else {
				switch (fileArgNumber) {
				case 0:
					indexDir = new File(arg);
					if (!indexDir.exists() || !indexDir.isDirectory()) {
						System.err.println(&quot;Index directory not found: &quot; + arg);
						usage();
						return;
					}
					break;
				case 1:
					inputFile = new File(arg);
					if (!inputFile.exists()) {
						System.err.println(&quot;Input file not found: &quot; + arg);
						usage();
						return;
					}
					break;
				default:
					System.err.println(&quot;Too many file arguments (supply index dir and input file)&quot;);
					usage();
					return;
				}
				fileArgNumber++;
			}
		}
		if (fileArgNumber &lt; 2) {
			System.err.println(&quot;Too few file arguments (supply index dir and input file)&quot;);
			usage();
			return;
		}

		System.err.print(&quot;Opening content store... &quot;);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV2.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV2.html#L668">668</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV3.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV3.html#L794">794</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		ForwardIndex fi = new ForwardIndexImplV2(new File(&quot;E:\\temp&quot;), true, null, false);
		try {
			String test = &quot;the quick brown fox jumps over the lazy dog . the brown quick dog jumps beside the lazy fox&quot;;
			int doc = fi.addDocument(Arrays.asList(test.split(&quot;\\s+&quot;)));
			System.out.println(&quot;Stored &quot; + doc);

			test = &quot;fox jumps over dog&quot;;
			doc = fi.addDocument(Arrays.asList(test.split(&quot;\\s+&quot;)));
			System.out.println(&quot;Stored &quot; + doc);
		} finally {
			fi.close();
		}
	}

	@Override
	public Terms getTerms() {
		return terms;
	}

	@Override
	public int getNumDocs() {
		return toc.size();
	}

	@Override
	public int getDocLength(int fiid) {
		return toc.get(fiid).length;
	}

	@Override
	public void deleteDocument(int fiid) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/analysis/BLLatinAnalyzer.java</td>
<td><a href="./xref/nl/inl/blacklab/analysis/BLLatinAnalyzer.html#L76">76</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/analysis/BLStandardAnalyzer.java</td>
<td><a href="./xref/nl/inl/blacklab/analysis/BLStandardAnalyzer.html#L93">93</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		Analyzer a = new BLLatinAnalyzer();
		try {
			TokenStream ts = a.tokenStream(&quot;test&quot;, new StringReader(TEST_STR));
			CharTermAttribute ta = ts.addAttribute(CharTermAttribute.class);
			while (ts.incrementToken()) {
				System.out.println(new String(ta.buffer(), 0, ta.length()));
			}
			TokenStream ts2 = a.tokenStream(ComplexFieldUtil.propertyField(&quot;test&quot;, null, &quot;s&quot;),
					new StringReader(TEST_STR));
			ta = ts2.addAttribute(CharTermAttribute.class);
			while (ts2.incrementToken()) {
				System.out.println(new String(ta.buffer(), 0, ta.length()));
			}
		} finally {
			a.close();
		}
	}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/index/DocIndexerXml.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXml.html#L158">158</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/index/DocIndexerXmlHandlers.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXmlHandlers.html#L559">559</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		escapeBuilder.delete(0, escapeBuilder.length());
		int start = 0;
		char[] srcArr = new char[source.length()];
		source.getChars(0, source.length(), srcArr, 0);
		int end = source.length();
		for (int i = 0; i &lt; end; i++) {
			char c = srcArr[i]; // source.charAt(i);
			if (c == '&lt;' || c == '&gt;' || c == '&amp;' || c == '&quot;') {
				escapeBuilder.append(srcArr, start, i - start); // source.substring(start, i));
				switch (c) {
				case '&lt;':
					escapeBuilder.append(&quot;&amp;lt;&quot;);
					break;
				case '&gt;':
					escapeBuilder.append(&quot;&amp;gt;&quot;);
					break;
				case '&amp;':
					escapeBuilder.append(&quot;&amp;amp;&quot;);
					break;
				case '&quot;':
					escapeBuilder.append(&quot;&amp;quot;&quot;);
					break;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/index/DocIndexerXml.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXml.html#L204">204</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/index/DocIndexerXmlHandlers.java</td>
<td><a href="./xref/nl/inl/blacklab/index/DocIndexerXmlHandlers.html#L606">606</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		escapeBuilder.delete(0, escapeBuilder.length());
		int end = start + length;
		for (int i = start; i &lt; end; i++) {
			char c = source[i];
			if (c == '&lt;' || c == '&gt;' || c == '&amp;' || c == '&quot;') {
				escapeBuilder.append(source, start, i - start);
				switch (c) {
				case '&lt;':
					escapeBuilder.append(&quot;&amp;lt;&quot;);
					break;
				case '&gt;':
					escapeBuilder.append(&quot;&amp;gt;&quot;);
					break;
				case '&amp;':
					escapeBuilder.append(&quot;&amp;amp;&quot;);
					break;
				case '&quot;':
					escapeBuilder.append(&quot;&amp;quot;&quot;);
					break;
				}
				start = i + 1;
			}
		}
		escapeBuilder.append(source, start, end - start);
		return escapeBuilder.toString();
	}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV2.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV2.html#L167">167</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV3.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV3.html#L160">160</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>			int numToCheck = Math.min(ForwardIndexImplV3.NUMBER_OF_CACHE_ENTRIES_TO_CHECK, srw.maxDoc());
			for (int i = 0; i &lt; numToCheck; i++) {
				// (NOTE: we don't check if document wasn't deleted, but that shouldn't matter here)
				if (cachedFiids.get(i) != 0) {
					allZeroes = false;
					break;
				}
			}
			if (allZeroes) {
				// Tokens lengths weren't saved in the index, skip cache
				cachedFiids = null;
			}

		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	@Override
	public int luceneDocIdToFiid(int docId) {
		if (cachedFiids != null)
			return cachedFiids.get(docId);

		// Not cached; find fiid by reading stored value from Document now
		try {
			return Integer.parseInt(reader.document(docId).get(fiidFieldName));
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	public ForwardIndexImplV2(File dir, boolean indexMode, Collator collator, boolean create) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/perdocument/DocPropertyMultiple.java</td>
<td><a href="./xref/nl/inl/blacklab/perdocument/DocPropertyMultiple.html#L111">111</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/grouping/HitPropertyMultiple.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyMultiple.html#L149">149</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		for (DocProperty crit : criteria) {
			if (b.length() &gt; 0)
				b.append(&quot;, &quot;);
			b.append(crit.getName());
		}
		return b.toString();
	}

	@Override
	public String serialize() {
		String[] values = new String[criteria.size()];
		for (int i = 0; i &lt; criteria.size(); i++) {
			values[i] = criteria.get(i).serialize();
		}
		return (reverse ? &quot;-(&quot; : &quot;&quot;) + PropValSerializeUtil.combineMultiple(values) + (reverse ? &quot;)&quot; : &quot;&quot;);
	}

	public static DocPropertyMultiple deserialize(String info) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/util/ChunkedIntList.java</td>
<td><a href="./xref/nl/inl/util/ChunkedIntList.html#L169">169</a></td></tr>
<tr class="b">
<td>nl/inl/util/ChunkedList.java</td>
<td><a href="./xref/nl/inl/util/ChunkedList.html#L172">172</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>			int[] chunk = chunks.get(i);

			// Find chunk size
			int thisChunkSize = chunkSize;
			if (i == chunkContainingFirstUnusedSlot) {
				// Chunk is not full.
				thisChunkSize = size % chunkSize;
			} else {
				// Full chunk. Move last element in chunk to next chunk
				chunks.get(i + 1)[0] = chunk[chunkSize - 1];
			}

			// Move rest of the elements in chunk one position forward
			int srcPos = 0;
			if (i == targetChunk)
				srcPos = indexInTargetChunk;
			int length = thisChunkSize - srcPos - (i == chunkContainingFirstUnusedSlot ? 0 : 1);
			if (length &gt; 0)
				System.arraycopy(chunk, srcPos, chunk, srcPos + 1, length);
		}

		// Finally, set the element and increment the list size
		chunks.get(targetChunk)[indexInTargetChunk] = element;
		size++;
	}

	@Override
	public Integer remove(int index) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV2.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV2.html#L539">539</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV3.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV3.html#L263">263</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>	@Override
	public void warmUp() throws InterruptedException {
		int fiid = 0;
		int oneReadPerHowManyChars = 4000;
		for (TocEntry e: toc) {
			int n = e.length / oneReadPerHowManyChars;

			int[] starts = new int[n];
			int[] ends = new int[n];
			for (int i = 0; i &lt; n; i++) {
				starts[i] = i * oneReadPerHowManyChars;
				ends[i] = starts[i] + 10;
			}
			retrievePartsInt(fiid, starts, ends);
			fiid++;
			if (fiid % 100 == 0) {
				// Allow a little bit of other processing to go on,
				// and check for thread interruption
				Thread.sleep(1);
			}
		}
	}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerFolia.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerFolia.html#L99">99</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L161">161</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>			}
		});

		// t (token) element directly under w (word) element: contains the word form
		addHandler(&quot;w/t&quot;, new ContentCapturingHandler() {

			/** Tokens with a class attribute are (usually?) the original scanned token before correction,
			 *  so we skip them */
			boolean isOcr;

			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				isOcr = attributes.getValue(&quot;class&quot;) != null;
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (!isOcr)
					wordform = getElementContent();
			}
		});

		// Sentence tags: index as tags in the content
		addHandler(&quot;s&quot;, new InlineTagHandler());

		// Paragraph tags: index as tags in the content
		addHandler(&quot;p&quot;, new InlineTagHandler());

		// meta elements: metadata fields
		addHandler(&quot;meta&quot;, new ContentCapturingHandler() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV2.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV2.html#L560">560</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/forwardindex/ForwardIndexImplV3.java</td>
<td><a href="./xref/nl/inl/blacklab/forwardindex/ForwardIndexImplV3.html#L686">686</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>	}

	@Override
	public synchronized List&lt;int[]&gt; retrievePartsInt(int fiid, int[] start, int[] end) {
		try {
			TocEntry e = toc.get(fiid);
			if (e == null || e.deleted)
				return null;

			int n = start.length;
			if (n != end.length)
				throw new RuntimeException(&quot;start and end must be of equal length&quot;);
			List&lt;int[]&gt; result = new ArrayList&lt;int[]&gt;(n);

			for (int i = 0; i &lt; n; i++) {
				if (start[i] == -1 &amp;&amp; end[i] == -1) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerFolia.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerFolia.html#L52">52</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L88">88</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		addHandler(&quot;/FoLiA&quot;, new DocumentElementHandler());

		// Word elements: index as main contents
		addHandler(&quot;w&quot;, new WordHandlerBase() {

			@Override
			public void startElement(String uri, String localName, String qName,
					Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				wordform = &quot;&quot;;
				pos = &quot;&quot;;
				lemma = &quot;&quot;;
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (wordform.length() &gt; 0) {
					propMain.addValue(wordform);
					propPartOfSpeech.addValue(pos);
					propLemma.addValue(lemma);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>nl/inl/blacklab/search/grouping/HitPropertyHitText.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyHitText.html#L54">54</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/grouping/HitPropertyLeftContext.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyLeftContext.html#L54">54</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/grouping/HitPropertyRightContext.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyRightContext.html#L54">54</a></td></tr>
<tr class="b">
<td>nl/inl/blacklab/search/grouping/HitPropertyWordLeft.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyWordLeft.html#L55">55</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/search/grouping/HitPropertyWordRight.java</td>
<td><a href="./xref/nl/inl/blacklab/search/grouping/HitPropertyWordRight.html#L54">54</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	public HitPropertyHitText(Hits hits, String field, String property, boolean sensitive) {
		super(hits);
		this.searcher = hits.getSearcher();
		if (property == null || property.length() == 0) {
			this.luceneFieldName = ComplexFieldUtil.mainPropertyField(searcher.getIndexStructure(), field);
			this.propName = ComplexFieldUtil.getDefaultMainPropName();
		} else {
			this.luceneFieldName = ComplexFieldUtil.propertyField(field, property);
			this.propName = property;
		}

		this.terms = searcher.getTerms(luceneFieldName);
		this.sensitive = sensitive;
	}

	public HitPropertyHitText(Hits hits, String field, boolean sensitive) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/util/ChunkedIntList.java</td>
<td><a href="./xref/nl/inl/util/ChunkedIntList.html#L211">211</a></td></tr>
<tr class="a">
<td>nl/inl/util/ChunkedList.java</td>
<td><a href="./xref/nl/inl/util/ChunkedList.html#L214">214</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			int[] chunk = chunks.get(i);

			// Find chunk size
			int thisChunkSize = chunkSize;
			if (i == chunkContainingFirstUnusedSlot) {
				// Chunk is not full.
				thisChunkSize = size % chunkSize;
			}

			// Move elements in chunk one position backward
			int srcPos = 1;
			if (i == targetChunk)
				srcPos = indexInTargetChunk + 1;
			int length = thisChunkSize - srcPos;
			if (length &gt; 0)
				System.arraycopy(chunk, srcPos, chunk, srcPos - 1, length);

			if (i != chunkContainingLastElement) {
				// Next chunk has at least one element. Move first element to last position of this
				// chunk.
				chunk[chunkSize - 1] = chunks.get(i + 1)[0];
			}
		}

		size--;

		return deleted;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/blacklab/indexers/DocIndexerFolia.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerFolia.html#L128">128</a></td></tr>
<tr class="a">
<td>nl/inl/blacklab/indexers/DocIndexerOpenSonar.java</td>
<td><a href="./xref/nl/inl/blacklab/indexers/DocIndexerOpenSonar.html#L193">193</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		addHandler(&quot;p&quot;, new InlineTagHandler());

		// meta elements: metadata fields
		addHandler(&quot;meta&quot;, new ContentCapturingHandler() {

			private String metadataFieldName;

			/** Open tag: add metadata field */
			@Override
			public void startElement(String uri, String localName, String qName, Attributes attributes) {
				super.startElement(uri, localName, qName, attributes);
				metadataFieldName = attributes.getValue(&quot;id&quot;);
			}

			@Override
			public void endElement(String uri, String localName, String qName) {
				super.endElement(uri, localName, qName);
				if (metadataFieldName != null)
					addMetadataField(metadataFieldName, getElementContent());
			}
		});
	}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>nl/inl/util/TimeUtil.java</td>
<td><a href="./xref/nl/inl/util/TimeUtil.html#L47">47</a></td></tr>
<tr class="a">
<td>nl/inl/util/Timer.java</td>
<td><a href="./xref/nl/inl/util/Timer.html#L86">86</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		if (min &gt; 0) {
			result.append(min).append(&quot; &quot;).append(StringUtil.pluralize(&quot;minute&quot;, min)).append(&quot;, &quot;);
		}
		result.append(sec).append(&quot; &quot;).append(StringUtil.pluralize(&quot;second&quot;, sec));
		if (reportMsec) {
			result.append(&quot;, &quot;).append(msec).append(&quot; &quot;).append(StringUtil.pluralize(&quot;millisecond&quot;, msec));
		}
		return result.toString();
	}</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2015
                        <a href="http://www.inl.nl">INL</a>.
            All rights reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
