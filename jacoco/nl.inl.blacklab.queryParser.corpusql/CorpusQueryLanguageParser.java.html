<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CorpusQueryLanguageParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.queryParser.corpusql</a> &gt; <span class="el_source">CorpusQueryLanguageParser.java</span></div><h1>CorpusQueryLanguageParser.java</h1><pre class="source lang-java linenums">/* CorpusQueryLanguageParser.java */
/* Generated By:JavaCC: Do not edit this line. CorpusQueryLanguageParser.java */
package nl.inl.blacklab.queryParser.corpusql;

import java.util.Map;
import java.util.HashMap;
import nl.inl.blacklab.index.complex.ComplexFieldUtil;

import nl.inl.blacklab.search.TextPattern;
import nl.inl.blacklab.search.TextPatternAnd;
import nl.inl.blacklab.search.TextPatternAnyToken;
import nl.inl.blacklab.search.TextPatternCaptureGroup;
import nl.inl.blacklab.search.TextPatternConstrained;
import nl.inl.blacklab.search.TextPatternEdge;
import nl.inl.blacklab.search.TextPatternNot;
import nl.inl.blacklab.search.TextPatternOr;
import nl.inl.blacklab.search.TextPatternPositionFilter;
import nl.inl.blacklab.search.TextPatternProperty;
import nl.inl.blacklab.search.TextPatternRegex;
import nl.inl.blacklab.search.TextPatternRepetition;
import nl.inl.blacklab.search.TextPatternSequence;
import nl.inl.blacklab.search.TextPatternTags;
import nl.inl.blacklab.search.indexstructure.IndexStructure;
import nl.inl.blacklab.search.lucene.BLSpanQuery;
import nl.inl.blacklab.search.lucene.SpanQueryPositionFilter.Operation;
import nl.inl.blacklab.search.matchfilter.MatchFilter;
import nl.inl.blacklab.search.matchfilter.MatchFilterAnd;
import nl.inl.blacklab.search.matchfilter.MatchFilterEquals;
import nl.inl.blacklab.search.matchfilter.MatchFilterImplication;
import nl.inl.blacklab.search.matchfilter.MatchFilterNot;
import nl.inl.blacklab.search.matchfilter.MatchFilterOr;
import nl.inl.blacklab.search.matchfilter.MatchFilterString;
import nl.inl.blacklab.search.matchfilter.MatchFilterTokenProperty;

@SuppressWarnings(&quot;all&quot;)

public class CorpusQueryLanguageParser implements CorpusQueryLanguageParserConstants {

    public static void main(String[] args) throws nl.inl.blacklab.queryParser.corpusql.ParseException
    {
<span class="nc" id="L41">  CorpusQueryLanguageParser parser = new CorpusQueryLanguageParser(new java.io.StringReader(args[0]));</span>
<span class="nc" id="L42">  parser.query();</span>
<span class="nc" id="L43">    }</span>

    public static TextPattern parse(String query) throws nl.inl.blacklab.queryParser.corpusql.ParseException
    {
<span class="fc" id="L47">        CorpusQueryLanguageParser parser = new CorpusQueryLanguageParser(new java.io.StringReader(query));</span>
<span class="fc" id="L48">        return parser.query();</span>
    }

    private int num(Token t)
    {
<span class="fc" id="L53">     return Integer.parseInt(t.toString());</span>
    }

    private String chopEnds(String input)
    {
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">     if (input.length() &gt;= 2)</span>
<span class="fc" id="L59">      return input.substring(1, input.length() - 1);</span>
<span class="nc" id="L60">     throw new RuntimeException();</span>
    }

    private String getStringBetweenQuotes(String input) throws SingleQuotesException
    {
<span class="pc bpc" id="L65" title="3 of 4 branches missed.">        if (!allowSingleQuotes &amp;&amp; input.charAt(0) == '\'')</span>
<span class="nc" id="L66">            throw new SingleQuotesException();</span>
<span class="fc" id="L67">        return chopEnds(input);</span>
    }

    private TextPattern simplePattern(String str)
    {
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (str.length() &gt; 0) {</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">            if (str.charAt(0) != '^')</span>
<span class="fc" id="L74">                str = &quot;^&quot; + str;</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">            if (str.charAt(str.length() - 1) != '$')</span>
<span class="fc" id="L76">                str += &quot;$&quot;;</span>
        }

        // Treat everything like regex now; will be simplified later if possible
<span class="fc" id="L80">        return new TextPatternRegex(str);</span>
    }

    /** Allow strings to be quoted using single quotes? */
<span class="pc" id="L84">    private boolean allowSingleQuotes = true;</span>

    /** Allow strings to be quoted using single quotes? [default: yes] */
    public void setAllowSingleQuotes(boolean b) {
<span class="nc" id="L88">        allowSingleQuotes = b;</span>
<span class="nc" id="L89">    }</span>

    /** Allow strings to be quoted using single quotes? */
    public boolean getAllowSingleQuotes() {
<span class="nc" id="L93">        return allowSingleQuotes;</span>
    }

<span class="pc" id="L96">    private String defaultProperty = &quot;word&quot;; //ComplexFieldUtil.DEFAULT_MAIN_PROP_NAME;</span>

    public void setDefaultProperty(IndexStructure structure, String fieldName) {
<span class="nc" id="L99">        defaultProperty = structure.getComplexFieldDesc(fieldName).getMainProperty().getName();</span>
<span class="nc" id="L100">    }</span>

    public void setDefaultProperty(String property) {
<span class="nc" id="L103">        defaultProperty = property;</span>
<span class="nc" id="L104">    }</span>

    public String getDefaultProperty() {
<span class="nc" id="L107">        return defaultProperty;</span>
    }

    private TextPattern propertyClause(String prop, TextPattern value) {
        // Main property has a name. Use that.
<span class="pc bpc" id="L112" title="2 of 4 branches missed.">        if (prop == null || prop.length() == 0)</span>
<span class="nc" id="L113">            prop = defaultProperty;</span>
<span class="fc" id="L114">        return new TextPatternProperty(prop, value);</span>
    }

// --- Grammar rules start here --- 

/* a query */
<span class="fc" id="L120">  final public TextPattern query() throws ParseException {TextPattern a = null;</span>
<span class="fc" id="L121">    a = constrainedQuery();</span>
<span class="fc" id="L122">    jj_consume_token(0);</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return a;}</span>
<span class="nc" id="L124">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

<span class="fc" id="L127">  final public TextPattern constrainedQuery() throws ParseException {TextPattern a = null;</span>
<span class="fc" id="L128"> MatchFilter b = null;</span>
<span class="fc" id="L129">    a = complexQuery();</span>
<span class="pc bpc" id="L130" title="1 of 4 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 14:{
<span class="fc" id="L132">      jj_consume_token(14);</span>
<span class="fc" id="L133">      b = constraint();</span>
<span class="fc" id="L134">      break;</span>
      }
    default:
<span class="fc" id="L137">      jj_la1[0] = jj_gen;</span>
      ;
    }
<span class="fc bfc" id="L140" title="All 2 branches covered.">if (b == null)</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">            {if (&quot;&quot; != null) return a;}</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        {if (&quot;&quot; != null) return new TextPatternConstrained(a, b);}</span>
<span class="nc" id="L143">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

<span class="fc" id="L146">  final public MatchFilter constraint() throws ParseException {MatchFilter a = null, c = null;</span>
<span class="fc" id="L147">    Token b = null;</span>
<span class="fc" id="L148">    a = simpleConstraint();</span>
<span class="fc bfc" id="L149" title="All 4 branches covered.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 30:
    case 31:
    case 32:{
<span class="fc" id="L153">      b = booleanOperator();</span>
<span class="fc" id="L154">      c = constraint();</span>
<span class="fc" id="L155">      break;</span>
      }
    default:
<span class="fc" id="L158">      jj_la1[1] = jj_gen;</span>
      ;
    }
<span class="fc bfc" id="L161" title="All 2 branches covered.">if (b == null)</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">   {if (&quot;&quot; != null) return a;}</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (b.toString().equals(&quot;-&gt;&quot;))</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            {if (&quot;&quot; != null) return new MatchFilterImplication(a, c);}</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">  if (b.toString().equals(&quot;&amp;&quot;))</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">   {if (&quot;&quot; != null) return new MatchFilterAnd(a, c);}</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">  {if (&quot;&quot; != null) return new MatchFilterOr(a, c);}</span>
<span class="nc" id="L168">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

<span class="fc" id="L171">  final public MatchFilter simpleConstraint() throws ParseException {MatchFilter v = null, w = null;</span>
<span class="fc" id="L172">    Token b = null;</span>
<span class="fc" id="L173">    v = constraintValue();</span>
<span class="fc bfc" id="L174" title="All 4 branches covered.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 15:
    case 16:{
<span class="fc" id="L177">      b = equalityOperator();</span>
<span class="fc" id="L178">      w = constraintValue();</span>
<span class="fc" id="L179">      break;</span>
      }
    default:
<span class="fc" id="L182">      jj_la1[2] = jj_gen;</span>
      ;
    }
<span class="fc bfc" id="L185" title="All 2 branches covered.">if (b == null)</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">   {if (&quot;&quot; != null) return v;}</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (b.toString().equals(&quot;=&quot;))</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">            {if (&quot;&quot; != null) return new MatchFilterEquals(v, w, false, false);}</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">  if (b.toString().equals(&quot;!=&quot;))</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">   {if (&quot;&quot; != null) return new MatchFilterNot(new MatchFilterEquals(v, w, false, false));}</span>
<span class="nc" id="L191">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

<span class="fc" id="L194">  final public Token equalityOperator() throws ParseException {Token t = null;</span>
<span class="pc bpc" id="L195" title="2 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 15:{
<span class="fc" id="L197">      t = jj_consume_token(15);</span>
<span class="fc" id="L198">      break;</span>
      }
    case 16:{
<span class="fc" id="L201">      t = jj_consume_token(16);</span>
<span class="fc" id="L202">      break;</span>
      }
    default:
<span class="nc" id="L205">      jj_la1[3] = jj_gen;</span>
<span class="nc" id="L206">      jj_consume_token(-1);</span>
<span class="nc" id="L207">      throw new ParseException();</span>
    }
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return t;}</span>
<span class="nc" id="L210">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

<span class="fc" id="L213">  final public MatchFilter constraintValue() throws ParseException {MatchFilter v = null;</span>
<span class="fc" id="L214"> String q = null;</span>
<span class="fc" id="L215"> Token s = null;</span>
<span class="fc" id="L216"> String l = null;</span>
<span class="pc bpc" id="L217" title="3 of 7 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case QUOTED_STRING:
    case SINGLE_QUOTED_STRING:{
<span class="fc" id="L220">      q = quotedString();</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return new MatchFilterString(q);}</span>
      break;
      }
    case 17:{
<span class="fc" id="L225">      jj_consume_token(17);</span>
<span class="fc" id="L226">      v = constraint();</span>
<span class="fc" id="L227">      jj_consume_token(18);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return v;}</span>
      break;
      }
    case 19:{
<span class="nc" id="L232">      jj_consume_token(19);</span>
<span class="nc" id="L233">      v = constraintValue();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">{if (&quot;&quot; != null) return new MatchFilterNot(v);}</span>
      break;
      }
    case NAME:
    case NUMBER:{
<span class="fc" id="L239">      l = captureLabel();</span>
<span class="pc bpc" id="L240" title="1 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case 20:{
<span class="fc" id="L242">        jj_consume_token(20);</span>
<span class="fc" id="L243">        s = jj_consume_token(NAME);</span>
<span class="fc" id="L244">        break;</span>
        }
      default:
<span class="fc" id="L247">        jj_la1[4] = jj_gen;</span>
        ;
      }
<span class="pc bpc" id="L250" title="1 of 4 branches missed.">{if (&quot;&quot; != null) return new MatchFilterTokenProperty(l, s == null ? null : s.toString());}</span>
      break;
      }
    default:
<span class="nc" id="L254">      jj_la1[5] = jj_gen;</span>
<span class="nc" id="L255">      jj_consume_token(-1);</span>
<span class="nc" id="L256">      throw new ParseException();</span>
    }
<span class="nc" id="L258">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

<span class="fc" id="L261">  final public TextPattern complexQuery() throws ParseException {TextPattern a = null, b = null;</span>
<span class="fc" id="L262">    Token op = null;</span>
<span class="fc" id="L263">    Operation oper = Operation.CONTAINING;</span>
<span class="fc" id="L264">    a = simpleQuery();</span>
<span class="pc bpc" id="L265" title="1 of 4 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case WITHIN:
    case CONTAINING:{
<span class="fc" id="L268">      op = queryOperator();</span>
<span class="fc" id="L269">      b = complexQuery();</span>
<span class="fc" id="L270">      break;</span>
      }
    default:
<span class="fc" id="L273">      jj_la1[6] = jj_gen;</span>
      ;
    }
<span class="fc bfc" id="L276" title="All 2 branches covered.">if (op == null)</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            {if (&quot;&quot; != null) return a;}</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (op.toString().equals(&quot;within&quot;)) {</span>
            // a within b
<span class="fc" id="L280">            oper = Operation.WITHIN;</span>
        }

<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        {if (&quot;&quot; != null) return new TextPatternPositionFilter(a, b, oper);}</span>
<span class="nc" id="L284">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

<span class="fc" id="L287">  final public Token queryOperator() throws ParseException {Token t = null;</span>
<span class="pc bpc" id="L288" title="2 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case WITHIN:{
<span class="fc" id="L290">      t = jj_consume_token(WITHIN);</span>
<span class="fc" id="L291">      break;</span>
      }
    case CONTAINING:{
<span class="fc" id="L294">      t = jj_consume_token(CONTAINING);</span>
<span class="fc" id="L295">      break;</span>
      }
    default:
<span class="nc" id="L298">      jj_la1[7] = jj_gen;</span>
<span class="nc" id="L299">      jj_consume_token(-1);</span>
<span class="nc" id="L300">      throw new ParseException();</span>
    }
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return t;}</span>
<span class="nc" id="L303">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* a simple query (not including containing, within, etc.) */
<span class="fc" id="L307">  final public TextPattern simpleQuery() throws ParseException {TextPattern query = null, rest = null;</span>
<span class="fc" id="L308">    Token b = null;</span>
<span class="fc" id="L309">    query = sequence();</span>
<span class="fc bfc" id="L310" title="All 4 branches covered.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 30:
    case 31:
    case 32:{
<span class="fc" id="L314">      b = booleanOperator();</span>
<span class="fc" id="L315">      rest = simpleQuery();</span>
<span class="fc" id="L316">      break;</span>
      }
    default:
<span class="fc" id="L319">      jj_la1[8] = jj_gen;</span>
      ;
    }
<span class="fc bfc" id="L322" title="All 2 branches covered.">if (b == null)</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">   {if (&quot;&quot; != null) return query;}</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (b.toString().equals(&quot;-&gt;&quot;))</span>
<span class="nc" id="L325">            {if (true) throw new UnsupportedOperationException(&quot;Implication operator only supported within global constraints&quot;);}</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">  if (b.toString().equals(&quot;&amp;&quot;))</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">   {if (&quot;&quot; != null) return new TextPatternAnd(query, rest);}</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">  {if (&quot;&quot; != null) return new TextPatternOr(query, rest);}</span>
<span class="nc" id="L329">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* a sequence of token constraints */
<span class="fc" id="L333">  final public TextPattern sequence() throws ParseException {TextPattern first = null;</span>
<span class="fc" id="L334"> TextPattern result = null;</span>
<span class="fc" id="L335"> TextPattern[] tag = null;</span>
<span class="fc" id="L336">    Token t2 = null;</span>
<span class="fc" id="L337">    first = sequencePart();</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">    if (jj_2_1(2)) {</span>
<span class="fc" id="L339">      result = sequenceRest(first);</span>
    } else {
      ;
    }
<span class="fc bfc" id="L343" title="All 2 branches covered.">if (result == null)</span>
<span class="fc" id="L344">   result = first;</span>

<span class="pc bpc" id="L346" title="1 of 2 branches missed.">  {if (&quot;&quot; != null) return result;}</span>
<span class="nc" id="L347">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* a start or self-closing tag tag such as &lt;s&gt; or &lt;s/&gt; (for finding XML elements).
 * Note that it returns one TextPattern, but if it's in [0] that means it's a start
 * tag; if it's in [1] it's a self-closing tag.
 */
<span class="fc" id="L354">  final public TextPattern tag() throws ParseException {Token tagName, endTagSlash = null, selfCloseSlash = null;</span>
<span class="fc" id="L355">    Map&lt;String, String&gt; attr = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L356">    jj_consume_token(21);</span>
<span class="pc bpc" id="L357" title="1 of 4 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 22:{
<span class="fc" id="L359">      endTagSlash = jj_consume_token(22);</span>
<span class="fc" id="L360">      break;</span>
      }
    default:
<span class="fc" id="L363">      jj_la1[9] = jj_gen;</span>
      ;
    }
<span class="fc" id="L366">    tagName = jj_consume_token(NAME);</span>
    label_1:
    while (true) {
<span class="pc bpc" id="L369" title="1 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case NAME:{
        ;
<span class="fc" id="L372">        break;</span>
        }
      default:
<span class="fc" id="L375">        jj_la1[10] = jj_gen;</span>
<span class="fc" id="L376">        break label_1;</span>
      }
<span class="fc" id="L378">      attributes(attr);</span>
    }
<span class="pc bpc" id="L380" title="1 of 4 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 22:{
<span class="fc" id="L382">      selfCloseSlash = jj_consume_token(22);</span>
<span class="fc" id="L383">      break;</span>
      }
    default:
<span class="fc" id="L386">      jj_la1[11] = jj_gen;</span>
      ;
    }
<span class="fc" id="L389">    jj_consume_token(23);</span>
<span class="pc bpc" id="L390" title="1 of 4 branches missed.">if (endTagSlash != null &amp;&amp; selfCloseSlash != null) {</span>
<span class="nc" id="L391">            {if (true) throw new MalformedTagException();}</span>
        }
<span class="fc" id="L393">        TextPattern tags = new TextPatternTags(tagName.toString(), attr);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (selfCloseSlash != null)</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">            {if (&quot;&quot; != null) return tags;}</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (endTagSlash != null) {</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">            if (attr.size() &gt; 0) {</span>
<span class="nc" id="L398">                {if (true) throw new MalformedTagException(&quot;Cannot filter XML end tag on attributes&quot;);}</span>
            }
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">            {if (&quot;&quot; != null) return new TextPatternEdge(tags, true);} // right edge</span>
        }
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        {if (&quot;&quot; != null) return new TextPatternEdge(tags, false);} // left edge</span>

<span class="nc" id="L404">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

  final public String quotedString() throws ParseException {Token a;
<span class="pc bpc" id="L408" title="1 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case QUOTED_STRING:{
<span class="fc" id="L410">      a = jj_consume_token(QUOTED_STRING);</span>
<span class="fc" id="L411">      break;</span>
      }
    case SINGLE_QUOTED_STRING:{
<span class="fc" id="L414">      a = jj_consume_token(SINGLE_QUOTED_STRING);</span>
<span class="fc" id="L415">      break;</span>
      }
    default:
<span class="nc" id="L418">      jj_la1[12] = jj_gen;</span>
<span class="nc" id="L419">      jj_consume_token(-1);</span>
<span class="nc" id="L420">      throw new ParseException();</span>
    }
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return getStringBetweenQuotes(a.toString());}</span>
<span class="nc" id="L423">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

  final public void attributes(Map&lt;String, String&gt; attr) throws ParseException {Token name;
    String value;
<span class="fc" id="L428">    name = jj_consume_token(NAME);</span>
<span class="fc" id="L429">    jj_consume_token(15);</span>
<span class="fc" id="L430">    value = quotedString();</span>
<span class="fc" id="L431">attr.put(name.toString(), value);</span>
<span class="fc" id="L432">  }</span>

/* continuation of a sequence (after the first part) */
<span class="fc" id="L435">  final public TextPattern sequenceRest(TextPattern first) throws ParseException {Token op = null;</span>
<span class="fc" id="L436"> TextPattern rest = null;</span>
<span class="fc" id="L437">    rest = sequence();</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">if (rest == null)</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">   {if (&quot;&quot; != null) return first;}</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">  {if (&quot;&quot; != null) return new TextPatternSequence(first, rest);}</span>
<span class="nc" id="L441">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* a repetition specifier */
<span class="fc" id="L445">  final public Integer[] repetitionAmount() throws ParseException {Token t = null, t2 = null;</span>
<span class="fc" id="L446"> Integer[] minMax = new Integer[2];</span>
<span class="fc bfc" id="L447" title="All 6 branches covered.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 24:{
<span class="fc" id="L449">      jj_consume_token(24);</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">minMax[0] = 0; minMax[1] = BLSpanQuery.MAX_UNLIMITED; {if (&quot;&quot; != null) return minMax;}</span>
      break;
      }
    case 25:{
<span class="fc" id="L454">      jj_consume_token(25);</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">minMax[0] = 1; minMax[1] = BLSpanQuery.MAX_UNLIMITED; {if (&quot;&quot; != null) return minMax;}</span>
      break;
      }
    case 26:{
<span class="fc" id="L459">      jj_consume_token(26);</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">minMax[0] = 0; minMax[1] = 1; {if (&quot;&quot; != null) return minMax;}</span>
      break;
      }
    default:
<span class="fc" id="L464">      jj_la1[14] = jj_gen;</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">      if (jj_2_2(3)) {</span>
<span class="fc" id="L466">        jj_consume_token(27);</span>
<span class="fc" id="L467">        t = jj_consume_token(NUMBER);</span>
<span class="fc" id="L468">        jj_consume_token(28);</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">minMax[0] = minMax[1] = num(t); {if (&quot;&quot; != null) return minMax;}</span>
      } else {
<span class="pc bpc" id="L471" title="2 of 4 branches missed.">        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
        case 27:{
<span class="fc" id="L473">          jj_consume_token(27);</span>
<span class="fc" id="L474">          t = jj_consume_token(NUMBER);</span>
<span class="fc" id="L475">          jj_consume_token(29);</span>
<span class="pc bpc" id="L476" title="1 of 4 branches missed.">          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
          case NUMBER:{
<span class="fc" id="L478">            t2 = jj_consume_token(NUMBER);</span>
<span class="fc" id="L479">            break;</span>
            }
          default:
<span class="fc" id="L482">            jj_la1[13] = jj_gen;</span>
            ;
          }
<span class="fc" id="L485">          jj_consume_token(28);</span>
<span class="fc" id="L486">minMax[0] = num(t);</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">  if (t2 == null)</span>
<span class="fc" id="L488">   minMax[1] = BLSpanQuery.MAX_UNLIMITED;</span>
  else
<span class="fc" id="L490">   minMax[1] = num(t2);</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">  {if (&quot;&quot; != null) return minMax;}</span>
          break;
          }
        default:
<span class="nc" id="L495">          jj_la1[15] = jj_gen;</span>
<span class="nc" id="L496">          jj_consume_token(-1);</span>
<span class="nc" id="L497">          throw new ParseException();</span>
        }
      }
    }
<span class="nc" id="L501">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* boolean operator: and, or or implication */
<span class="fc" id="L505">  final public Token booleanOperator() throws ParseException {Token t = null;</span>
<span class="pc bpc" id="L506" title="2 of 6 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 30:{
<span class="fc" id="L508">      t = jj_consume_token(30);</span>
<span class="fc" id="L509">      break;</span>
      }
    case 31:{
<span class="fc" id="L512">      t = jj_consume_token(31);</span>
<span class="fc" id="L513">      break;</span>
      }
    case 32:{
<span class="fc" id="L516">      t = jj_consume_token(32);</span>
<span class="fc" id="L517">      break;</span>
      }
    default:
<span class="nc" id="L520">      jj_la1[16] = jj_gen;</span>
<span class="nc" id="L521">      jj_consume_token(-1);</span>
<span class="nc" id="L522">      throw new ParseException();</span>
    }
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return t;}</span>
<span class="nc" id="L525">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* sequence part: one part in a sequence, possibly with a repetition operator */
<span class="fc" id="L529">  final public TextPattern sequencePart() throws ParseException {TextPattern m = null;</span>
<span class="fc" id="L530"> Integer[] rep = null;</span>
<span class="fc" id="L531"> String label = null;</span>
<span class="fc bfc" id="L532" title="All 4 branches covered.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case NAME:
    case NUMBER:{
<span class="fc" id="L535">      label = captureLabel();</span>
<span class="fc" id="L536">      jj_consume_token(33);</span>
<span class="fc" id="L537">      break;</span>
      }
    default:
<span class="fc" id="L540">      jj_la1[17] = jj_gen;</span>
      ;
    }
<span class="pc bpc" id="L543" title="1 of 6 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 21:{
<span class="fc" id="L545">      m = tag();</span>
<span class="fc" id="L546">      break;</span>
      }
    case QUOTED_STRING:
    case SINGLE_QUOTED_STRING:
    case 34:{
<span class="fc" id="L551">      m = position();</span>
<span class="fc" id="L552">      break;</span>
      }
    case 17:{
<span class="fc" id="L555">      jj_consume_token(17);</span>
<span class="fc" id="L556">      m = complexQuery();</span>
<span class="fc" id="L557">      jj_consume_token(18);</span>
<span class="fc" id="L558">      break;</span>
      }
    default:
<span class="nc" id="L561">      jj_la1[18] = jj_gen;</span>
<span class="nc" id="L562">      jj_consume_token(-1);</span>
<span class="nc" id="L563">      throw new ParseException();</span>
    }
<span class="fc bfc" id="L565" title="All 2 branches covered.">    if (jj_2_3(6)) {</span>
<span class="fc" id="L566">      rep = repetitionAmount();</span>
    } else {
      ;
    }
<span class="fc bfc" id="L570" title="All 2 branches covered.">if (rep != null)</span>
  {
<span class="fc bfc" id="L572" title="All 2 branches covered.">            if (m instanceof TextPatternAnyToken)</span>
            {
<span class="fc" id="L574">                TextPatternAnyToken any = (TextPatternAnyToken)m;</span>
<span class="fc" id="L575">                m = any.repeat(rep[0], rep[1]);</span>
<span class="fc" id="L576">            } else</span>
<span class="fc" id="L577">                m = new TextPatternRepetition(m, rep[0], rep[1]);</span>
  }
<span class="fc bfc" id="L579" title="All 2 branches covered.">  if (label != null) {</span>
<span class="fc" id="L580">      m = new TextPatternCaptureGroup(m, label);</span>
  }
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">  {if (&quot;&quot; != null) return m;}</span>
<span class="nc" id="L583">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

<span class="fc" id="L586">  final public String captureLabel() throws ParseException {Token l = null;</span>
<span class="pc bpc" id="L587" title="3 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case NAME:{
<span class="fc" id="L589">      l = jj_consume_token(NAME);</span>
<span class="fc" id="L590">      break;</span>
      }
    case NUMBER:{
<span class="nc" id="L593">      l = jj_consume_token(NUMBER);</span>
<span class="nc" id="L594">      break;</span>
      }
    default:
<span class="nc" id="L597">      jj_la1[19] = jj_gen;</span>
<span class="nc" id="L598">      jj_consume_token(-1);</span>
<span class="nc" id="L599">      throw new ParseException();</span>
    }
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return l.toString();}</span>
<span class="nc" id="L602">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* position: a simple attribute value or complex attribute expression between square brackets */
<span class="fc" id="L606">  final public TextPattern position() throws ParseException {TextPattern m = null;</span>
<span class="fc" id="L607"> String f = null;</span>
<span class="pc bpc" id="L608" title="2 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case QUOTED_STRING:
    case SINGLE_QUOTED_STRING:{
<span class="fc" id="L611">      m = positionWord();</span>
<span class="pc bpc" id="L612" title="2 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case FLAGS:{
<span class="nc" id="L614">        f = flags();</span>
<span class="nc" id="L615">        break;</span>
        }
      default:
<span class="fc" id="L618">        jj_la1[20] = jj_gen;</span>
        ;
      }
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return m;}</span>
      break;
      }
    case 34:{
<span class="fc" id="L625">      jj_consume_token(34);</span>
<span class="pc bpc" id="L626" title="1 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case NAME:
      case QUOTED_STRING:
      case SINGLE_QUOTED_STRING:
      case 17:
      case 19:{
<span class="fc" id="L632">        m = positionLong();</span>
<span class="fc" id="L633">        break;</span>
        }
      default:
<span class="fc" id="L636">        jj_la1[21] = jj_gen;</span>
        ;
      }
<span class="fc" id="L639">      jj_consume_token(35);</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">if (m == null)</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">            {if (&quot;&quot; != null) return new TextPatternAnyToken(1, 1);}</span>
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">        {if (&quot;&quot; != null) return m;}</span>
      break;
      }
    default:
<span class="nc" id="L646">      jj_la1[22] = jj_gen;</span>
<span class="nc" id="L647">      jj_consume_token(-1);</span>
<span class="nc" id="L648">      throw new ParseException();</span>
    }
<span class="nc" id="L650">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

  final public String flags() throws ParseException {Token f;
<span class="nc" id="L654">    f = jj_consume_token(FLAGS);</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">{if (&quot;&quot; != null) return f.toString().substring(1);}</span>
<span class="nc" id="L656">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* position word: no brackets, just a single token constraint for the default attribute (usually word form) */
<span class="fc" id="L660">  final public TextPattern positionWord() throws ParseException {String t = null;</span>
<span class="fc" id="L661">    t = quotedString();</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return simplePattern(t);}</span>
<span class="nc" id="L663">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* expression inside square brackets: an attribute clause, or multiple 
   attribute clauses combined with boolean operators */
<span class="fc" id="L668">  final public TextPattern positionLong() throws ParseException {TextPattern a = null, c = null;</span>
<span class="fc" id="L669"> Token b = null;</span>
<span class="fc" id="L670">    a = positionLongPart();</span>
<span class="fc bfc" id="L671" title="All 4 branches covered.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 30:
    case 31:
    case 32:{
<span class="fc" id="L675">      b = booleanOperator();</span>
<span class="fc" id="L676">      c = positionLong();</span>
<span class="fc" id="L677">      break;</span>
      }
    default:
<span class="fc" id="L680">      jj_la1[23] = jj_gen;</span>
      ;
    }
<span class="fc bfc" id="L683" title="All 2 branches covered.">if (b == null)</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">   {if (&quot;&quot; != null) return a;}</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">        if (b.toString().equals(&quot;-&gt;&quot;))</span>
<span class="nc" id="L686">            {if (true) throw new UnsupportedOperationException(&quot;Implication operator only supported within global constraints&quot;);}</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">  if (b.toString().equals(&quot;&amp;&quot;))</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">   {if (&quot;&quot; != null) return new TextPatternAnd(a, c);}</span>
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">  {if (&quot;&quot; != null) return new TextPatternOr(a, c);}</span>
<span class="nc" id="L690">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* attribute clause: an attribute/value pair, attribute expression between parens, or a negated attribute/value pair */
<span class="fc" id="L694">  final public TextPattern positionLongPart() throws ParseException {TextPattern m = null;</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">    if (jj_2_4(3)) {</span>
<span class="fc" id="L696">      m = attValuePair();</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return m;}</span>
    } else {
<span class="pc bpc" id="L699" title="1 of 5 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case 17:{
<span class="fc" id="L701">        jj_consume_token(17);</span>
<span class="fc" id="L702">        m = positionLong();</span>
<span class="fc" id="L703">        jj_consume_token(18);</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return m;}</span>
        break;
        }
      case 19:{
<span class="fc" id="L708">        jj_consume_token(19);</span>
<span class="fc" id="L709">        m = positionLongPart();</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return new TextPatternNot(m);}</span>
        break;
        }
      default:
<span class="nc" id="L714">        jj_la1[24] = jj_gen;</span>
<span class="nc" id="L715">        jj_consume_token(-1);</span>
<span class="nc" id="L716">        throw new ParseException();</span>
      }
    }
<span class="nc" id="L719">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* attribute/value pair, with equals or not equals sign, or possibly just a value (default attribute) */
<span class="fc" id="L723">  final public TextPattern attValuePair() throws ParseException {TextPattern v = null;</span>
 String prop;
<span class="fc" id="L725"> String f = null;</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">    if (jj_2_5(2)) {</span>
<span class="fc" id="L727">      prop = propName();</span>
<span class="fc" id="L728">      jj_consume_token(15);</span>
<span class="fc" id="L729">      v = valuePart();</span>
<span class="pc bpc" id="L730" title="2 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case FLAGS:{
<span class="nc" id="L732">        f = flags();</span>
<span class="nc" id="L733">        break;</span>
        }
      default:
<span class="fc" id="L736">        jj_la1[25] = jj_gen;</span>
        ;
      }
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return propertyClause(prop, v);}</span>
    } else {
<span class="pc bpc" id="L741" title="2 of 5 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case NAME:{
<span class="fc" id="L743">        prop = propName();</span>
<span class="fc" id="L744">        jj_consume_token(16);</span>
<span class="fc" id="L745">        v = valuePart();</span>
<span class="pc bpc" id="L746" title="2 of 4 branches missed.">        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
        case FLAGS:{
<span class="nc" id="L748">          f = flags();</span>
<span class="nc" id="L749">          break;</span>
          }
        default:
<span class="fc" id="L752">          jj_la1[26] = jj_gen;</span>
          ;
        }
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return new TextPatternNot(propertyClause(prop, v));}</span>
        break;
        }
      case QUOTED_STRING:
      case SINGLE_QUOTED_STRING:
      case 17:{
<span class="nc" id="L761">        v = valuePart();</span>
<span class="nc bnc" id="L762" title="All 4 branches missed.">        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
        case FLAGS:{
<span class="nc" id="L764">          f = flags();</span>
<span class="nc" id="L765">          break;</span>
          }
        default:
<span class="nc" id="L768">          jj_la1[27] = jj_gen;</span>
          ;
        }
<span class="nc bnc" id="L771" title="All 2 branches missed.">{if (&quot;&quot; != null) return v;}</span>
        break;
        }
      default:
<span class="nc" id="L775">        jj_la1[28] = jj_gen;</span>
<span class="nc" id="L776">        jj_consume_token(-1);</span>
<span class="nc" id="L777">        throw new ParseException();</span>
      }
    }
<span class="nc" id="L780">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

<span class="fc" id="L783">  final public String propName() throws ParseException {Token t = null, subProp = null;</span>
<span class="fc" id="L784">    t = jj_consume_token(NAME);</span>
<span class="pc bpc" id="L785" title="2 of 4 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case 22:{
<span class="nc" id="L787">      jj_consume_token(22);</span>
<span class="nc" id="L788">      subProp = jj_consume_token(NAME);</span>
<span class="nc" id="L789">      break;</span>
      }
    default:
<span class="fc" id="L792">      jj_la1[29] = jj_gen;</span>
      ;
    }
<span class="fc" id="L795">String propName = t.toString();</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">  if (subProp == null)</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">   {if (&quot;&quot; != null) return propName;}</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">  {if (&quot;&quot; != null) return propName + &quot;/&quot; + subProp.toString();}</span>
<span class="nc" id="L799">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* value expression: a value or multiple values combined with boolean operators */
<span class="nc" id="L803">  final public TextPattern value() throws ParseException {TextPattern a = null, c = null;</span>
<span class="nc" id="L804"> Token b = null;</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">    if (jj_2_6(3)) {</span>
<span class="nc" id="L806">      a = valuePart();</span>
<span class="nc" id="L807">      b = booleanOperator();</span>
<span class="nc" id="L808">      c = value();</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">if (b.toString().equals(&quot;-&gt;&quot;))</span>
<span class="nc" id="L810">            {if (true) throw new UnsupportedOperationException(&quot;Implication operator only supported within global constraints&quot;);}</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">  if (b.toString().equals(&quot;&amp;&quot;))</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">   {if (&quot;&quot; != null) return new TextPatternAnd(a, c);}</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">  {if (&quot;&quot; != null) return new TextPatternOr(a, c);}</span>
    } else {
<span class="nc bnc" id="L815" title="All 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case QUOTED_STRING:
      case SINGLE_QUOTED_STRING:
      case 17:{
<span class="nc" id="L819">        a = valuePart();</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">{if (&quot;&quot; != null) return a;}</span>
        break;
        }
      default:
<span class="nc" id="L824">        jj_la1[30] = jj_gen;</span>
<span class="nc" id="L825">        jj_consume_token(-1);</span>
<span class="nc" id="L826">        throw new ParseException();</span>
      }
    }
<span class="nc" id="L829">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

/* value: a quoted string, a value expression between parens, or a negated value */
<span class="fc" id="L833">  final public TextPattern valuePart() throws ParseException {TextPattern m = null;</span>
<span class="fc" id="L834"> String t = null;</span>
<span class="pc bpc" id="L835" title="3 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case QUOTED_STRING:
    case SINGLE_QUOTED_STRING:{
<span class="fc" id="L838">      t = quotedString();</span>
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">{if (&quot;&quot; != null) return simplePattern(t);}</span>
      break;
      }
    case 17:{
<span class="nc" id="L843">      jj_consume_token(17);</span>
<span class="nc" id="L844">      m = value();</span>
<span class="nc" id="L845">      jj_consume_token(18);</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">{if (&quot;&quot; != null) return m;}</span>
      break;
      }
    default:
<span class="nc" id="L850">      jj_la1[31] = jj_gen;</span>
<span class="nc" id="L851">      jj_consume_token(-1);</span>
<span class="nc" id="L852">      throw new ParseException();</span>
    }
<span class="nc" id="L854">    throw new Error(&quot;Missing return statement in function&quot;);</span>
  }

  private boolean jj_2_1(int xla)
 {
<span class="fc" id="L859">    jj_la = xla; jj_lastpos = jj_scanpos = token;</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">    try { return !jj_3_1(); }</span>
<span class="fc" id="L861">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L862">    finally { jj_save(0, xla); }</span>
  }

  private boolean jj_2_2(int xla)
 {
<span class="fc" id="L867">    jj_la = xla; jj_lastpos = jj_scanpos = token;</span>
<span class="pc bpc" id="L868" title="1 of 2 branches missed.">    try { return !jj_3_2(); }</span>
<span class="fc" id="L869">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L870">    finally { jj_save(1, xla); }</span>
  }

  private boolean jj_2_3(int xla)
 {
<span class="fc" id="L875">    jj_la = xla; jj_lastpos = jj_scanpos = token;</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">    try { return !jj_3_3(); }</span>
<span class="nc" id="L877">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L878">    finally { jj_save(2, xla); }</span>
  }

  private boolean jj_2_4(int xla)
 {
<span class="fc" id="L883">    jj_la = xla; jj_lastpos = jj_scanpos = token;</span>
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">    try { return !jj_3_4(); }</span>
<span class="fc" id="L885">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L886">    finally { jj_save(3, xla); }</span>
  }

  private boolean jj_2_5(int xla)
 {
<span class="fc" id="L891">    jj_la = xla; jj_lastpos = jj_scanpos = token;</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">    try { return !jj_3_5(); }</span>
<span class="fc" id="L893">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L894">    finally { jj_save(4, xla); }</span>
  }

  private boolean jj_2_6(int xla)
 {
<span class="nc" id="L899">    jj_la = xla; jj_lastpos = jj_scanpos = token;</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">    try { return !jj_3_6(); }</span>
<span class="nc" id="L901">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="nc" id="L902">    finally { jj_save(5, xla); }</span>
  }

  private boolean jj_3R_24()
 {
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">    if (jj_3R_29()) return true;</span>
<span class="nc" id="L908">    return false;</span>
  }

  private boolean jj_3R_16()
 {
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">    if (jj_scan_token(22)) return true;</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">    if (jj_scan_token(NAME)) return true;</span>
<span class="nc" id="L915">    return false;</span>
  }

  private boolean jj_3R_31()
 {
<span class="nc bnc" id="L920" title="All 2 branches missed.">    if (jj_3R_34()) return true;</span>
<span class="nc" id="L921">    return false;</span>
  }

  private boolean jj_3R_21()
 {
<span class="nc bnc" id="L926" title="All 2 branches missed.">    if (jj_3R_27()) return true;</span>
<span class="nc" id="L927">    return false;</span>
  }

  private boolean jj_3R_22()
 {
    Token xsp;
<span class="fc" id="L933">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L934" title="All 2 branches covered.">    if (jj_scan_token(12)) {</span>
<span class="fc" id="L935">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">    if (jj_scan_token(13)) return true;</span>
    }
<span class="fc" id="L938">    return false;</span>
  }

  private boolean jj_3R_28()
 {
    Token xsp;
<span class="fc" id="L944">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">    if (jj_scan_token(9)) {</span>
<span class="fc" id="L946">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L947" title="1 of 2 branches missed.">    if (jj_scan_token(11)) return true;</span>
    }
<span class="fc" id="L949">    return false;</span>
  }

  private boolean jj_3R_5()
 {
<span class="fc bfc" id="L954" title="All 2 branches covered.">    if (jj_scan_token(NAME)) return true;</span>
    Token xsp;
<span class="fc" id="L956">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">    if (jj_3R_16()) jj_scanpos = xsp;</span>
<span class="fc" id="L958">    return false;</span>
  }

  private boolean jj_3R_15()
 {
<span class="pc bpc" id="L963" title="1 of 2 branches missed.">    if (jj_3R_6()) return true;</span>
    Token xsp;
<span class="nc" id="L965">    xsp = jj_scanpos;</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">    if (jj_3R_21()) jj_scanpos = xsp;</span>
<span class="nc" id="L967">    return false;</span>
  }

  private boolean jj_3R_14()
 {
<span class="pc bpc" id="L972" title="1 of 2 branches missed.">    if (jj_3R_5()) return true;</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">    if (jj_scan_token(16)) return true;</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">    if (jj_3R_6()) return true;</span>
<span class="nc" id="L975">    return false;</span>
  }

  private boolean jj_3_1()
 {
<span class="fc bfc" id="L980" title="All 2 branches covered.">    if (jj_3R_2()) return true;</span>
<span class="fc" id="L981">    return false;</span>
  }

  private boolean jj_3R_4()
 {
    Token xsp;
<span class="fc" id="L987">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L988" title="1 of 2 branches missed.">    if (jj_3_5()) {</span>
<span class="fc" id="L989">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L990" title="1 of 2 branches missed.">    if (jj_3R_14()) {</span>
<span class="fc" id="L991">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">    if (jj_3R_15()) return true;</span>
    }
    }
<span class="nc" id="L995">    return false;</span>
  }

  private boolean jj_3_5()
 {
<span class="fc bfc" id="L1000" title="All 2 branches covered.">    if (jj_3R_5()) return true;</span>
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">    if (jj_scan_token(15)) return true;</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">    if (jj_3R_6()) return true;</span>
<span class="nc" id="L1003">    return false;</span>
  }

  private boolean jj_3R_29()
 {
<span class="fc bfc" id="L1008" title="All 2 branches covered.">    if (jj_scan_token(21)) return true;</span>
    Token xsp;
<span class="fc" id="L1010">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">    if (jj_scan_token(22)) jj_scanpos = xsp;</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">    if (jj_scan_token(NAME)) return true;</span>
<span class="nc" id="L1013">    return false;</span>
  }

  private boolean jj_3R_23()
 {
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">    if (jj_3R_28()) return true;</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">    if (jj_scan_token(33)) return true;</span>
<span class="nc" id="L1020">    return false;</span>
  }

  private boolean jj_3R_20()
 {
    Token xsp;
<span class="fc" id="L1026">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">    if (jj_3R_23()) jj_scanpos = xsp;</span>
<span class="fc" id="L1028">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L1029" title="1 of 2 branches missed.">    if (jj_3R_24()) {</span>
<span class="fc" id="L1030">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">    if (jj_3R_25()) {</span>
<span class="fc" id="L1032">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">    if (jj_3R_26()) return true;</span>
    }
    }
<span class="fc" id="L1036">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">    if (jj_3_3()) jj_scanpos = xsp;</span>
<span class="fc" id="L1038">    return false;</span>
  }

  private boolean jj_3R_41()
 {
<span class="pc bpc" id="L1043" title="1 of 2 branches missed.">    if (jj_scan_token(19)) return true;</span>
<span class="nc" id="L1044">    return false;</span>
  }

  private boolean jj_3R_40()
 {
<span class="pc bpc" id="L1049" title="1 of 2 branches missed.">    if (jj_scan_token(17)) return true;</span>
<span class="nc" id="L1050">    return false;</span>
  }

  private boolean jj_3R_39()
 {
    Token xsp;
<span class="fc" id="L1056">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L1057" title="1 of 2 branches missed.">    if (jj_3_4()) {</span>
<span class="fc" id="L1058">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">    if (jj_3R_40()) {</span>
<span class="fc" id="L1060">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">    if (jj_3R_41()) return true;</span>
    }
    }
<span class="nc" id="L1064">    return false;</span>
  }

  private boolean jj_3_4()
 {
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">    if (jj_3R_4()) return true;</span>
<span class="nc" id="L1070">    return false;</span>
  }

  private boolean jj_3_3()
 {
<span class="fc bfc" id="L1075" title="All 2 branches covered.">    if (jj_3R_3()) return true;</span>
<span class="fc" id="L1076">    return false;</span>
  }

  private boolean jj_3R_7()
 {
    Token xsp;
<span class="nc" id="L1082">    xsp = jj_scanpos;</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">    if (jj_scan_token(30)) {</span>
<span class="nc" id="L1084">    jj_scanpos = xsp;</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">    if (jj_scan_token(31)) {</span>
<span class="nc" id="L1086">    jj_scanpos = xsp;</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">    if (jj_scan_token(32)) return true;</span>
    }
    }
<span class="nc" id="L1090">    return false;</span>
  }

  private boolean jj_3R_9()
 {
<span class="fc bfc" id="L1095" title="All 2 branches covered.">    if (jj_3R_20()) return true;</span>
    Token xsp;
<span class="fc" id="L1097">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L1098" title="1 of 2 branches missed.">    if (jj_3_1()) jj_scanpos = xsp;</span>
<span class="fc" id="L1099">    return false;</span>
  }

  private boolean jj_3R_38()
 {
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">    if (jj_3R_39()) return true;</span>
<span class="nc" id="L1105">    return false;</span>
  }

  private boolean jj_3R_13()
 {
<span class="fc bfc" id="L1110" title="All 2 branches covered.">    if (jj_scan_token(27)) return true;</span>
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">    if (jj_scan_token(NUMBER)) return true;</span>
<span class="pc bpc" id="L1112" title="1 of 2 branches missed.">    if (jj_scan_token(29)) return true;</span>
    Token xsp;
<span class="fc" id="L1114">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">    if (jj_scan_token(11)) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L1116" title="1 of 2 branches missed.">    if (jj_scan_token(28)) return true;</span>
<span class="fc" id="L1117">    return false;</span>
  }

  private boolean jj_3_2()
 {
<span class="fc bfc" id="L1122" title="All 2 branches covered.">    if (jj_scan_token(27)) return true;</span>
<span class="pc bpc" id="L1123" title="1 of 2 branches missed.">    if (jj_scan_token(NUMBER)) return true;</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">    if (jj_scan_token(28)) return true;</span>
<span class="fc" id="L1125">    return false;</span>
  }

  private boolean jj_3R_12()
 {
<span class="fc bfc" id="L1130" title="All 2 branches covered.">    if (jj_scan_token(26)) return true;</span>
<span class="fc" id="L1131">    return false;</span>
  }

  private boolean jj_3R_11()
 {
<span class="fc bfc" id="L1136" title="All 2 branches covered.">    if (jj_scan_token(25)) return true;</span>
<span class="fc" id="L1137">    return false;</span>
  }

  private boolean jj_3R_10()
 {
<span class="fc bfc" id="L1142" title="All 2 branches covered.">    if (jj_scan_token(24)) return true;</span>
<span class="fc" id="L1143">    return false;</span>
  }

  private boolean jj_3R_3()
 {
    Token xsp;
<span class="fc" id="L1149">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">    if (jj_3R_10()) {</span>
<span class="fc" id="L1151">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">    if (jj_3R_11()) {</span>
<span class="fc" id="L1153">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">    if (jj_3R_12()) {</span>
<span class="fc" id="L1155">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L1156" title="All 2 branches covered.">    if (jj_3_2()) {</span>
<span class="fc" id="L1157">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">    if (jj_3R_13()) return true;</span>
    }
    }
    }
    }
<span class="fc" id="L1163">    return false;</span>
  }

  private boolean jj_3R_35()
 {
<span class="fc bfc" id="L1168" title="All 2 branches covered.">    if (jj_3R_22()) return true;</span>
<span class="fc" id="L1169">    return false;</span>
  }

  private boolean jj_3R_34()
 {
<span class="nc bnc" id="L1174" title="All 2 branches missed.">    if (jj_3R_9()) return true;</span>
<span class="nc" id="L1175">    return false;</span>
  }

  private boolean jj_3R_26()
 {
<span class="pc bpc" id="L1180" title="1 of 2 branches missed.">    if (jj_scan_token(17)) return true;</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">    if (jj_3R_31()) return true;</span>
<span class="nc" id="L1182">    return false;</span>
  }

  private boolean jj_3R_36()
 {
<span class="pc bpc" id="L1187" title="1 of 2 branches missed.">    if (jj_3R_27()) return true;</span>
<span class="nc" id="L1188">    return false;</span>
  }

  private boolean jj_3R_18()
 {
<span class="fc bfc" id="L1193" title="All 2 branches covered.">    if (jj_scan_token(17)) return true;</span>
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">    if (jj_3R_8()) return true;</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">    if (jj_scan_token(18)) return true;</span>
<span class="nc" id="L1196">    return false;</span>
  }

  private boolean jj_3R_6()
 {
    Token xsp;
<span class="fc" id="L1202">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L1203" title="1 of 2 branches missed.">    if (jj_3R_17()) {</span>
<span class="fc" id="L1204">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">    if (jj_3R_18()) return true;</span>
    }
<span class="nc" id="L1207">    return false;</span>
  }

  private boolean jj_3R_17()
 {
<span class="pc bpc" id="L1212" title="1 of 2 branches missed.">    if (jj_3R_22()) return true;</span>
<span class="nc" id="L1213">    return false;</span>
  }

  private boolean jj_3R_27()
 {
<span class="pc bpc" id="L1218" title="1 of 2 branches missed.">    if (jj_scan_token(FLAGS)) return true;</span>
<span class="nc" id="L1219">    return false;</span>
  }

  private boolean jj_3R_2()
 {
<span class="fc bfc" id="L1224" title="All 2 branches covered.">    if (jj_3R_9()) return true;</span>
<span class="fc" id="L1225">    return false;</span>
  }

  private boolean jj_3R_37()
 {
<span class="pc bpc" id="L1230" title="1 of 2 branches missed.">    if (jj_3R_38()) return true;</span>
<span class="nc" id="L1231">    return false;</span>
  }

  private boolean jj_3R_19()
 {
<span class="pc bpc" id="L1236" title="1 of 2 branches missed.">    if (jj_3R_6()) return true;</span>
<span class="nc" id="L1237">    return false;</span>
  }

  private boolean jj_3R_25()
 {
<span class="fc bfc" id="L1242" title="All 2 branches covered.">    if (jj_3R_30()) return true;</span>
<span class="fc" id="L1243">    return false;</span>
  }

  private boolean jj_3R_33()
 {
<span class="fc bfc" id="L1248" title="All 2 branches covered.">    if (jj_scan_token(34)) return true;</span>
    Token xsp;
<span class="fc" id="L1250">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L1251" title="1 of 2 branches missed.">    if (jj_3R_37()) jj_scanpos = xsp;</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">    if (jj_scan_token(35)) return true;</span>
<span class="nc" id="L1253">    return false;</span>
  }

  private boolean jj_3R_32()
 {
<span class="fc bfc" id="L1258" title="All 2 branches covered.">    if (jj_3R_35()) return true;</span>
    Token xsp;
<span class="fc" id="L1260">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">    if (jj_3R_36()) jj_scanpos = xsp;</span>
<span class="fc" id="L1262">    return false;</span>
  }

  private boolean jj_3R_30()
 {
    Token xsp;
<span class="fc" id="L1268">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L1269" title="All 2 branches covered.">    if (jj_3R_32()) {</span>
<span class="fc" id="L1270">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">    if (jj_3R_33()) return true;</span>
    }
<span class="fc" id="L1273">    return false;</span>
  }

  private boolean jj_3R_8()
 {
    Token xsp;
<span class="fc" id="L1279">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L1280" title="1 of 2 branches missed.">    if (jj_3_6()) {</span>
<span class="fc" id="L1281">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L1282" title="1 of 2 branches missed.">    if (jj_3R_19()) return true;</span>
    }
<span class="nc" id="L1284">    return false;</span>
  }

  private boolean jj_3_6()
 {
<span class="pc bpc" id="L1289" title="1 of 2 branches missed.">    if (jj_3R_6()) return true;</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">    if (jj_3R_7()) return true;</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">    if (jj_3R_8()) return true;</span>
<span class="nc" id="L1292">    return false;</span>
  }

  /** Generated Token Manager. */
  public CorpusQueryLanguageParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
<span class="pc" id="L1306">  final private int[] jj_la1 = new int[32];</span>
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
<span class="fc" id="L1310">      jj_la1_init_0();</span>
<span class="fc" id="L1311">      jj_la1_init_1();</span>
<span class="fc" id="L1312">   }</span>
   private static void jj_la1_init_0() {
<span class="fc" id="L1314">      jj_la1_0 = new int[] {0x4000,0xc0000000,0x18000,0x18000,0x100000,0xa3a00,0x180,0x180,0xc0000000,0x400000,0x200,0x400000,0x3000,0x800,0x7000000,0x8000000,0xc0000000,0xa00,0x223000,0xa00,0x400,0xa3200,0x3000,0xc0000000,0xa0000,0x400,0x400,0x400,0x23200,0x400000,0x23000,0x23000,};</span>
<span class="fc" id="L1315">   }</span>
   private static void jj_la1_init_1() {
<span class="fc" id="L1317">      jj_la1_1 = new int[] {0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x4,0x0,0x0,0x0,0x4,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};</span>
<span class="fc" id="L1318">   }</span>
<span class="pc" id="L1319">  final private JJCalls[] jj_2_rtns = new JJCalls[6];</span>
<span class="pc" id="L1320">  private boolean jj_rescan = false;</span>
<span class="pc" id="L1321">  private int jj_gc = 0;</span>

  /** Constructor with InputStream. */
  public CorpusQueryLanguageParser(java.io.InputStream stream) {
<span class="nc" id="L1325">     this(stream, null);</span>
<span class="nc" id="L1326">  }</span>
  /** Constructor with InputStream and supplied encoding */
<span class="nc" id="L1328">  public CorpusQueryLanguageParser(java.io.InputStream stream, String encoding) {</span>
<span class="nc" id="L1329">    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }</span>
<span class="nc" id="L1330">    token_source = new CorpusQueryLanguageParserTokenManager(jj_input_stream);</span>
<span class="nc" id="L1331">    token = new Token();</span>
<span class="nc" id="L1332">    jj_ntk = -1;</span>
<span class="nc" id="L1333">    jj_gen = 0;</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">    for (int i = 0; i &lt; 32; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L1336">  }</span>

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
<span class="nc" id="L1340">     ReInit(stream, null);</span>
<span class="nc" id="L1341">  }</span>
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
<span class="nc" id="L1344">    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }</span>
<span class="nc" id="L1345">    token_source.ReInit(jj_input_stream);</span>
<span class="nc" id="L1346">    token = new Token();</span>
<span class="nc" id="L1347">    jj_ntk = -1;</span>
<span class="nc" id="L1348">    jj_gen = 0;</span>
<span class="nc bnc" id="L1349" title="All 2 branches missed.">    for (int i = 0; i &lt; 32; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L1351">  }</span>

  /** Constructor. */
<span class="fc" id="L1354">  public CorpusQueryLanguageParser(java.io.Reader stream) {</span>
<span class="fc" id="L1355">    jj_input_stream = new JavaCharStream(stream, 1, 1);</span>
<span class="fc" id="L1356">    token_source = new CorpusQueryLanguageParserTokenManager(jj_input_stream);</span>
<span class="fc" id="L1357">    token = new Token();</span>
<span class="fc" id="L1358">    jj_ntk = -1;</span>
<span class="fc" id="L1359">    jj_gen = 0;</span>
<span class="fc bfc" id="L1360" title="All 2 branches covered.">    for (int i = 0; i &lt; 32; i++) jj_la1[i] = -1;</span>
<span class="fc bfc" id="L1361" title="All 2 branches covered.">    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="fc" id="L1362">  }</span>

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
<span class="nc bnc" id="L1366" title="All 2 branches missed.">	if (jj_input_stream == null) {</span>
<span class="nc" id="L1367">      jj_input_stream = new JavaCharStream(stream, 1, 1);</span>
   } else {
<span class="nc" id="L1369">      jj_input_stream.ReInit(stream, 1, 1);</span>
   }
<span class="nc bnc" id="L1371" title="All 2 branches missed.">   if (token_source == null) {</span>
<span class="nc" id="L1372">      token_source = new CorpusQueryLanguageParserTokenManager(jj_input_stream);</span>
   }

<span class="nc" id="L1375">    token_source.ReInit(jj_input_stream);</span>
<span class="nc" id="L1376">    token = new Token();</span>
<span class="nc" id="L1377">    jj_ntk = -1;</span>
<span class="nc" id="L1378">    jj_gen = 0;</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">    for (int i = 0; i &lt; 32; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L1381">  }</span>

  /** Constructor with generated Token Manager. */
<span class="nc" id="L1384">  public CorpusQueryLanguageParser(CorpusQueryLanguageParserTokenManager tm) {</span>
<span class="nc" id="L1385">    token_source = tm;</span>
<span class="nc" id="L1386">    token = new Token();</span>
<span class="nc" id="L1387">    jj_ntk = -1;</span>
<span class="nc" id="L1388">    jj_gen = 0;</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">    for (int i = 0; i &lt; 32; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L1391">  }</span>

  /** Reinitialise. */
  public void ReInit(CorpusQueryLanguageParserTokenManager tm) {
<span class="nc" id="L1395">    token_source = tm;</span>
<span class="nc" id="L1396">    token = new Token();</span>
<span class="nc" id="L1397">    jj_ntk = -1;</span>
<span class="nc" id="L1398">    jj_gen = 0;</span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">    for (int i = 0; i &lt; 32; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">    for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L1401">  }</span>

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
<span class="fc bfc" id="L1405" title="All 2 branches covered.">    if ((oldToken = token).next != null) token = token.next;</span>
<span class="fc" id="L1406">    else token = token.next = token_source.getNextToken();</span>
<span class="fc" id="L1407">    jj_ntk = -1;</span>
<span class="pc bpc" id="L1408" title="1 of 2 branches missed.">    if (token.kind == kind) {</span>
<span class="fc" id="L1409">      jj_gen++;</span>
<span class="pc bpc" id="L1410" title="1 of 2 branches missed.">      if (++jj_gc &gt; 100) {</span>
<span class="nc" id="L1411">        jj_gc = 0;</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">        for (int i = 0; i &lt; jj_2_rtns.length; i++) {</span>
<span class="nc" id="L1413">          JJCalls c = jj_2_rtns[i];</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">          while (c != null) {</span>
<span class="nc bnc" id="L1415" title="All 2 branches missed.">            if (c.gen &lt; jj_gen) c.first = null;</span>
<span class="nc" id="L1416">            c = c.next;</span>
          }
        }
      }
<span class="fc" id="L1420">      return token;</span>
    }
<span class="nc" id="L1422">    token = oldToken;</span>
<span class="nc" id="L1423">    jj_kind = kind;</span>
<span class="nc" id="L1424">    throw generateParseException();</span>
  }

  @SuppressWarnings(&quot;serial&quot;)
<span class="fc" id="L1428">  static private final class LookaheadSuccess extends java.lang.Error { }</span>
<span class="pc" id="L1429">  final private LookaheadSuccess jj_ls = new LookaheadSuccess();</span>
  private boolean jj_scan_token(int kind) {
<span class="fc bfc" id="L1431" title="All 2 branches covered.">    if (jj_scanpos == jj_lastpos) {</span>
<span class="fc" id="L1432">      jj_la--;</span>
<span class="fc bfc" id="L1433" title="All 2 branches covered.">      if (jj_scanpos.next == null) {</span>
<span class="fc" id="L1434">        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();</span>
      } else {
<span class="fc" id="L1436">        jj_lastpos = jj_scanpos = jj_scanpos.next;</span>
      }
    } else {
<span class="fc" id="L1439">      jj_scanpos = jj_scanpos.next;</span>
    }
<span class="pc bpc" id="L1441" title="1 of 2 branches missed.">    if (jj_rescan) {</span>
<span class="nc" id="L1442">      int i = 0; Token tok = token;</span>
<span class="nc bnc" id="L1443" title="All 4 branches missed.">      while (tok != null &amp;&amp; tok != jj_scanpos) { i++; tok = tok.next; }</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">      if (tok != null) jj_add_error_token(kind, i);</span>
    }
<span class="fc bfc" id="L1446" title="All 2 branches covered.">    if (jj_scanpos.kind != kind) return true;</span>
<span class="pc bpc" id="L1447" title="1 of 4 branches missed.">    if (jj_la == 0 &amp;&amp; jj_scanpos == jj_lastpos) throw jj_ls;</span>
<span class="fc" id="L1448">    return false;</span>
  }


/** Get the next Token. */
  final public Token getNextToken() {
<span class="nc bnc" id="L1454" title="All 2 branches missed.">    if (token.next != null) token = token.next;</span>
<span class="nc" id="L1455">    else token = token.next = token_source.getNextToken();</span>
<span class="nc" id="L1456">    jj_ntk = -1;</span>
<span class="nc" id="L1457">    jj_gen++;</span>
<span class="nc" id="L1458">    return token;</span>
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
<span class="nc" id="L1463">    Token t = token;</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">    for (int i = 0; i &lt; index; i++) {</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">      if (t.next != null) t = t.next;</span>
<span class="nc" id="L1466">      else t = t.next = token_source.getNextToken();</span>
    }
<span class="nc" id="L1468">    return t;</span>
  }

  private int jj_ntk_f() {
<span class="fc bfc" id="L1472" title="All 2 branches covered.">    if ((jj_nt=token.next) == null)</span>
<span class="fc" id="L1473">      return (jj_ntk = (token.next=token_source.getNextToken()).kind);</span>
    else
<span class="fc" id="L1475">      return (jj_ntk = jj_nt.kind);</span>
  }

<span class="pc" id="L1478">  private java.util.List&lt;int[]&gt; jj_expentries = new java.util.ArrayList&lt;int[]&gt;();</span>
  private int[] jj_expentry;
<span class="pc" id="L1480">  private int jj_kind = -1;</span>
<span class="pc" id="L1481">  private int[] jj_lasttokens = new int[100];</span>
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
<span class="nc bnc" id="L1485" title="All 2 branches missed.">    if (pos &gt;= 100) {</span>
<span class="nc" id="L1486">       return;</span>
    }

<span class="nc bnc" id="L1489" title="All 2 branches missed.">    if (pos == jj_endpos + 1) {</span>
<span class="nc" id="L1490">      jj_lasttokens[jj_endpos++] = kind;</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">    } else if (jj_endpos != 0) {</span>
<span class="nc" id="L1492">      jj_expentry = new int[jj_endpos];</span>

<span class="nc bnc" id="L1494" title="All 2 branches missed.">      for (int i = 0; i &lt; jj_endpos; i++) {</span>
<span class="nc" id="L1495">        jj_expentry[i] = jj_lasttokens[i];</span>
      }

<span class="nc bnc" id="L1498" title="All 2 branches missed.">      for (int[] oldentry : jj_expentries) {</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">        if (oldentry.length == jj_expentry.length) {</span>
<span class="nc" id="L1500">          boolean isMatched = true;</span>

<span class="nc bnc" id="L1502" title="All 2 branches missed.">          for (int i = 0; i &lt; jj_expentry.length; i++) {</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">            if (oldentry[i] != jj_expentry[i]) {</span>
<span class="nc" id="L1504">              isMatched = false;</span>
<span class="nc" id="L1505">              break;</span>
            }

          }
<span class="nc bnc" id="L1509" title="All 2 branches missed.">          if (isMatched) {</span>
<span class="nc" id="L1510">            jj_expentries.add(jj_expentry);</span>
<span class="nc" id="L1511">            break;</span>
          }
        }
<span class="nc" id="L1514">      }</span>

<span class="nc bnc" id="L1516" title="All 2 branches missed.">      if (pos != 0) {</span>
<span class="nc" id="L1517">        jj_lasttokens[(jj_endpos = pos) - 1] = kind;</span>
      }
    }
<span class="nc" id="L1520">  }</span>

  /** Generate ParseException. */
  public ParseException generateParseException() {
<span class="nc" id="L1524">    jj_expentries.clear();</span>
<span class="nc" id="L1525">    boolean[] la1tokens = new boolean[36];</span>
<span class="nc bnc" id="L1526" title="All 2 branches missed.">    if (jj_kind &gt;= 0) {</span>
<span class="nc" id="L1527">      la1tokens[jj_kind] = true;</span>
<span class="nc" id="L1528">      jj_kind = -1;</span>
    }
<span class="nc bnc" id="L1530" title="All 2 branches missed.">    for (int i = 0; i &lt; 32; i++) {</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">      if (jj_la1[i] == jj_gen) {</span>
<span class="nc bnc" id="L1532" title="All 2 branches missed.">        for (int j = 0; j &lt; 32; j++) {</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">          if ((jj_la1_0[i] &amp; (1&lt;&lt;j)) != 0) {</span>
<span class="nc" id="L1534">            la1tokens[j] = true;</span>
          }
<span class="nc bnc" id="L1536" title="All 2 branches missed.">          if ((jj_la1_1[i] &amp; (1&lt;&lt;j)) != 0) {</span>
<span class="nc" id="L1537">            la1tokens[32+j] = true;</span>
          }
        }
      }
    }
<span class="nc bnc" id="L1542" title="All 2 branches missed.">    for (int i = 0; i &lt; 36; i++) {</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">      if (la1tokens[i]) {</span>
<span class="nc" id="L1544">        jj_expentry = new int[1];</span>
<span class="nc" id="L1545">        jj_expentry[0] = i;</span>
<span class="nc" id="L1546">        jj_expentries.add(jj_expentry);</span>
      }
    }
<span class="nc" id="L1549">    jj_endpos = 0;</span>
<span class="nc" id="L1550">    jj_rescan_token();</span>
<span class="nc" id="L1551">    jj_add_error_token(0, 0);</span>
<span class="nc" id="L1552">    int[][] exptokseq = new int[jj_expentries.size()][];</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">    for (int i = 0; i &lt; jj_expentries.size(); i++) {</span>
<span class="nc" id="L1554">      exptokseq[i] = jj_expentries.get(i);</span>
    }
<span class="nc" id="L1556">    return new ParseException(token, exptokseq, tokenImage);</span>
  }

  /** Enable tracing. */
  final public void enable_tracing() {
<span class="nc" id="L1561">  }</span>

  /** Disable tracing. */
  final public void disable_tracing() {
<span class="nc" id="L1565">  }</span>

  private void jj_rescan_token() {
<span class="nc" id="L1568">    jj_rescan = true;</span>
<span class="nc bnc" id="L1569" title="All 2 branches missed.">    for (int i = 0; i &lt; 6; i++) {</span>
      try {
<span class="nc" id="L1571">        JJCalls p = jj_2_rtns[i];</span>

        do {
<span class="nc bnc" id="L1574" title="All 2 branches missed.">          if (p.gen &gt; jj_gen) {</span>
<span class="nc" id="L1575">            jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;</span>
<span class="nc bnc" id="L1576" title="All 7 branches missed.">            switch (i) {</span>
<span class="nc" id="L1577">              case 0: jj_3_1(); break;</span>
<span class="nc" id="L1578">              case 1: jj_3_2(); break;</span>
<span class="nc" id="L1579">              case 2: jj_3_3(); break;</span>
<span class="nc" id="L1580">              case 3: jj_3_4(); break;</span>
<span class="nc" id="L1581">              case 4: jj_3_5(); break;</span>
<span class="nc" id="L1582">              case 5: jj_3_6(); break;</span>
            }
          }
<span class="nc" id="L1585">          p = p.next;</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">        } while (p != null);</span>

<span class="nc" id="L1588">        } catch(LookaheadSuccess ls) { }</span>
    }
<span class="nc" id="L1590">    jj_rescan = false;</span>
<span class="nc" id="L1591">  }</span>

  private void jj_save(int index, int xla) {
<span class="fc" id="L1594">    JJCalls p = jj_2_rtns[index];</span>
<span class="fc bfc" id="L1595" title="All 2 branches covered.">    while (p.gen &gt; jj_gen) {</span>
<span class="fc bfc" id="L1596" title="All 2 branches covered.">      if (p.next == null) { p = p.next = new JJCalls(); break; }</span>
<span class="fc" id="L1597">      p = p.next;</span>
    }

<span class="fc" id="L1600">    p.gen = jj_gen + xla - jj_la; </span>
<span class="fc" id="L1601">    p.first = token;</span>
<span class="fc" id="L1602">    p.arg = xla;</span>
<span class="fc" id="L1603">  }</span>

<span class="fc" id="L1605">  static final class JJCalls {</span>
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>