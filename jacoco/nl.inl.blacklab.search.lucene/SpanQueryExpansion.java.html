<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SpanQueryExpansion.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.search.lucene</a> &gt; <span class="el_source">SpanQueryExpansion.java</span></div><h1>SpanQueryExpansion.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2010, 2012 Institute for Dutch Lexicology
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package nl.inl.blacklab.search.lucene;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.index.Term;
import org.apache.lucene.index.TermContext;
import org.apache.lucene.search.IndexSearcher;

import nl.inl.blacklab.search.fimatch.Nfa;
import nl.inl.blacklab.search.fimatch.NfaState;
import nl.inl.blacklab.search.fimatch.NfaStateAnyToken;
import nl.inl.blacklab.search.fimatch.ForwardIndexAccessor;

/**
 * Expands the source spans to the left and right by the given ranges.
 *
 * This is used to support sequences including subsequences of completely unknown tokens (like
 * &quot;apple&quot; []{2, 4} &quot;pear&quot; to find apple and pear with 2 to 4 tokens in between).
 *
 * Note that this class will generate all possible expansions, so if you call it with left-expansion
 * of between 2 to 4 tokens, it will generate 3 new hits for every hit from the source spans: one
 * hit with 2 more tokens to the left, one hit with 3 more tokens to the left, and one hit with 4
 * more tokens to the left.
 *
 * Spans generated from this query will be sorted by start point and then by end point, and any
 * duplicates generated will be discarded.
 */
public class SpanQueryExpansion extends BLSpanQueryAbstract {

	/** Whether to expand to left (true) or right (false) */
	boolean expandToLeft;

	/** Minimum number of tokens to expand */
	int min;

	/** Maximum number of tokens to expand (MAX_UNLIMITED = infinite) */
	int max;

	/** if true, we assume the last token is always a special closing token and ignore it */
<span class="fc" id="L61">	boolean ignoreLastToken = false;</span>

	public boolean isIgnoreLastToken() {
<span class="fc" id="L64">		return ignoreLastToken;</span>
	}

	public SpanQueryExpansion(BLSpanQuery clause, boolean expandToLeft, int min, int max) {
<span class="fc" id="L68">		super(clause);</span>
<span class="fc" id="L69">		this.expandToLeft = expandToLeft;</span>
<span class="fc" id="L70">		this.min = min;</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">		this.max = max == -1 ? MAX_UNLIMITED : max;</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">		if (min &gt; this.max)</span>
<span class="nc" id="L73">			throw new IllegalArgumentException(&quot;min &gt; max&quot;);</span>
<span class="pc bpc" id="L74" title="2 of 4 branches missed.">		if (min &lt; 0 || this.max &lt; 0)</span>
<span class="nc" id="L75">			throw new IllegalArgumentException(&quot;Expansions cannot be negative&quot;);</span>
<span class="fc" id="L76">	}</span>

	@Override
	public boolean equals(Object o) {
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">		if (this == o)</span>
<span class="nc" id="L81">			return true;</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">		if (!super.equals(o))</span>
<span class="fc" id="L83">			return false;</span>

<span class="nc" id="L85">		final SpanQueryExpansion that = (SpanQueryExpansion) o;</span>
<span class="nc bnc" id="L86" title="All 6 branches missed.">		return expandToLeft == that.expandToLeft &amp;&amp; min == that.min &amp;&amp; max == that.max;</span>
	}

	@Override
	public BLSpanQuery rewrite(IndexReader reader) throws IOException {
<span class="fc" id="L91">		List&lt;BLSpanQuery&gt; rewritten = rewriteClauses(reader);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">		if (rewritten == null)</span>
<span class="fc" id="L93">			return this;</span>
<span class="pc bpc" id="L94" title="1 of 4 branches missed.">		if (min == 0 &amp;&amp; max == 0)</span>
<span class="nc" id="L95">			return rewritten.get(0); // not really an expansion</span>
<span class="fc" id="L96">		SpanQueryExpansion result = new SpanQueryExpansion(rewritten.get(0), expandToLeft, min, max);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">		if (ignoreLastToken)</span>
<span class="fc" id="L98">			result.setIgnoreLastToken(true);</span>
<span class="fc" id="L99">		return result;</span>
	}

	@Override
	public boolean matchesEmptySequence() {
<span class="pc bpc" id="L104" title="3 of 4 branches missed.">		return clauses.get(0).matchesEmptySequence() &amp;&amp; min == 0;</span>
	}

	@Override
	public BLSpanQuery noEmpty() {
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">		if (!matchesEmptySequence())</span>
<span class="fc" id="L110">			return this;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">		int newMin = min == 0 ? 1 : min;</span>
<span class="nc" id="L112">		SpanQueryExpansion result = new SpanQueryExpansion(clauses.get(0).noEmpty(), expandToLeft, newMin, max);</span>
<span class="nc" id="L113">		result.setIgnoreLastToken(ignoreLastToken);</span>
<span class="nc" id="L114">		return result;</span>
	}

	@Override
	public BLSpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
<span class="fc" id="L119">		BLSpanWeight weight = clauses.get(0).createWeight(searcher, needsScores);</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">		return new SpanWeightExpansion(weight, searcher, needsScores ? getTermContexts(weight) : null);</span>
	}

	class SpanWeightExpansion extends BLSpanWeight {

		final BLSpanWeight weight;

<span class="fc" id="L127">		public SpanWeightExpansion(BLSpanWeight weight, IndexSearcher searcher, Map&lt;Term, TermContext&gt; terms) throws IOException {</span>
<span class="fc" id="L128">			super(SpanQueryExpansion.this, searcher, terms);</span>
<span class="fc" id="L129">			this.weight = weight;</span>
<span class="fc" id="L130">		}</span>

		@Override
		public void extractTerms(Set&lt;Term&gt; terms) {
<span class="fc" id="L134">			weight.extractTerms(terms);</span>
<span class="fc" id="L135">		}</span>

		@Override
		public void extractTermContexts(Map&lt;Term, TermContext&gt; contexts) {
<span class="nc" id="L139">			weight.extractTermContexts(contexts);</span>
<span class="nc" id="L140">		}</span>

		@Override
		public BLSpans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
<span class="fc" id="L144">			BLSpans spansSource = weight.getSpans(context, requiredPostings);</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">			if (spansSource == null)</span>
<span class="nc" id="L146">				return null;</span>
<span class="fc" id="L147">			BLSpans spans = new SpansExpansionRaw(ignoreLastToken, context.reader(), clauses.get(0).getField(), spansSource, expandToLeft, min, max);</span>
<span class="fc" id="L148">			return spans;</span>
		}

	}

	@Override
	public int hashCode() {
<span class="nc" id="L155">		int h = clauses.hashCode();</span>
<span class="nc" id="L156">		h ^= (h &lt;&lt; 10) | (h &gt;&gt;&gt; 23);</span>
<span class="nc" id="L157">		h ^= min &lt;&lt; 10;</span>
<span class="nc" id="L158">		h ^= max &lt;&lt; 5;</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">		h ^= expandToLeft ? 1 : 0;</span>
<span class="nc" id="L160">		return h;</span>
	}

	@Override
	public String toString(String field) {
<span class="fc bfc" id="L165" title="All 2 branches covered.">		return &quot;EXPAND(&quot; + clauses.get(0) + &quot;, &quot; + (expandToLeft ? &quot;L&quot; : &quot;R&quot;) + &quot;, &quot; + min + &quot;, &quot; + inf(max) + &quot;)&quot;;</span>
	}

	/** Set whether to ignore the last token.
	 *
	 * @param ignoreLastToken if true, we assume the last token is always a special closing token and ignore it
	 */
	public void setIgnoreLastToken(boolean ignoreLastToken) {
<span class="fc" id="L173">		this.ignoreLastToken = ignoreLastToken;</span>
<span class="fc" id="L174">	}</span>

	public boolean isExpandToLeft() {
<span class="nc" id="L177">		return expandToLeft;</span>
	}

	public int getMinExpand() {
<span class="nc" id="L181">		return min;</span>
	}

	public int getMaxExpand() {
<span class="nc" id="L185">		return max;</span>
	}

	public BLSpanQuery getClause() {
<span class="nc" id="L189">		return clauses.get(0);</span>
	}

	@Override
	public boolean hitsAllSameLength() {
<span class="pc bpc" id="L194" title="1 of 4 branches missed.">		return clauses.get(0).hitsAllSameLength() &amp;&amp; min == max;</span>
	}

	@Override
	public int hitsLengthMin() {
<span class="fc" id="L199">		return clauses.get(0).hitsLengthMin() + min;</span>
	}

	@Override
	public int hitsLengthMax() {
<span class="fc" id="L204">		return addMaxValues(clauses.get(0).hitsLengthMax(), max);</span>
	}

	@Override
	public boolean hitsEndPointSorted() {
<span class="pc bpc" id="L209" title="2 of 8 branches missed.">		return clauses.get(0).hitsEndPointSorted() &amp;&amp; (expandToLeft || !expandToLeft &amp;&amp; min == max);</span>
	}

	@Override
	public boolean hitsStartPointSorted() {
<span class="pc bpc" id="L214" title="2 of 8 branches missed.">		return clauses.get(0).hitsStartPointSorted() &amp;&amp; (!expandToLeft || expandToLeft &amp;&amp; min == max);</span>
	}

	@Override
	public boolean hitsHaveUniqueStart() {
<span class="pc bpc" id="L219" title="1 of 4 branches missed.">		return clauses.get(0).hitsHaveUniqueStart() &amp;&amp; min == max;</span>
	}

	@Override
	public boolean hitsHaveUniqueEnd() {
<span class="pc bpc" id="L224" title="1 of 4 branches missed.">		return clauses.get(0).hitsHaveUniqueEnd() &amp;&amp; min == max;</span>
	}

	@Override
	public boolean hitsAreUnique() {
<span class="pc bpc" id="L229" title="1 of 4 branches missed.">		return clauses.get(0).hitsAreUnique() &amp;&amp; min == max;</span>
	}

	@Override
	public Nfa getNfa(ForwardIndexAccessor fiAccessor, int direction) {
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">		if (max == MAX_UNLIMITED)</span>
<span class="nc" id="L235">			throw new UnsupportedOperationException(&quot;Unlimited expansion using forward index not implemented&quot;);</span>
<span class="fc" id="L236">		Nfa nfa = clauses.get(0).getNfa(fiAccessor, direction);</span>
<span class="fc" id="L237">		NfaState any = new NfaStateAnyToken(clauses.get(0).getRealField(), null);</span>
<span class="fc" id="L238">		Nfa frag = new Nfa(any, Arrays.asList(any));</span>
<span class="fc" id="L239">		frag.repeat(min, max);</span>
<span class="fc bfc" id="L240" title="All 8 branches covered.">		if (expandToLeft &amp;&amp; direction == 1 || !expandToLeft &amp;&amp; direction == -1) {</span>
			// Prepend nfa with stretch of anytokens
<span class="fc" id="L242">			frag.append(nfa);</span>
<span class="fc" id="L243">			nfa = frag;</span>
		} else {
			// Append stretch of anytokens to nfa
<span class="fc" id="L246">			nfa.append(frag);</span>
		}
<span class="fc" id="L248">		return nfa;</span>
	}

	@Override
	public boolean canMakeNfa() {
<span class="fc bfc" id="L253" title="All 4 branches covered.">		return max != MAX_UNLIMITED &amp;&amp; clauses.get(0).canMakeNfa();</span>
	}

	@Override
	public long reverseMatchingCost(IndexReader reader) {
<span class="fc bfc" id="L258" title="All 2 branches covered.">		int numberOfExpansionSteps = max == MAX_UNLIMITED ? 50 : max - min + 1;</span>
<span class="fc" id="L259">		return clauses.get(0).reverseMatchingCost(reader) * numberOfExpansionSteps;</span>
	}

	@Override
	public int forwardMatchingCost() {
<span class="fc" id="L264">		int cost = clauses.get(0).forwardMatchingCost();</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">		int nMax = max == MAX_UNLIMITED ? 50 : max;</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">		for (int i = min; i &lt;= nMax; i++) {</span>
<span class="fc" id="L267">			cost += i;</span>
		}
<span class="fc" id="L269">		return cost;</span>
	}

	public BLSpanQuery addExpand(int addMin, int addMax) {
<span class="fc" id="L273">		int nMin = min + addMin;</span>
<span class="fc" id="L274">		int nMax = addMaxValues(max, addMax);</span>
<span class="fc" id="L275">		SpanQueryExpansion result = new SpanQueryExpansion(clauses.get(0), expandToLeft, nMin, nMax);</span>
<span class="fc" id="L276">		result.setIgnoreLastToken(isIgnoreLastToken());</span>
<span class="fc" id="L277">		return result;</span>
	}

	@Override
	public boolean canInternalizeNeighbour(BLSpanQuery clause, boolean onTheRight) {
<span class="fc bfc" id="L282" title="All 2 branches covered.">		if (onTheRight == expandToLeft) {</span>
			// Internalization on the side of our non-expanded clause. Always possible.
<span class="fc" id="L284">			return true;</span>
		}
		// Internalization on the side of our expansion. Only possible for any token clauses.
<span class="fc" id="L287">		return clause instanceof SpanQueryAnyToken;</span>
	}

	@Override
	public BLSpanQuery internalizeNeighbour(BLSpanQuery clause, boolean onTheRight) {
<span class="pc bpc" id="L292" title="1 of 4 branches missed.">		if (onTheRight != expandToLeft &amp;&amp; !(clause instanceof SpanQueryAnyToken)) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">			throw new IllegalArgumentException(&quot;Cannot internalize &quot; + clause + &quot; into &quot; + this + &quot; on the &quot; + (onTheRight ? &quot;right&quot; : &quot;left&quot;) + &quot;side&quot;);</span>
		}
<span class="fc bfc" id="L295" title="All 2 branches covered.">		if (onTheRight == expandToLeft) {</span>
			// &quot;Gobble up&quot; a clause into the clause we're expanding.
			// If we're expanding to the left, the clause is added to the right of what we were expanding, and vice versa.
<span class="fc" id="L298">			SpanQuerySequence seq = SpanQuerySequence.sequenceInternalize(clauses.get(0), clause, expandToLeft);</span>
<span class="fc" id="L299">			SpanQueryExpansion result = new SpanQueryExpansion(seq, expandToLeft, min, max);</span>
<span class="fc" id="L300">			result.setIgnoreLastToken(ignoreLastToken);</span>
<span class="fc" id="L301">			return result;</span>
		}
		// Add any token to our expansion.
<span class="fc" id="L304">		return addExpand(clause.hitsLengthMin(), clause.hitsLengthMax());</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>