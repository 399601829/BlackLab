<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SpanQuerySequence.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.search.lucene</a> &gt; <span class="el_source">SpanQuerySequence.java</span></div><h1>SpanQuerySequence.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2010, 2012 Institute for Dutch Lexicology
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package nl.inl.blacklab.search.lucene;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.index.Term;
import org.apache.lucene.index.TermContext;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.spans.SpanWeight;

import nl.inl.blacklab.search.Searcher;
import nl.inl.blacklab.search.fimatch.ForwardIndexAccessor;
import nl.inl.blacklab.search.fimatch.Nfa;
import nl.inl.blacklab.search.lucene.optimize.ClauseCombiner;

/**
 * Combines spans, keeping only combinations of hits that occur one after the other. The order is
 * significant: a hit from the first span must be followed by a hit from the second.
 *
 * Note that this class is different from org.apache.lucene.search.spans.SpanNearQuery: it tries to
 * make sure it generates *all* possible sequence matches. SpanNearQuery doesn't do this; once a hit
 * is used in a SpanNearQuery match, it advances to the next hit.
 *
 * In the future, this class could be expanded to make the exact behaviour configurable: find all
 * matches / find longest matches / find shortest matches / ...
 *
 * See SpanSequenceRaw for details on the matching process.
 */
public class SpanQuerySequence extends BLSpanQueryAbstract {
<span class="fc" id="L55">	protected static final Logger logger = LogManager.getLogger(SpanQuerySequence.class);</span>

	public SpanQuerySequence(BLSpanQuery first, BLSpanQuery second) {
<span class="fc" id="L58">		super(first, second);</span>
<span class="fc" id="L59">	}</span>

	public SpanQuerySequence(Collection&lt;BLSpanQuery&gt; clauscol) {
<span class="fc" id="L62">		super(clauscol);</span>
<span class="fc" id="L63">	}</span>

	public SpanQuerySequence(BLSpanQuery[] _clauses) {
<span class="fc" id="L66">		super(_clauses);</span>
<span class="fc" id="L67">	}</span>

	/**
	 * Flatten nested sequences in clauses array.
	 *
	 * Flattens in-place.
	 *
	 * @param clauses clauses which may need flattening
	 * @return true if any rewriting was done, false if not
	 */
	private static boolean flattenSequence(List&lt;BLSpanQuery&gt; clauses) {
<span class="fc" id="L78">		boolean anyRewritten = false;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">		for (int i = 0; i &lt; clauses.size(); i++) {</span>
<span class="fc" id="L80">			BLSpanQuery child = clauses.get(i);</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">			if (child instanceof SpanQuerySequence) {</span>
<span class="fc" id="L82">				clauses.remove(i);</span>
<span class="fc" id="L83">				clauses.addAll(i, ((SpanQuerySequence) child).getClauses());</span>
<span class="fc" id="L84">				anyRewritten = true;</span>
			}
		}
<span class="fc" id="L87">		return anyRewritten;</span>
	}

	/**
	 * Try to match separate start and end tags in this sequence, and convert into a
	 * position filter (e.g. containing) query.
	 *
	 * For example:
	 *  &lt;s&gt; []* 'bla' []* &lt;/s&gt; ==&gt; &lt;s/&gt; containing 'bla'
	 *
	 * @param clauses clauses in which to find matching tags
	 * @return true if any rewriting was done, false if not
	 */
	protected boolean matchingTagsToPosFilter(List&lt;BLSpanQuery&gt; clauses) {
<span class="fc" id="L101">		boolean anyRewritten = false;</span>

		// Try to match separate start and end tags in this sequence, and convert into a
		// containing query. (&lt;s&gt; []* 'bla' []* &lt;/s&gt; ==&gt; &lt;s/&gt; containing 'bla')
<span class="fc bfc" id="L105" title="All 2 branches covered.">		for (int i = 0; i &lt; clauses.size(); i++) {</span>
<span class="fc" id="L106">			BLSpanQuery clause = clauses.get(i);</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">			if (clause instanceof SpanQueryEdge) {</span>
<span class="fc" id="L108">				SpanQueryEdge start = (SpanQueryEdge) clause;</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">				if (!start.isRightEdge()) {</span>
<span class="fc" id="L110">					String tagName = start.getElementName();</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">					if (tagName != null) {</span>
						// Start tag found. Is there a matching end tag?
<span class="fc bfc" id="L113" title="All 2 branches covered.">						for (int j = i + 1; j &lt; clauses.size(); j++) {</span>
<span class="fc" id="L114">							BLSpanQuery clause2 = clauses.get(j);</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">							if (clause2 instanceof SpanQueryEdge) {</span>
<span class="fc" id="L116">								SpanQueryEdge end = (SpanQueryEdge) clause2;</span>
<span class="pc bpc" id="L117" title="2 of 4 branches missed.">								if (end.isRightEdge() &amp;&amp; end.getElementName().equals(tagName)) {</span>
									// Found start and end tags in sequence. Convert to containing
									// query.
<span class="fc" id="L120">									List&lt;BLSpanQuery&gt; search = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L121">									clauses.remove(i); // start tag</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">									for (int k = 0; k &lt; j - i - 1; k++) {</span>
<span class="fc" id="L123">										search.add(clauses.remove(i));</span>
									}
<span class="fc" id="L125">									clauses.remove(i); // end tag</span>
<span class="fc" id="L126">									boolean startAny = false;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">									if (search.get(0) instanceof SpanQueryAnyToken) {</span>
<span class="fc" id="L128">										SpanQueryAnyToken any1 = (SpanQueryAnyToken) search.get(0);</span>
<span class="pc bpc" id="L129" title="2 of 4 branches missed.">										if (any1.hitsLengthMin() == 0 &amp;&amp; any1.hitsLengthMax() == MAX_UNLIMITED) {</span>
<span class="fc" id="L130">											startAny = true;</span>
<span class="fc" id="L131">											search.remove(0);</span>
										}
									}
<span class="fc" id="L134">									boolean endAny = false;</span>
<span class="fc" id="L135">									int last = search.size() - 1;</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">									if (search.get(last) instanceof SpanQueryAnyToken) {</span>
<span class="fc" id="L137">										SpanQueryAnyToken any2 = (SpanQueryAnyToken) search.get(last);</span>
<span class="pc bpc" id="L138" title="2 of 4 branches missed.">										if (any2.hitsLengthMin() == 0 &amp;&amp; any2.hitsLengthMax() == MAX_UNLIMITED) {</span>
<span class="fc" id="L139">											endAny = true;</span>
<span class="fc" id="L140">											search.remove(last);</span>
										}
									}
<span class="fc" id="L143">									BLSpanQuery producer = start.getClause();</span>
<span class="fc" id="L144">									BLSpanQuery filter = new SpanQuerySequence(search.toArray(new BLSpanQuery[0]));</span>
									SpanQueryPositionFilter.Operation op;
<span class="fc bfc" id="L146" title="All 2 branches covered.">									if (startAny) {</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">										if (endAny) {</span>
<span class="fc" id="L148">											op = SpanQueryPositionFilter.Operation.CONTAINING;</span>
										} else {
<span class="fc" id="L150">											op = SpanQueryPositionFilter.Operation.CONTAINING_AT_END;</span>
										}
									} else {
<span class="fc bfc" id="L153" title="All 2 branches covered.">										if (endAny) {</span>
<span class="fc" id="L154">											op = SpanQueryPositionFilter.Operation.CONTAINING_AT_START;</span>
										} else {
<span class="fc" id="L156">											op = SpanQueryPositionFilter.Operation.MATCHES;</span>
										}
									}
<span class="fc" id="L159">									clauses.add(i, new SpanQueryPositionFilter(producer, filter, op, false));</span>
<span class="fc" id="L160">									anyRewritten = true;</span>
								}
							}
						}
					}
				}
			}
		}
<span class="fc" id="L168">		return anyRewritten;</span>
	}

	static boolean rewriteClauses(List&lt;BLSpanQuery&gt; clauses, IndexReader reader) throws IOException {
<span class="fc" id="L172">		boolean anyRewritten = false;</span>
		// Rewrite all clauses.
<span class="fc bfc" id="L174" title="All 2 branches covered.">		for (int i = 0; i &lt; clauses.size(); i++) {</span>
<span class="fc" id="L175">			BLSpanQuery child = clauses.get(i);</span>
<span class="fc" id="L176">			BLSpanQuery rewritten = child.rewrite(reader);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">			if (child != rewritten) {</span>
				// Replace the child with the rewritten version
<span class="fc" id="L179">				anyRewritten = true;</span>
<span class="fc" id="L180">				clauses.set(i, rewritten);</span>
			}
		}
<span class="fc" id="L183">		return anyRewritten;</span>
	}

	static boolean optimizeClauses(List&lt;BLSpanQuery&gt; clauses, IndexReader reader) throws IOException {
<span class="fc" id="L187">		boolean anyRewritten = false;</span>
		// Rewrite all clauses.
<span class="fc bfc" id="L189" title="All 2 branches covered.">		for (int i = 0; i &lt; clauses.size(); i++) {</span>
<span class="fc" id="L190">			BLSpanQuery child = clauses.get(i);</span>
<span class="fc" id="L191">			BLSpanQuery rewritten = child.optimize(reader);</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">			if (child != rewritten) {</span>
				// Replace the child with the rewritten version
<span class="nc" id="L194">				anyRewritten = true;</span>
<span class="nc" id="L195">				clauses.set(i, rewritten);</span>
			}
		}
<span class="fc" id="L198">		return anyRewritten;</span>
	}

	static boolean combineAdjacentClauses(List&lt;BLSpanQuery&gt; cl, IndexReader reader, String fieldName, Set&lt;ClauseCombiner&gt; combiners) {

<span class="fc" id="L203">		boolean anyRewritten = false;</span>

		// Rewrite adjacent clauses according to rewriting precedence rules
<span class="fc" id="L206">		boolean anyRewrittenThisCycle = true;</span>
<span class="fc" id="L207">		int pass = 0;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">		while (anyRewrittenThisCycle) {</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">			if (Searcher.traceOptimization)</span>
<span class="nc" id="L210">				logger.debug(&quot;combineAdj pass &quot; + pass + &quot;: &quot; + StringUtils.join(cl, &quot;, &quot;));</span>
<span class="fc" id="L211">			pass++;</span>

<span class="fc" id="L213">			anyRewrittenThisCycle = false;</span>

			// Find the highest-priority rewrite possible
<span class="fc" id="L216">			int highestPrio = ClauseCombiner.CANNOT_COMBINE, highestPrioIndex = -1;</span>
<span class="fc" id="L217">			ClauseCombiner highestPrioCombiner = null;</span>
			BLSpanQuery left, right;
<span class="fc bfc" id="L219" title="All 2 branches covered.">			for (int i = 1; i &lt; cl.size(); i++) {</span>
				// See if any combiners apply, and if the priority is higher than found so far.
<span class="fc" id="L221">				left = cl.get(i - 1);</span>
<span class="fc" id="L222">				right = cl.get(i);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">				for (ClauseCombiner combiner: combiners) {</span>
<span class="fc" id="L224">					int prio = combiner.priority(left, right, reader);</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">					if (Searcher.traceOptimization)</span>
<span class="nc" id="L226">						logger.debug(&quot;  i=&quot; + i + &quot;, combiner=&quot; + combiner + &quot;, prio=&quot; + prio);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">					if (prio &lt; highestPrio) {</span>
<span class="fc" id="L228">						highestPrio = prio;</span>
<span class="fc" id="L229">						highestPrioIndex = i;</span>
<span class="fc" id="L230">						highestPrioCombiner = combiner;</span>
					}
<span class="fc" id="L232">				}</span>
			}
			// Any combiners found?
<span class="fc bfc" id="L235" title="All 2 branches covered.">			if (highestPrio &lt; ClauseCombiner.CANNOT_COMBINE) {</span>
				// Yes, execute the highest-prio combiner
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">				if (Searcher.traceOptimization)</span>
<span class="nc" id="L238">					logger.debug(&quot;  Execute combiner: &quot; + highestPrioCombiner + &quot;, index=&quot; + highestPrioIndex);</span>
<span class="fc" id="L239">				left = cl.get(highestPrioIndex - 1);</span>
<span class="fc" id="L240">				right = cl.get(highestPrioIndex);</span>
<span class="fc" id="L241">				BLSpanQuery combined = highestPrioCombiner.combine(left, right, reader);</span>
				// (we used to rewrite() combined here just to be safe, but that could break optimizations later)
<span class="fc" id="L243">				cl.remove(highestPrioIndex);</span>
<span class="fc" id="L244">				cl.set(highestPrioIndex - 1, combined);</span>
<span class="fc" id="L245">				anyRewrittenThisCycle = true;</span>
			}
<span class="fc bfc" id="L247" title="All 2 branches covered.">			if (anyRewrittenThisCycle)</span>
<span class="fc" id="L248">				anyRewritten = true;</span>
<span class="fc" id="L249">		}</span>

<span class="fc" id="L251">		return anyRewritten;</span>
	}

	@Override
	public BLSpanQuery optimize(IndexReader reader) throws IOException {
<span class="fc" id="L256">		super.optimize(reader);</span>
<span class="fc" id="L257">		boolean canDoNfaMatching = Searcher.fromIndexReader(reader).canDoNfaMatching();</span>
<span class="fc" id="L258">		boolean anyRewritten = false;</span>

		// Make a copy, because our methods rewrite things in-place.
<span class="fc" id="L261">		List&lt;BLSpanQuery&gt; cl = new ArrayList&lt;&gt;(clauses);</span>

		// Flatten nested sequences.
		// This doesn't change the query because the sequence operator is associative.
<span class="fc" id="L265">		anyRewritten |= flattenSequence(cl);</span>

		// Find matching tags and rewrite them to position filter (e.g. containing) to execute more
		// efficiently
<span class="fc" id="L269">		anyRewritten |= matchingTagsToPosFilter(cl);</span>

		// Try to combine adjacent clauses into more efficient ones.
		// We do this before rewrite (as well as after) specifically to find clauses that are slow
		// because
		// of regular expressions matching many terms (e.g. &quot;s.*&quot; or &quot;.*s&quot;) and match these using an
		// NFA instead.
		// By doing it before rewriting, we save the time to expand the regex to all its matching
		// terms, as well
		// as dealing with each of these (sometimes frequent) terms, which can be significant.
<span class="fc" id="L279">		anyRewritten |= combineAdjacentClauses(cl, reader, getField(), ClauseCombiner.all(canDoNfaMatching));</span>

		// Optimize each clause, and flatten again if necessary
<span class="fc" id="L282">		anyRewritten |= optimizeClauses(cl, reader);</span>

<span class="fc bfc" id="L284" title="All 2 branches covered.">		if (!anyRewritten) {</span>
			// Nothing rewritten. If this is a sequence of length one, just return the clause;
			// otherwise return this object unchanged.
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">			if (cl.size() == 1)</span>
<span class="nc" id="L288">				return cl.get(0);</span>
<span class="fc" id="L289">			return this;</span>
		}
<span class="fc" id="L291">		return new SpanQuerySequence(cl.toArray(new BLSpanQuery[0]));</span>
	}

	@Override
	public BLSpanQuery rewrite(IndexReader reader) throws IOException {
<span class="fc" id="L296">		boolean canDoNfaMatching = Searcher.fromIndexReader(reader).canDoNfaMatching();</span>
<span class="fc" id="L297">		boolean anyRewritten = false;</span>

		// Make a copy, because our methods rewrite things in-place.
<span class="fc" id="L300">		List&lt;BLSpanQuery&gt; cl = new ArrayList&lt;&gt;(clauses);</span>

		// Flatten nested sequences.
		// This doesn't change the query because the sequence operator is associative.
<span class="fc" id="L304">		anyRewritten |= flattenSequence(cl);</span>

		// Find matching tags and rewrite them to position filter (e.g. containing) to execute more
		// efficiently
<span class="fc" id="L308">		anyRewritten |= matchingTagsToPosFilter(cl);</span>

		// Try to combine adjacent clauses into more efficient ones.
		// We do this before rewrite (as well as after) specifically to find clauses that are slow
		// because
		// of regular expressions matching many terms (e.g. &quot;s.*&quot; or &quot;.*s&quot;) and match these using an
		// NFA instead.
		// By doing it before rewriting, we save the time to expand the regex to all its matching
		// terms, as well
		// as dealing with each of these (sometimes frequent) terms, which can be significant.
<span class="fc" id="L318">		anyRewritten |= combineAdjacentClauses(cl, reader, getField(), ClauseCombiner.all(canDoNfaMatching));</span>

		// Rewrite each clause, and flatten again if necessary
<span class="fc" id="L321">		anyRewritten |= rewriteClauses(cl, reader);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">		if (anyRewritten)</span>
<span class="fc" id="L323">			flattenSequence(cl);</span>

		// Again, try to combine adjacent clauses into more efficient ones. Rewriting clauses may
		// have
		// generated new opportunities for combining clauses.
<span class="fc" id="L328">		anyRewritten |= combineAdjacentClauses(cl, reader, getField(), ClauseCombiner.all(canDoNfaMatching));</span>

		// If any part of the sequence matches the empty sequence, we must
		// rewrite it to several alternatives combined with OR. Do so now.
<span class="fc" id="L332">		List&lt;List&lt;BLSpanQuery&gt;&gt; results = makeAlternatives(cl, reader);</span>
<span class="fc bfc" id="L333" title="All 4 branches covered.">		if (results.size() == 1 &amp;&amp; !anyRewritten) {</span>
			// Nothing rewritten. If this is a sequence of length one, just return the clause;
			// otherwise return this object unchanged.
<span class="fc" id="L336">			List&lt;BLSpanQuery&gt; seq = results.get(0);</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">			if (seq.size() == 1)</span>
<span class="fc" id="L338">				return seq.get(0);</span>
<span class="fc" id="L339">			return this;</span>
		}
<span class="fc" id="L341">		List&lt;BLSpanQuery&gt; orCl = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">		for (List&lt;BLSpanQuery&gt; seq: results) {</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">			if (seq.size() == 1)</span>
<span class="fc" id="L344">				orCl.add(seq.get(0));</span>
			else
<span class="fc" id="L346">				orCl.add(new SpanQuerySequence(seq.toArray(new BLSpanQuery[0])));</span>
<span class="fc" id="L347">		}</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">		if (orCl.size() == 1)</span>
<span class="fc" id="L349">			return orCl.get(0);</span>
<span class="fc" id="L350">		return new BLSpanOrQuery(orCl.toArray(new BLSpanQuery[0])).rewrite(reader);</span>
	}

	/**
	 * For possibly empty clauses, combine them with a neighbour into a binary-tree
	 * structure. This differs from the approach of makeAlternatives() which produces
	 * a OR of several longer sequences. That approach is probably more efficient with Lucene
	 * (because it allows more optimizations on the longer sequences produced), while this
	 * approach is probably more efficient for NFAs (because we don't have to follow many long
	 * paths in the NFA).
	 *
	 * @param cl clauses
	 * @param reader index reader
	 * @return alternatives tree
	 */
	@SuppressWarnings(&quot;unused&quot;)
	private static boolean makeAlternativesLocally(List&lt;BLSpanQuery&gt; cl, IndexReader reader) {
<span class="nc" id="L367">		boolean anyRewritten = false;</span>
		while (true) {
			// Find two clauses to combine to OR, preferring to combine one that matches
			// the empty sequence with one that does not.
<span class="nc" id="L371">			int bestIndex = -1;</span>
<span class="nc" id="L372">			boolean bestBothEmpty = true;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">			for (int i = 1; i &lt; cl.size(); i++) {</span>
<span class="nc" id="L374">				BLSpanQuery left = cl.get(i - 1);</span>
<span class="nc" id="L375">				BLSpanQuery right = cl.get(i);</span>
<span class="nc" id="L376">				boolean leftEmpty = left.matchesEmptySequence();</span>
<span class="nc" id="L377">				boolean rightEmpty = right.matchesEmptySequence();</span>
				// Does either clause matcht the empty sequence, and are these two
				// the best candidates to combine right now?
<span class="nc bnc" id="L380" title="All 12 branches missed.">				if ((leftEmpty || rightEmpty) &amp;&amp; bestBothEmpty || (!bestBothEmpty &amp;&amp; (!leftEmpty || !rightEmpty))) {</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">					bestBothEmpty = leftEmpty &amp;&amp; rightEmpty;</span>
<span class="nc" id="L382">					bestIndex = i;</span>
				}
			}
<span class="nc bnc" id="L385" title="All 2 branches missed.">			if (bestIndex &lt; 0)</span>
<span class="nc" id="L386">				return anyRewritten; // we're done</span>
			// Combine the clauses we found
<span class="nc" id="L388">			BLSpanQuery left = cl.get(bestIndex - 1);</span>
<span class="nc" id="L389">			BLSpanQuery right = cl.get(bestIndex);</span>
<span class="nc" id="L390">			boolean leftEmpty = left.matchesEmptySequence();</span>
<span class="nc" id="L391">			boolean rightEmpty = right.matchesEmptySequence();</span>
			BLSpanQuery combi;
<span class="nc" id="L393">			BLSpanQuery both = new SpanQuerySequence(left, right);</span>
<span class="nc bnc" id="L394" title="All 4 branches missed.">			if (leftEmpty &amp;&amp; rightEmpty) {</span>
				// 4 alternatives: neither, left only, right only, or both
<span class="nc" id="L396">				combi = new SpanQueryRepetition(new BLSpanOrQuery(left, right, both), 0, 1);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">			} else if (leftEmpty) {</span>
				// 2 alternatives: right only, or both
<span class="nc" id="L399">				combi = new BLSpanOrQuery(right, both);</span>
			} else {
				// 2 alternatives: left only, or both
<span class="nc" id="L402">				combi = new BLSpanOrQuery(left, both);</span>
			}
<span class="nc" id="L404">			cl.remove(bestIndex - 1);</span>
<span class="nc" id="L405">			cl.set(bestIndex - 1, combi);</span>
<span class="nc" id="L406">			anyRewritten = true;</span>
<span class="nc" id="L407">		}</span>
	}

	/**
	 * Given translated clauses, builds several alternatives and combines them with OR.
	 *
	 * This is necessary because of how sequence matching works: first the hits in each
	 * of the clauses are located, then we try to detect valid sequences by looking at these
	 * hits. But when a clause also matches the empty sequence, you may miss valid sequence
	 * matches because there's no hit in the clause to combine with the hits from other clauses.
	 *
	 * @param alternatives the alternative sequences we have built so far
	 * @param parts translation results for each of the clauses so far
	 * @param reader the index reader
	 * @return several alternatives combined with or
	 * @throws IOException
	 */
	List&lt;List&lt;BLSpanQuery&gt;&gt; makeAlternatives(List&lt;BLSpanQuery&gt; parts, IndexReader reader) throws IOException {
<span class="fc bfc" id="L425" title="All 2 branches covered.">		if (parts.size() == 1) {</span>
			// Last clause in the sequence; just return it
			// (noEmpty() version because we will build alternatives
			// in the caller if the input matched the empty sequence)
<span class="fc" id="L429">			return Arrays.asList(Arrays.asList(parts.get(0).noEmpty().rewrite(reader)));</span>
		}

		// Recursively determine the query for the &quot;tail&quot; of the list,
		// and whether it matches the empty sequence or not.
<span class="fc" id="L434">		List&lt;BLSpanQuery&gt; partsTail = parts.subList(1, parts.size());</span>
<span class="fc" id="L435">		boolean restMatchesEmpty = true;</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">		for (BLSpanQuery part: partsTail) {</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">			if (!part.matchesEmptySequence()) {</span>
<span class="fc" id="L438">				restMatchesEmpty = false;</span>
<span class="fc" id="L439">				break;</span>
			}
<span class="fc" id="L441">		}</span>
<span class="fc" id="L442">		List&lt;List&lt;BLSpanQuery&gt;&gt; altTail = makeAlternatives(partsTail, reader);</span>

		// Now, add the head part and check if that matches the empty sequence.
<span class="fc" id="L445">		return combine(parts.get(0), altTail, restMatchesEmpty, reader);</span>
	}

	private static List&lt;List&lt;BLSpanQuery&gt;&gt; combine(BLSpanQuery head, List&lt;List&lt;BLSpanQuery&gt;&gt; tailAlts, boolean tailMatchesEmpty,
			IndexReader reader) throws IOException {
<span class="fc" id="L450">		List&lt;List&lt;BLSpanQuery&gt;&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L451">		BLSpanQuery headNoEmpty = head.noEmpty().rewrite(reader);</span>
<span class="fc" id="L452">		boolean headMatchesEmpty = head.matchesEmptySequence();</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">		for (List&lt;BLSpanQuery&gt; tailAlt: tailAlts) {</span>
			// Add head in front of each tail alternative
<span class="fc" id="L455">			List&lt;BLSpanQuery&gt; n = new ArrayList&lt;&gt;(tailAlt);</span>
<span class="fc" id="L456">			n.add(0, headNoEmpty);</span>
<span class="fc" id="L457">			results.add(n);</span>

			// If head can be empty, also add original tail alternative
<span class="fc bfc" id="L460" title="All 2 branches covered.">			if (headMatchesEmpty)</span>
<span class="fc" id="L461">				results.add(tailAlt);</span>
<span class="fc" id="L462">		}</span>
		// If tail can be empty, also add the head separately
<span class="fc bfc" id="L464" title="All 2 branches covered.">		if (tailMatchesEmpty)</span>
<span class="fc" id="L465">			results.add(Arrays.asList(headNoEmpty));</span>
<span class="fc" id="L466">		return results;</span>
	}

	@Override
	public boolean matchesEmptySequence() {
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">		for (BLSpanQuery cl: clauses) {</span>
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">			if (!cl.matchesEmptySequence())</span>
<span class="fc" id="L473">				return false;</span>
<span class="nc" id="L474">		}</span>
<span class="nc" id="L475">		return true;</span>
	}

	@Override
	public BLSpanQuery noEmpty() {
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">		if (!matchesEmptySequence())</span>
<span class="fc" id="L481">			return this;</span>
<span class="nc" id="L482">		throw new RuntimeException(&quot;Sequence should have been rewritten!&quot;);</span>
	}

	@Override
	public BLSpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
<span class="fc" id="L487">		List&lt;BLSpanWeight&gt; weights = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">		for (BLSpanQuery clause: clauses) {</span>
<span class="fc" id="L489">			weights.add(clause.createWeight(searcher, needsScores));</span>
<span class="fc" id="L490">		}</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">		Map&lt;Term, TermContext&gt; contexts = needsScores ? getTermContexts(weights.toArray(new SpanWeight[0])) : null;</span>
<span class="fc" id="L492">		return new SpanWeightSequence(weights, searcher, contexts);</span>
	}

	class SpanWeightSequence extends BLSpanWeight {

		final List&lt;BLSpanWeight&gt; weights;

<span class="fc" id="L499">		public SpanWeightSequence(List&lt;BLSpanWeight&gt; weights, IndexSearcher searcher, Map&lt;Term, TermContext&gt; terms) throws IOException {</span>
<span class="fc" id="L500">			super(SpanQuerySequence.this, searcher, terms);</span>
<span class="fc" id="L501">			this.weights = weights;</span>
<span class="fc" id="L502">		}</span>

		@Override
		public void extractTerms(Set&lt;Term&gt; terms) {
<span class="fc bfc" id="L506" title="All 2 branches covered.">			for (SpanWeight weight: weights) {</span>
<span class="fc" id="L507">				weight.extractTerms(terms);</span>
<span class="fc" id="L508">			}</span>
<span class="fc" id="L509">		}</span>

		@Override
		public void extractTermContexts(Map&lt;Term, TermContext&gt; contexts) {
<span class="nc bnc" id="L513" title="All 2 branches missed.">			for (SpanWeight weight: weights) {</span>
<span class="nc" id="L514">				weight.extractTermContexts(contexts);</span>
<span class="nc" id="L515">			}</span>
<span class="nc" id="L516">		}</span>

		class CombiPart {
			BLSpans spans;

			boolean uniqueStart;

			boolean uniqueEnd;

			boolean startSorted;

			boolean endSorted;

			boolean sameLength;

<span class="fc" id="L531">			public CombiPart(BLSpanWeight weight, final LeafReaderContext context, Postings requiredPostings) throws IOException {</span>
<span class="fc" id="L532">				this.spans = weight.getSpans(context, requiredPostings);</span>
<span class="fc" id="L533">				BLSpanQuery q = (BLSpanQuery) weight.getQuery();</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">				if (q != null) {</span>
<span class="fc" id="L535">					this.uniqueStart = q.hitsHaveUniqueStart();</span>
<span class="fc" id="L536">					this.uniqueEnd = q.hitsHaveUniqueEnd();</span>
<span class="fc" id="L537">					this.startSorted = q.hitsStartPointSorted();</span>
<span class="fc" id="L538">					this.endSorted = q.hitsEndPointSorted();</span>
<span class="fc" id="L539">					this.sameLength = q.hitsAllSameLength();</span>
				}
<span class="fc" id="L541">			}</span>

			public CombiPart(BLSpans spans, boolean hitsHaveUniqueStart, boolean hitsHaveUniqueEnd, boolean hitsStartPointSorted,
<span class="fc" id="L544">					boolean hitsEndPointSorted, boolean hitsAllSameLength) {</span>
<span class="fc" id="L545">				super();</span>
<span class="fc" id="L546">				this.spans = spans;</span>
<span class="fc" id="L547">				this.uniqueStart = hitsHaveUniqueStart;</span>
<span class="fc" id="L548">				this.uniqueEnd = hitsHaveUniqueEnd;</span>
<span class="fc" id="L549">				this.startSorted = hitsStartPointSorted;</span>
<span class="fc" id="L550">				this.endSorted = hitsEndPointSorted;</span>
<span class="fc" id="L551">				this.sameLength = hitsAllSameLength;</span>
<span class="fc" id="L552">			}</span>

			@Override
			public String toString() {
<span class="nc" id="L556">				return spans.toString();</span>
			}

		}

		@Override
		public BLSpans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
<span class="fc" id="L563">			List&lt;CombiPart&gt; parts = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">			for (int i = 0; i &lt; weights.size(); i++) {</span>
<span class="fc" id="L565">				CombiPart part = new CombiPart(weights.get(i), context, requiredPostings);</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">				if (part.spans == null)</span>
<span class="fc" id="L567">					return null;</span>
<span class="fc" id="L568">				parts.add(part);</span>
			}

			// First, combine as many clauses as possible into SpansSequenceSimple,
			// which works for simple clauses and is the most efficient to execute.
			// OPT: it might be even better to favour combining low-frequency terms first,
			// as that minimizes useless skipping through non-matching docs.
<span class="fc bfc" id="L575" title="All 2 branches covered.">			for (int i = 1; i &lt; parts.size(); i++) {</span>
<span class="fc" id="L576">				CombiPart left = parts.get(i - 1);</span>
<span class="fc" id="L577">				CombiPart right = parts.get(i);</span>
<span class="fc" id="L578">				CombiPart newPart = null;</span>
<span class="pc bpc" id="L579" title="1 of 8 branches missed.">				if (left.uniqueEnd &amp;&amp; left.endSorted &amp;&amp; right.startSorted &amp;&amp; right.uniqueStart) {</span>
					// We can take a shortcut because of what we know about the Spans we're
					// combining.
<span class="fc" id="L582">					SpansSequenceSimple newSpans = new SpansSequenceSimple(left.spans, right.spans);</span>
<span class="pc bpc" id="L583" title="2 of 4 branches missed.">					newPart = new CombiPart(newSpans, left.uniqueStart, right.uniqueEnd, left.startSorted, right.sameLength,</span>
							left.sameLength &amp;&amp; right.sameLength);
<span class="fc" id="L585">					parts.remove(i - 1);</span>
<span class="fc" id="L586">					parts.set(i - 1, newPart);</span>
<span class="fc" id="L587">					i--;</span>
				}
			}

			// Now, combine the rest (if any) using the more expensive SpansSequenceRaw,
			// that takes more complex sequences into account.
<span class="fc bfc" id="L593" title="All 2 branches covered.">			while (parts.size() &gt; 1) {</span>
<span class="fc" id="L594">				CombiPart left = parts.get(0);</span>
<span class="fc" id="L595">				CombiPart right = parts.get(1);</span>

				// Note: the spans coming from SequenceSpansRaw may not be sorted by end point.
				// We keep track of this and sort them manually if necessary.
<span class="fc" id="L599">				CombiPart newPart = null;</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">				if (!left.endSorted)</span>
<span class="fc" id="L601">					left.spans = new PerDocumentSortedSpans(left.spans, PerDocumentSortedSpans.cmpEndPoint, false);</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">				if (!right.startSorted)</span>
<span class="fc" id="L603">					right.spans = new PerDocumentSortedSpans(right.spans, PerDocumentSortedSpans.cmpStartPoint, false);</span>
<span class="fc" id="L604">				BLSpans newSpans = new SpansSequenceRaw(left.spans, right.spans);</span>
<span class="pc bpc" id="L605" title="5 of 16 branches missed.">				newPart = new CombiPart(newSpans, left.uniqueStart &amp;&amp; left.uniqueEnd &amp;&amp; right.uniqueStart,</span>
						left.uniqueEnd &amp;&amp; right.uniqueStart &amp;&amp; right.uniqueEnd, left.startSorted, right.sameLength,
						left.sameLength &amp;&amp; right.sameLength);
<span class="fc" id="L608">				parts.remove(0);</span>
<span class="fc" id="L609">				parts.set(0, newPart);</span>
<span class="fc" id="L610">			}</span>

<span class="fc" id="L612">			return parts.get(0).spans;</span>
		}

	}

	@Override
	public String toString(String field) {
<span class="fc" id="L619">		return &quot;SEQ(&quot; + clausesToString(field) + &quot;)&quot;;</span>
	}

	@Override
	public boolean hitsAllSameLength() {
<span class="fc bfc" id="L624" title="All 2 branches covered.">		for (BLSpanQuery clause: clauses) {</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">			if (!clause.hitsAllSameLength())</span>
<span class="fc" id="L626">				return false;</span>
<span class="fc" id="L627">		}</span>
<span class="fc" id="L628">		return true;</span>
	}

	@Override
	public int hitsLengthMin() {
<span class="fc" id="L633">		int n = 0;</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">		for (BLSpanQuery clause: clauses) {</span>
<span class="fc" id="L635">			n += clause.hitsLengthMin();</span>
<span class="fc" id="L636">		}</span>
<span class="fc" id="L637">		return n;</span>
	}

	@Override
	public int hitsLengthMax() {
<span class="fc" id="L642">		int n = 0;</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">		for (BLSpanQuery clause: clauses) {</span>
<span class="fc" id="L644">			int max = clause.hitsLengthMax();</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">			if (max == Integer.MAX_VALUE)</span>
<span class="nc" id="L646">				return max; // infinite</span>
<span class="fc" id="L647">			n += max;</span>
<span class="fc" id="L648">		}</span>
<span class="fc" id="L649">		return n;</span>
	}

	@Override
	public boolean hitsEndPointSorted() {
<span class="nc bnc" id="L654" title="All 2 branches missed.">		for (int i = 0; i &lt; clauses.size() - 1; i++) {</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">			if (!clauses.get(i).hitsHaveUniqueEnd())</span>
<span class="nc" id="L656">				return false;</span>
		}
<span class="nc bnc" id="L658" title="All 2 branches missed.">		for (int i = 1; i &lt; clauses.size(); i++) {</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">			if (!clauses.get(i).hitsAllSameLength())</span>
<span class="nc" id="L660">				return false;</span>
		}
<span class="nc" id="L662">		return true;</span>
	}

	@Override
	public boolean hitsStartPointSorted() {
<span class="fc bfc" id="L667" title="All 2 branches covered.">		for (int i = 0; i &lt; clauses.size() - 1; i++) {</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">			if (!clauses.get(i).hitsAllSameLength())</span>
<span class="fc" id="L669">				return false;</span>
		}
<span class="fc" id="L671">		return true;</span>
	}

	@Override
	public boolean hitsHaveUniqueStart() {
<span class="fc bfc" id="L676" title="All 2 branches covered.">		for (BLSpanQuery clause: clauses) {</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">			if (!clause.hitsHaveUniqueStart())</span>
<span class="fc" id="L678">				return false;</span>
<span class="fc" id="L679">		}</span>
<span class="fc" id="L680">		return true;</span>
	}

	@Override
	public boolean hitsHaveUniqueEnd() {
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">		for (BLSpanQuery clause: clauses) {</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">			if (!clause.hitsHaveUniqueEnd())</span>
<span class="fc" id="L687">				return false;</span>
<span class="fc" id="L688">		}</span>
<span class="nc" id="L689">		return true;</span>

	}

	@Override
	public boolean hitsAreUnique() {
<span class="pc bpc" id="L695" title="1 of 4 branches missed.">		return hitsHaveUniqueStart() || hitsHaveUniqueEnd();</span>
	}

	@Override
	public Nfa getNfa(ForwardIndexAccessor fiAccessor, int direction) {
<span class="fc" id="L700">		Nfa frag = null;</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">		int start = direction == 1 ? 0 : clauses.size() - 1;</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">		int end = direction == 1 ? clauses.size() : -1;</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">		for (int i = start; i != end; i += direction) {</span>
<span class="fc" id="L704">			BLSpanQuery clause = clauses.get(i);</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">			if (frag == null)</span>
<span class="fc" id="L706">				frag = clause.getNfa(fiAccessor, direction);</span>
			else
<span class="fc" id="L708">				frag.append(clause.getNfa(fiAccessor, direction));</span>
		}
<span class="fc" id="L710">		return frag;</span>
	}

	@Override
	public boolean canMakeNfa() {
<span class="fc bfc" id="L715" title="All 2 branches covered.">		for (BLSpanQuery clause: clauses) {</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">			if (!clause.canMakeNfa())</span>
<span class="nc" id="L717">				return false;</span>
<span class="fc" id="L718">		}</span>
<span class="fc" id="L719">		return true;</span>
	}

	@Override
	public long reverseMatchingCost(IndexReader reader) {
<span class="fc" id="L724">		long cost = Integer.MAX_VALUE;</span>
<span class="fc" id="L725">		double factor = 1.0;</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">		for (BLSpanQuery clause: clauses) {</span>
<span class="fc" id="L727">			cost = Math.min(cost, clause.reverseMatchingCost(reader));</span>
<span class="fc" id="L728">			factor *= 1.2; // 20% overhead per clause (?)</span>
<span class="fc" id="L729">		}</span>
<span class="fc" id="L730">		return (long) (cost * factor);</span>
	}

	@Override
	public int forwardMatchingCost() {
<span class="fc" id="L735">		int cost = 0;</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">		for (BLSpanQuery clause: clauses) {</span>
<span class="fc" id="L737">			cost += clause.forwardMatchingCost();</span>
<span class="fc" id="L738">		}</span>
<span class="fc" id="L739">		return cost;</span>
	}

	@Override
	public boolean canInternalizeNeighbour(BLSpanQuery clause, boolean onTheRight) {
		// NOTE: we (explicitly) return false even though sequences can always
		// internalize neighbours, because sequences are explicitly flattened
		// while rewriting, so this shouldn't be necessary.
		// The internalize() method is used by other classes' internalize() methods, though.
<span class="fc" id="L748">		return false;</span>
	}

	/**
	 * Create a new sequence with a clause added to it.
	 *
	 * @param clause clause to add
	 * @param addToRight if true, add to the right; if false, to the left
	 * @return new sequence with clause added
	 */
	@Override
	public SpanQuerySequence internalizeNeighbour(BLSpanQuery clause, boolean addToRight) {
<span class="fc" id="L760">		List&lt;BLSpanQuery&gt; cl = new ArrayList&lt;&gt;(clauses);</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">		if (addToRight)</span>
<span class="fc" id="L762">			cl.add(clause);</span>
		else
<span class="fc" id="L764">			cl.add(0, clause);</span>
<span class="fc" id="L765">		return new SpanQuerySequence(cl);</span>
	}

	/**
	 * Either add a clause to an existing SpanQuerySequence, or create a new
	 * SpanQuerySequence with the two specified clauses.
	 *
	 * @param whereToInternalize existing sequence, or existing non-sequence clause
	 * @param clauseToInternalize clause to add to sequence or add to existing clause
	 * @param addToRight if true, add new clause to the right of existing; if false, to the left
	 * @return the expanded or newly created sequence
	 */
	public static SpanQuerySequence sequenceInternalize(BLSpanQuery whereToInternalize, BLSpanQuery clauseToInternalize,
			boolean addToRight) {
		SpanQuerySequence seq;
<span class="fc bfc" id="L780" title="All 2 branches covered.">		if (whereToInternalize instanceof SpanQuerySequence) {</span>
<span class="fc" id="L781">			seq = (SpanQuerySequence) whereToInternalize;</span>
<span class="fc" id="L782">			seq = seq.internalizeNeighbour(clauseToInternalize, addToRight);</span>
		} else {
<span class="fc bfc" id="L784" title="All 2 branches covered.">			if (addToRight)</span>
<span class="fc" id="L785">				seq = new SpanQuerySequence(whereToInternalize, clauseToInternalize);</span>
			else
<span class="fc" id="L787">				seq = new SpanQuerySequence(clauseToInternalize, whereToInternalize);</span>
		}
<span class="fc" id="L789">		return seq;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>