<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BLSpanTermQuery.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.search.lucene</a> &gt; <span class="el_source">BLSpanTermQuery.java</span></div><h1>BLSpanTermQuery.java</h1><pre class="source lang-java linenums">package nl.inl.blacklab.search.lucene;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.Set;

import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.IndexReaderContext;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.index.Term;
import org.apache.lucene.index.TermContext;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.spans.SpanTermQuery;
import org.apache.lucene.search.spans.SpanTermQuery.SpanTermWeight;
import org.apache.lucene.search.spans.Spans;

import nl.inl.blacklab.index.complex.ComplexFieldUtil;
import nl.inl.blacklab.search.fimatch.ForwardIndexAccessor;
import nl.inl.blacklab.search.fimatch.Nfa;
import nl.inl.blacklab.search.fimatch.NfaState;

/**
 * BL-specific subclass of SpanTermQuery that changes what getField() returns
 * (the complex field name instead of the full Lucene field name) in order to be
 * able to combine queries in different Lucene fields using AND and OR. Also makes
 * sure the SpanWeight returned by createWeight() produces a BLSpans, not a regular
 * Spans.
 */
public class BLSpanTermQuery extends BLSpanQuery {

	public static final int FIXED_FORWARD_MATCHING_COST = 2;

	public static BLSpanTermQuery from(SpanTermQuery q) {
<span class="fc" id="L53">		return new BLSpanTermQuery(q);</span>
	}

	SpanTermQuery query;

	private TermContext termContext;

	/** Construct a SpanTermQuery matching the named term's spans.
	 *
	 * @param term term to search
	 */
<span class="fc" id="L64">	public BLSpanTermQuery(Term term) {</span>
<span class="fc" id="L65">		query = new SpanTermQuery(term);</span>
<span class="fc" id="L66">		termContext = null;</span>
<span class="fc" id="L67">	}</span>

	BLSpanTermQuery(SpanTermQuery termQuery) {
<span class="fc" id="L70">		this(termQuery.getTerm());</span>
<span class="fc" id="L71">	}</span>

	/**
	 * Expert: Construct a SpanTermQuery matching the named term's spans, using
	 * the provided TermContext.
	 *
	 * @param term term to search
	 * @param context TermContext to use to search the term
	 */
<span class="nc" id="L80">	public BLSpanTermQuery(Term term, TermContext context) {</span>
<span class="nc" id="L81">		query = new SpanTermQuery(term, context);</span>
<span class="nc" id="L82">		termContext = context;</span>
<span class="nc" id="L83">	}</span>

	@Override
	public String getRealField() {
<span class="fc" id="L87">		return query.getTerm().field();</span>
	}

	public Term getTerm() {
<span class="nc" id="L91">		return query.getTerm();</span>
	}

	@Override
	public BLSpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
		final TermContext context;
<span class="fc" id="L97">		final IndexReaderContext topContext = searcher.getTopReaderContext();</span>
<span class="pc bpc" id="L98" title="3 of 4 branches missed.">		if (termContext == null || termContext.topReaderContext != topContext) {</span>
<span class="fc" id="L99">			context = TermContext.build(topContext, query.getTerm());</span>
		} else {
<span class="nc" id="L101">			context = termContext;</span>
		}
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">		Map&lt;Term, TermContext&gt; contexts = needsScores ? Collections.singletonMap(query.getTerm(), context) : null;</span>
<span class="fc" id="L104">		final SpanTermWeight weight = query.new SpanTermWeight(context, searcher, contexts);</span>
<span class="fc" id="L105">		return new BLSpanWeight(this, searcher, contexts) {</span>
			@Override
			public void extractTermContexts(Map&lt;Term, TermContext&gt; contexts) {
<span class="nc" id="L108">				weight.extractTermContexts(contexts);</span>
<span class="nc" id="L109">			}</span>

			@Override
			public BLSpans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
<span class="fc" id="L113">				Spans spans = weight.getSpans(ctx, requiredPostings);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">				return spans == null ? null : new BLSpansWrapper(spans);</span>
			}

			@Override
			public void extractTerms(Set&lt;Term&gt; terms) {
<span class="fc" id="L119">				weight.extractTerms(terms);</span>
<span class="fc" id="L120">			}</span>
		};
	}

	@Override
	public String toString(String field) {
<span class="fc" id="L126">		return &quot;TERM(&quot; + query + &quot;)&quot;;</span>
	}

	@Override
	public int hashCode() {
<span class="nc" id="L131">		return query.hashCode() ^ 0xB1ACC1AB;</span>
	}

	@Override
	public boolean equals(Object obj) {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">		if (this == obj)</span>
<span class="nc" id="L137">			return true;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">		if (obj instanceof BLSpanTermQuery) {</span>
<span class="fc" id="L139">			BLSpanTermQuery other = (BLSpanTermQuery) obj;</span>
<span class="fc" id="L140">			return query.equals(other.query);</span>
		}
<span class="fc" id="L142">		return false;</span>
	}

	@Override
	public boolean hitsAllSameLength() {
<span class="fc" id="L147">		return true;</span>
	}

	@Override
	public int hitsLengthMin() {
<span class="fc" id="L152">		return 1;</span>
	}

	@Override
	public int hitsLengthMax() {
<span class="fc" id="L157">		return 1;</span>
	}

	@Override
	public boolean hitsEndPointSorted() {
<span class="fc" id="L162">		return true;</span>
	}

	@Override
	public boolean hitsStartPointSorted() {
<span class="fc" id="L167">		return true;</span>
	}

	@Override
	public boolean hitsHaveUniqueStart() {
<span class="fc" id="L172">		return true;</span>
	}

	@Override
	public boolean hitsHaveUniqueEnd() {
<span class="fc" id="L177">		return true;</span>
	}

	@Override
	public boolean hitsAreUnique() {
<span class="fc" id="L182">		return true;</span>
	}

	@Override
	public Nfa getNfa(ForwardIndexAccessor fiAccessor, int direction) {
<span class="fc" id="L187">		Term term = query.getTerm();</span>
<span class="fc" id="L188">		String propertyValue = term.text();</span>
<span class="fc" id="L189">		NfaState state = NfaState.token(term.field(), propertyValue, null);</span>
<span class="fc" id="L190">		return new Nfa(state, Arrays.asList(state));</span>
	}

	@Override
	public boolean canMakeNfa() {
		// Subproperties aren't stored in forward index, so we can't match them using NFAs
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">		if (query.getTerm().text().contains(ComplexFieldUtil.SUBPROPERTY_SEPARATOR))</span>
<span class="nc" id="L197">			return false;</span>

<span class="fc" id="L199">		return true;</span>
	}

	@Override
	public long reverseMatchingCost(IndexReader reader) {
		try {
<span class="fc" id="L205">			return reader.totalTermFreq(query.getTerm());</span>
<span class="nc" id="L206">		} catch (IOException e) {</span>
<span class="nc" id="L207">			throw new RuntimeException(e);</span>
		}
	}

	@Override
	public int forwardMatchingCost() {
<span class="fc" id="L213">		return FIXED_FORWARD_MATCHING_COST;</span>
	}

	@Override
	public BLSpanQuery rewrite(IndexReader reader) throws IOException {
<span class="fc" id="L218">		return this;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>