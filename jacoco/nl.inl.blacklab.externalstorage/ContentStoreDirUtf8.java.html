<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ContentStoreDirUtf8.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.externalstorage</a> &gt; <span class="el_source">ContentStoreDirUtf8.java</span></div><h1>ContentStoreDirUtf8.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2010, 2012 Institute for Dutch Lexicology
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package nl.inl.blacklab.externalstorage;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileChannel.MapMode;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.collections.impl.factory.Maps;

import nl.inl.util.ExUtil;

/**
 * Store string content by id in a directory of compound files with a TOC file. Quickly retrieve
 * (parts of) the string content.
 *
 * This implementation stores the strings in UTF-8 encoding to save disk space. To guarantee
 * reasonably fast random access times, we keep track of &quot;block offsets&quot;, which are byte offsets to
 * the start of (fixed char size) blocks. Block size in bytes can be slightly larger than char size
 * because some UTF-8 characters take up more than 1 byte. If the block size is 1000 chars, block
 * offsets might be [0, 1011, 2015, 3020].
 */
public class ContentStoreDirUtf8 extends ContentStoreDirAbstract {
	/** Table of contents entry */
	static class TocEntry {
		/** id of the string */
		public int id;

		/** id of the file the string was stored in */
		public int fileId;

		/** byte offset into the file of the string */
		public int entryOffsetBytes;

		/** length of the string in bytes */
		public int entryLengthBytes;

		/** length of the string in characters */
		public int entryLengthCharacters;

		/** fixed block size in characters (note that byte size differs per block) */
		public int blockSizeCharacters;

		/** relative block start offsets in bytes */
		public int[] blockOffsetBytes;

		/** was this entry deleted? (can be removed in next compacting run) */
		public boolean deleted;

		public TocEntry(int id, int fileId, int offset, int length, int charLength, int blockSize,
				boolean deleted, int[] blockOffset) {
<span class="fc" id="L78">			super();</span>
<span class="fc" id="L79">			this.id = id;</span>
<span class="fc" id="L80">			this.fileId = fileId;</span>
<span class="fc" id="L81">			entryOffsetBytes = offset;</span>
<span class="fc" id="L82">			entryLengthBytes = length;</span>
<span class="fc" id="L83">			entryLengthCharacters = charLength;</span>
<span class="fc" id="L84">			blockSizeCharacters = blockSize;</span>
<span class="fc" id="L85">			this.deleted = deleted;</span>
<span class="fc" id="L86">			blockOffsetBytes = blockOffset;</span>
<span class="fc" id="L87">		}</span>

		/**
		 * Store TOC entry in the TOC file
		 *
		 * @param buf
		 *            where to serialize to
		 * @throws IOException
		 *             on error
		 */
		public void serialize(ByteBuffer buf) throws IOException {
<span class="fc" id="L98">			buf.putInt(id);</span>
<span class="fc" id="L99">			buf.putInt(fileId);</span>
<span class="fc" id="L100">			buf.putInt(entryOffsetBytes);</span>
<span class="fc" id="L101">			buf.putInt(entryLengthBytes);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">			buf.putInt(deleted ? -1 : entryLengthCharacters);</span>
<span class="fc" id="L103">			buf.putInt(blockSizeCharacters);</span>
<span class="fc" id="L104">			buf.putInt(blockOffsetBytes.length);</span>
<span class="fc" id="L105">			IntBuffer ib = buf.asIntBuffer();</span>
<span class="fc" id="L106">			ib.put(blockOffsetBytes);</span>
<span class="fc" id="L107">			buf.position(buf.position() + blockOffsetBytes.length * Integer.SIZE / Byte.SIZE);</span>
<span class="fc" id="L108">		}</span>

		/**
		 * Read TOC entry from the TOC file
		 *
		 * @param buf
		 *            the buffer to read from
		 * @return new TocEntry
		 * @throws IOException
		 *             on error
		 */
		public static TocEntry deserialize(ByteBuffer buf) throws IOException {
<span class="fc" id="L120">			int id = buf.getInt();</span>
<span class="fc" id="L121">			int fileId = buf.getInt();</span>
<span class="fc" id="L122">			int offset = buf.getInt();</span>
<span class="fc" id="L123">			int length = buf.getInt();</span>
<span class="fc" id="L124">			int charLength = buf.getInt();</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">			boolean deleted = charLength &lt; 0;</span>
<span class="fc" id="L126">			int blockSize = buf.getInt();</span>
<span class="fc" id="L127">			int nBlocks = buf.getInt();</span>
<span class="fc" id="L128">			int[] blockOffsetBytes = new int[nBlocks];</span>
<span class="fc" id="L129">			IntBuffer ib = buf.asIntBuffer();</span>
<span class="fc" id="L130">			ib.get(blockOffsetBytes);</span>
<span class="fc" id="L131">			buf.position(buf.position() + blockOffsetBytes.length * Integer.SIZE / Byte.SIZE);</span>
<span class="fc" id="L132">			return new TocEntry(id, fileId, offset, length, charLength, blockSize, deleted,</span>
					blockOffsetBytes);
		}

		/**
		 * Get the offset of the first byte of the specified block.
		 *
		 * @param blockNumber
		 *            which block?
		 * @return byte offset of the first byte in the file
		 */
		public long getBlockStartOffset(int blockNumber) {
<span class="fc" id="L144">			return entryOffsetBytes + blockOffsetBytes[blockNumber];</span>
		}

		/**
		 * Get the offset of the first byte beyond the specified block.
		 *
		 * @param blockNumber
		 *            which block?
		 * @return byte offset of the first byte beyond the block in the file
		 */
		public long getBlockEndOffset(int blockNumber) {
<span class="fc bfc" id="L155" title="All 2 branches covered.">			if (blockNumber &lt; blockOffsetBytes.length - 1)</span>
<span class="fc" id="L156">				return entryOffsetBytes + blockOffsetBytes[blockNumber + 1];</span>
<span class="fc" id="L157">			return entryOffsetBytes + entryLengthBytes;</span>
		}

		/**
		 * Size of this entry serialized
		 *
		 * @return the size in bytes
		 */
		public int sizeBytes() {
<span class="fc" id="L166">			return 28 + blockOffsetBytes.length * 4;</span>
		}
	}

	/**
	 * The TOC entries
	 */
	private Map&lt;Integer, TocEntry&gt; toc;

	/**
	 * The table of contents (TOC) file
	 */
	private File tocFile;

	/**
	 * Memory mapping of the TOC file
	 */
	private ByteBuffer tocFileBuffer;

	/**
	 * The TOC file channel.
	 */
	private FileChannel tocFileChannel;

	/**
	 * The TOC random access file
	 */
	private RandomAccessFile tocRaf;

	/**
	 * How much to reserve at the end of mapped file for writing
	 */
<span class="fc" id="L198">	private int writeMapReserve = 1000000; // 1M</span>

	/**
	 * Set the size of the write reserve (the amount of
	 * space allocated at the end of the file). Larger reserves
	 * means less re-mapping.
	 *
	 * The default is 1M bytes.
	 *
	 * @param writeMapReserve size of the reserve in bytes.
	 */
	public void setWriteMapReserve(int writeMapReserve) {
<span class="fc" id="L210">		this.writeMapReserve = writeMapReserve;</span>
<span class="fc" id="L211">	}</span>

	/**
	 * Preferred size of data files. Note that the data files consist only of whole documents, so
	 * this size may be exceeded.
	 */
<span class="fc" id="L217">	private long dataFileSizeHint = 100000000; // 100M</span>

	/**
	 * Next content ID.
	 */
<span class="fc" id="L222">	private int nextId = 1;</span>

	/**
	 * File ID of the current file we're writing to.
	 */
<span class="fc" id="L227">	private int currentFileId = 1;</span>

	/**
	 * Length of the file we're writing to.
	 */
<span class="fc" id="L232">	private int currentFileLength = 0;</span>

	/**
	 * When writing, this is the outputstream to the current store file. We save it to save on
	 * open/close costs.
	 */
<span class="fc" id="L238">	OutputStream currentStoreFileStream = null;</span>

	/**
	 * If we're writing content in chunks, this keeps track of how many chars were already written.
	 * Used by store() to calculate the total content length in chars.
	 */
<span class="fc" id="L244">	private int charsFromEntryWritten = 0;</span>

	/**
	 * If we're writing content in chunks, this keeps track of how many bytes were already written.
	 * Used by store() to calculate the total content length in bytes.
	 */
<span class="fc" id="L250">	private int bytesWritten = 0;</span>

	private List&lt;Integer&gt; blockOffsetWhileStoring;

	/**
	 * What block size to use when adding a new document to the content store. Contributing factors
	 * for choosing block size:
	 * - larger blocks improve compression ratio
	 * - larger blocks decrease number of blocks you have to read
	 * - smaller blocks decrease the decompression time
	 * - smaller blocks increase the chance that we only have to read one disk block for a single concordance
	 *   (disk blocks are generally 2 or 4K)
	 * - consider OS I/O caching and memory mapping. Then it becomes the difference between reading
	 *   a few bytes from memory and reading a few kilobytes and decompressing them. Right now,
	 *   making concordances is often CPU-bound (because of decompression?)
	 */
<span class="fc" id="L266">	protected int newEntryBlockSizeCharacters = 4000;</span>

<span class="fc" id="L268">	private boolean tocModified = false;</span>

<span class="fc" id="L270">	StringBuilder currentBlockContents = new StringBuilder(newEntryBlockSizeCharacters);</span>

	/**
	 * Set the desired block size for new entries
	 *
	 * @param size
	 *            the fixed block size in characters
	 */
	public void setBlockSizeCharacters(int size) {
<span class="fc" id="L279">		newEntryBlockSizeCharacters = size;</span>
<span class="fc" id="L280">	}</span>

	/**
	 * @param dir content store dir
	 */
	public ContentStoreDirUtf8(File dir) {
<span class="fc" id="L286">		this(dir, false);</span>
<span class="fc" id="L287">	}</span>

	/**
	 * @param dir content store dir
	 * @param create if true, create a new content store
	 */
<span class="fc" id="L293">	public ContentStoreDirUtf8(File dir, boolean create) {</span>
<span class="fc" id="L294">		this.dir = dir;</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">		if (!dir.exists())</span>
<span class="nc" id="L296">			dir.mkdir();</span>
<span class="fc" id="L297">		tocFile = new File(dir, &quot;toc.dat&quot;);</span>
<span class="pc bpc" id="L298" title="3 of 4 branches missed.">		if (create &amp;&amp; tocFile.exists()) {</span>
			// Delete the ContentStore files
<span class="nc" id="L300">			tocFile.delete();</span>
<span class="nc" id="L301">			new File(dir, &quot;version.dat&quot;).delete();</span>
<span class="nc" id="L302">			File[] dataFiles = dir.listFiles(new FilenameFilter() {</span>
				@Override
				public boolean accept(File dir_, String name) {
<span class="nc" id="L305">					return name.matches(&quot;data\\d+.dat&quot;);</span>
				}
			});
<span class="nc bnc" id="L308" title="All 2 branches missed.">			for (File f : dataFiles) {</span>
<span class="nc" id="L309">				f.delete();</span>
			}
		}
<span class="fc" id="L312">		toc = Maps.mutable.empty();</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">		if (tocFile.exists())</span>
<span class="fc" id="L314">			readToc();</span>
<span class="fc" id="L315">		tocModified = false;</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">		if (create) {</span>
<span class="nc" id="L317">			clear();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">			if (tocFile.exists())</span>
<span class="nc" id="L319">				tocFile.delete();</span>
<span class="nc" id="L320">			setStoreType();</span>
		}
<span class="fc" id="L322">		blockOffsetWhileStoring = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L323">	}</span>

	/**
	 * Writes an empty file that indicates the type of store. Subclasses should override this to
	 * customize the type string.
	 */
	protected void setStoreType() {
<span class="nc" id="L330">		setStoreType(&quot;utf8&quot;, &quot;1&quot;);</span>
<span class="nc" id="L331">	}</span>

	/**
	 * Delete all content in the document store
	 */
	@Override
	public void clear() {
<span class="nc" id="L338">		closeCurrentStoreFile();</span>

		// delete all data files and empty TOC
<span class="nc bnc" id="L341" title="All 2 branches missed.">		for (Map.Entry&lt;Integer, TocEntry&gt; me : toc.entrySet()) {</span>
<span class="nc" id="L342">			TocEntry e = me.getValue();</span>
<span class="nc" id="L343">			File f = getContentFile(e.fileId);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">			if (f.exists())</span>
<span class="nc" id="L345">				f.delete();</span>
<span class="nc" id="L346">		}</span>
<span class="nc" id="L347">		toc.clear();</span>
<span class="nc" id="L348">		tocModified = true;</span>
<span class="nc" id="L349">		currentFileId = 1;</span>
<span class="nc" id="L350">		currentFileLength = 0;</span>
<span class="nc" id="L351">		nextId = 1;</span>
<span class="nc" id="L352">	}</span>

	private void mapToc(boolean writeable) throws IOException {
<span class="fc bfc" id="L355" title="All 2 branches covered.">		tocRaf = new RandomAccessFile(tocFile, writeable ? &quot;rw&quot; : &quot;r&quot;);</span>
<span class="fc" id="L356">		long fl = tocFile.length();</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">		if (writeable) {</span>
<span class="fc" id="L358">			fl += writeMapReserve;</span>
		} // leave 1M room at the end
<span class="fc" id="L360">		tocFileChannel = tocRaf.getChannel();</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">		tocFileBuffer = tocFileChannel.map(writeable ? MapMode.READ_WRITE : MapMode.READ_ONLY, 0,</span>
				fl);
<span class="fc" id="L363">	}</span>

	private void closeMappedToc() {
<span class="fc bfc" id="L366" title="All 2 branches covered.">		if (tocFileBuffer == null)</span>
<span class="fc" id="L367">			return; // not mapped</span>
		try {
<span class="fc" id="L369">			tocFileChannel.close();</span>
<span class="fc" id="L370">			tocFileChannel = null;</span>
<span class="fc" id="L371">			tocRaf.close();</span>
<span class="fc" id="L372">			tocRaf = null;</span>

<span class="fc" id="L374">			tocFileBuffer = null;</span>

<span class="nc" id="L376">		} catch (IOException e) {</span>
<span class="nc" id="L377">			throw new RuntimeException(e);</span>
<span class="fc" id="L378">		}</span>
<span class="fc" id="L379">	}</span>

	/**
	 * Read the table of contents from the file
	 */
	private void readToc() {
<span class="fc" id="L385">		toc.clear();</span>
		try {
<span class="fc" id="L387">			mapToc(false);</span>
			try {
<span class="fc" id="L389">				tocFileBuffer.position(0);</span>
<span class="fc" id="L390">				int n = tocFileBuffer.getInt();</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">				for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L392">					TocEntry e = TocEntry.deserialize(tocFileBuffer);</span>
<span class="fc" id="L393">					toc.put(e.id, e);</span>

					// Keep track of the current content file (file with highest ID)
<span class="fc bfc" id="L396" title="All 2 branches covered.">					if (e.fileId &gt; currentFileId) {</span>
<span class="fc" id="L397">						currentFileId = e.fileId;</span>
<span class="fc" id="L398">						currentFileLength = 0;</span>
					}

					// Keep track of the length of the current content file
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">					if (e.fileId == currentFileId) {</span>
<span class="fc" id="L403">						int endOfEntry = e.entryOffsetBytes + e.entryLengthBytes;</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">						if (endOfEntry &gt; currentFileLength)</span>
<span class="fc" id="L405">							currentFileLength = endOfEntry;</span>
					}

					// Keep track of what the next ID should be
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">					if (e.id + 1 &gt; nextId)</span>
<span class="fc" id="L410">						nextId = e.id + 1;</span>
				}
			} finally {
<span class="pc" id="L413">				closeMappedToc();</span>
<span class="pc" id="L414">			}</span>
<span class="nc" id="L415">		} catch (Exception e) {</span>
<span class="nc" id="L416">			throw ExUtil.wrapRuntimeException(e);</span>
<span class="fc" id="L417">		}</span>
<span class="fc" id="L418">	}</span>

	private void writeToc() {
		try {
<span class="fc" id="L422">			mapToc(true);</span>
<span class="fc" id="L423">			tocFileBuffer.putInt(toc.size());</span>
			try {
<span class="fc bfc" id="L425" title="All 2 branches covered.">				for (TocEntry e : toc.values()) {</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">					if (tocFileBuffer.remaining() &lt; e.sizeBytes()) {</span>
						// Close and re-open with extra writing room
<span class="fc" id="L428">						int p = tocFileBuffer.position();</span>
<span class="fc" id="L429">						closeMappedToc();</span>
<span class="fc" id="L430">						mapToc(true);</span>
<span class="fc" id="L431">						tocFileBuffer.position(p);</span>
					}
<span class="fc" id="L433">					e.serialize(tocFileBuffer);</span>
<span class="fc" id="L434">				}</span>
			} finally {
<span class="pc" id="L436">				closeMappedToc();</span>
<span class="pc" id="L437">			}</span>
<span class="nc" id="L438">		} catch (Exception e) {</span>
<span class="nc" id="L439">			throw ExUtil.wrapRuntimeException(e);</span>
<span class="fc" id="L440">		}</span>
<span class="fc" id="L441">		tocModified = false;</span>
<span class="fc" id="L442">	}</span>

	/**
	 * Close the content store. Writes the table of contents (if modified)
	 */
	@Override
	public void close() {
<span class="fc" id="L449">		closeCurrentStoreFile();</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">		if (tocModified) {</span>
<span class="fc" id="L451">			writeToc();</span>
		}
<span class="fc" id="L453">		closeMappedToc();</span>
<span class="fc" id="L454">	}</span>

	/**
	 * Indicate preferred maximum size of data files (defaults to 10M)
	 *
	 * @param dataFileSizeHint
	 */
	public void setDataFileSizeHint(long dataFileSizeHint) {
<span class="fc" id="L462">		this.dataFileSizeHint = dataFileSizeHint;</span>
<span class="fc" id="L463">	}</span>

	/**
	 * Add a piece of content to the current block
	 *
	 * @param contentPart
	 *            content to add
	 */
	public void addToBlock(String contentPart) {
<span class="fc" id="L472">		currentBlockContents.append(contentPart);</span>
<span class="fc" id="L473">	}</span>

	/**
	 * Encode and write the block we've compiled so far and reset for next block
	 * @param os where to write to block to
	 */
	public void writeCurrentBlock(OutputStream os) {
		try {
			// Encode and write block

			// OPT: we could try memory-mapping the current content store file (not sure if
			// you can grow a file in size while memory-mapped? maybe just put it at a fixed
			// size?) for additional speed.

<span class="fc" id="L487">			String blockContent = currentBlockContents.toString();</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">			if (blockContent.length() == 0)</span>
<span class="nc" id="L489">				throw new RuntimeException(&quot;ERROR, tried to write an empty block&quot;);</span>
<span class="fc" id="L490">			byte[] buf = encodeBlock(blockContent);</span>
<span class="fc" id="L491">			os.write(buf);</span>
<span class="fc" id="L492">			bytesWritten += buf.length;</span>
<span class="fc" id="L493">			currentBlockContents = new StringBuilder(newEntryBlockSizeCharacters);</span>
<span class="nc" id="L494">		} catch (IOException e) {</span>
<span class="nc" id="L495">			throw new RuntimeException(e);</span>
<span class="fc" id="L496">		}</span>
<span class="fc" id="L497">	}</span>

	/**
	 * Store part of a piece of large content. This may be called several times to store chunks of
	 * content, but MUST be *finished* by calling the &quot;normal&quot; store() method. You may call store()
	 * with the empty string if you wish.
	 *
	 * @param content
	 *            the content to store
	 */
	@Override
	public synchronized void storePart(String content) {
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">		if (content.length() == 0)</span>
<span class="nc" id="L510">			return;</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">		if (blockOffsetWhileStoring.size() == 0)</span>
<span class="fc" id="L512">			blockOffsetWhileStoring.add(0); // first offset is always 0</span>

		// Calculate what charsFromEntryWritten will be after storing this part
		// (used to determine if we will cross a block boundary)
<span class="fc" id="L516">		int offsetAfterThisPart = charsFromEntryWritten + content.length();</span>

		// See if we're about to cross any block boundaries; if so, write the content up to the
		// first block boundary, save the new block offset, and repeat.
<span class="fc" id="L520">		int thisPartCharsWritten = 0, thisPartCharsLeftToWrite = content.length();</span>

<span class="fc" id="L522">		OutputStream os = openCurrentStoreFile();</span>
		while (true) {
			// Will we cross a(nother) block boundary writing this part of the content?
<span class="fc" id="L525">			int nextBlockBoundary = blockOffsetWhileStoring.size() * newEntryBlockSizeCharacters;</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">			boolean willWeCrossBlockBoundary = (offsetAfterThisPart &gt; nextBlockBoundary);</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">			if (!willWeCrossBlockBoundary) {</span>
				// No; break out of this loop and write the last bit of content.
<span class="fc" id="L529">				break;</span>
			}

			// How many characters till the block boundary?
<span class="fc" id="L533">			int charsRemainingInBlock = nextBlockBoundary - charsFromEntryWritten;</span>

			// Are we at the block boundary already?
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">			if (charsRemainingInBlock &gt; 0) {</span>
				// No, not at the boundary yet; add last piece to block
				// and update bookkeeping variables
<span class="fc" id="L539">				addToBlock(content.substring(thisPartCharsWritten, thisPartCharsWritten</span>
						+ charsRemainingInBlock));
<span class="fc" id="L541">				charsFromEntryWritten += charsRemainingInBlock;</span>

<span class="fc" id="L543">				thisPartCharsWritten += charsRemainingInBlock;</span>
<span class="fc" id="L544">				thisPartCharsLeftToWrite -= charsRemainingInBlock;</span>
			}

			// We are now at a block boundary. Write the block and
			// store next block offset.
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">			if (currentBlockContents.length() &gt; 0) {</span>
<span class="fc" id="L550">				writeCurrentBlock(os);</span>
<span class="fc" id="L551">				blockOffsetWhileStoring.add(bytesWritten);</span>
			}
<span class="fc" id="L553">		}</span>
		// No more block boundaries to cross. If there's any content left to write in the
		// current block,
		// do so now.
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">		if (thisPartCharsLeftToWrite &gt; 0) {</span>
<span class="fc" id="L558">			addToBlock(content.substring(thisPartCharsWritten, thisPartCharsWritten</span>
					+ thisPartCharsLeftToWrite));
<span class="fc" id="L560">			charsFromEntryWritten += thisPartCharsLeftToWrite;</span>
		}
<span class="fc" id="L562">	}</span>

	/**
	 * Convert the String representation of a block to a byte buffer
	 *
	 * @param block
	 *            the block content
	 * @return the byte buffer representation
	 */
	protected byte[] encodeBlock(String block) {
<span class="fc" id="L572">		return block.getBytes(DEFAULT_CHARSET);</span>
	}

	/**
	 * Convert the byte buffer representation of a block back to the original String
	 *
	 * @param buf
	 *            the byte buffer
	 * @param offset
	 *            offset in the buffer
	 * @param length
	 *            length of the block in bytes
	 * @return the original String content
	 */
	protected String decodeBlock(byte[] buf, int offset, int length) {
<span class="fc" id="L587">		return new String(buf, offset, length, DEFAULT_CHARSET);</span>
	}

	/**
	 * Store the given content and assign an id to it
	 *
	 * @param content
	 *            the content to store
	 * @return the id assigned to the content
	 */
	@Override
	public synchronized int store(String content) {
<span class="fc" id="L599">		storePart(content);</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">		if (currentBlockContents.length() &gt; 0) {</span>
			// Write the last (not completely full) block
<span class="fc" id="L602">			OutputStream os = openCurrentStoreFile();</span>
<span class="fc" id="L603">			writeCurrentBlock(os);</span>
		}
<span class="fc" id="L605">		int[] blockOffsetArray = new int[blockOffsetWhileStoring.size()];</span>
<span class="fc" id="L606">		int i = 0;</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">		for (Integer bo : blockOffsetWhileStoring) {</span>
<span class="fc" id="L608">			blockOffsetArray[i] = bo;</span>
<span class="fc" id="L609">			i++;</span>
<span class="fc" id="L610">		}</span>
<span class="fc" id="L611">		TocEntry e = new TocEntry(nextId, currentFileId, currentFileLength, bytesWritten,</span>
				charsFromEntryWritten, newEntryBlockSizeCharacters, false, blockOffsetArray);
<span class="fc" id="L613">		nextId++;</span>
<span class="fc" id="L614">		currentFileLength += bytesWritten;</span>
<span class="fc" id="L615">		toc.put(e.id, e);</span>
<span class="fc" id="L616">		tocModified = true;</span>
<span class="fc" id="L617">		charsFromEntryWritten = 0;</span>
<span class="fc" id="L618">		bytesWritten = 0;</span>
<span class="fc" id="L619">		blockOffsetWhileStoring = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L620">		return e.id;</span>
	}

	private OutputStream openCurrentStoreFile() {
		try {
<span class="fc" id="L625">			boolean createNew = false;</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">			if (currentFileLength &gt; dataFileSizeHint) {</span>
				// Current file is full!
<span class="fc" id="L628">				currentFileId++;</span>
<span class="fc" id="L629">				currentFileLength = 0;</span>
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">				if (currentStoreFileStream != null)</span>
<span class="fc" id="L631">					currentStoreFileStream.close();</span>
<span class="fc" id="L632">				currentStoreFileStream = null;</span>
<span class="fc" id="L633">				createNew = true; // start a new store file; delete if old stuff hanging around</span>
			}
<span class="fc bfc" id="L635" title="All 2 branches covered.">			if (currentStoreFileStream == null) {</span>
<span class="fc" id="L636">				File f = getContentFile(currentFileId);</span>
<span class="pc bpc" id="L637" title="1 of 4 branches missed.">				if (createNew &amp;&amp; f.exists())</span>
<span class="nc" id="L638">					f.delete(); // leftover from previous index; delete</span>
<span class="fc" id="L639">				currentStoreFileStream = new BufferedOutputStream(new FileOutputStream(f, true));</span>
			}
<span class="fc" id="L641">			return currentStoreFileStream;</span>
<span class="nc" id="L642">		} catch (Exception e) {</span>
<span class="nc" id="L643">			throw ExUtil.wrapRuntimeException(e);</span>
		}
	}

	private void closeCurrentStoreFile() {
		try {
<span class="fc bfc" id="L649" title="All 2 branches covered.">			if (currentStoreFileStream != null)</span>
<span class="fc" id="L650">				currentStoreFileStream.close();</span>
<span class="nc" id="L651">		} catch (IOException e) {</span>
<span class="nc" id="L652">			throw new RuntimeException(e);</span>
<span class="fc" id="L653">		}</span>
<span class="fc" id="L654">	}</span>

	/**
	 * Get a data File object, given the data file id.
	 *
	 * @param fileId
	 *            the data file id
	 * @return the File object
	 */
	private File getContentFile(int fileId) {
<span class="fc" id="L664">		File f = new File(dir, String.format(&quot;data%04d.dat&quot;, fileId));</span>
<span class="fc" id="L665">		return f;</span>
	}

	/**
	 * Retrieve content with given id
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	@Override
	public String retrieve(int id) {
<span class="fc" id="L677">		String[] rv = retrieveParts(id, new int[] { -1 }, new int[] { -1 });</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">		return rv == null ? null : rv[0];</span>
	}

	/**
	 * Retrieve one or more substrings from the specified content.
	 *
	 * This is more efficient than retrieving the whole content, or retrieving parts in separate
	 * calls, because the file is only opened once and random access is used to read only the
	 * required parts.
	 *
	 * NOTE: if offset and length are both -1, retrieves the whole content. This is used by the
	 * retrieve(id) method.
	 *
	 * @param contentId
	 *            id of the entry to get substrings from
	 * @param start
	 *            the starting points of the substrings (in characters).
	 *            -1 means &quot;start of document&quot;
	 * @param end
	 *            the end points of the substrings (in characters).
	 *            -1 means &quot;end of document&quot;
	 * @return the parts
	 */
	@Override
	public synchronized String[] retrieveParts(int contentId, int[] start, int[] end) {
		try {
			// Find the correct TOC entry
<span class="fc" id="L705">			TocEntry e = toc.get(contentId);</span>
<span class="pc bpc" id="L706" title="1 of 4 branches missed.">			if (e == null || e.deleted)</span>
<span class="fc" id="L707">				return null;</span>

			// Sanity-check parameters
<span class="fc" id="L710">			int n = start.length;</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">			if (n != end.length)</span>
<span class="nc" id="L712">				throw new IllegalArgumentException(&quot;start and end must be of equal length&quot;);</span>

			// Create array for results
<span class="fc" id="L715">			String[] result = new String[n];</span>

			// Open the correct file
<span class="pc" id="L718">			try (FileInputStream fileInputStream = new FileInputStream(getContentFile(e.fileId))) {</span>
<span class="pc" id="L719">				try (FileChannel fileChannel = fileInputStream.getChannel()) {</span>
					// Retrieve the strings requested
<span class="fc bfc" id="L721" title="All 2 branches covered.">					for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L722">						int a = start[i];</span>
<span class="fc" id="L723">						int b = end[i];</span>

<span class="fc bfc" id="L725" title="All 2 branches covered.">						if (a == -1)</span>
<span class="fc" id="L726">							a = 0;</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">						if (b == -1)</span>
<span class="fc" id="L728">							b = e.entryLengthCharacters;</span>

						// Check values
<span class="pc bpc" id="L731" title="2 of 4 branches missed.">						if (a &lt; 0 || b &lt; 0) {</span>
<span class="nc" id="L732">							throw new IllegalArgumentException(&quot;Illegal values, start = &quot; + a + &quot;, end = &quot; + b);</span>
						}
<span class="pc bpc" id="L734" title="2 of 4 branches missed.">						if (a &gt; e.entryLengthCharacters || b &gt; e.entryLengthCharacters) {</span>
<span class="nc" id="L735">							throw new IllegalArgumentException(&quot;Value(s) out of range, start = &quot; + a</span>
									+ &quot;, end = &quot; + b + &quot;, content length = &quot; + e.entryLengthCharacters);
						}
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">						if (b &lt;= a) {</span>
<span class="nc" id="L739">							throw new IllegalArgumentException(</span>
									&quot;Tried to read empty or negative length snippet (from &quot; + a
											+ &quot; to &quot; + b + &quot;)&quot;);
						}

						// 1 - determine what blocks to read
<span class="fc" id="L745">						int firstBlock = a / e.blockSizeCharacters;</span>
<span class="fc" id="L746">						int lastBlock = (b - 1) / e.blockSizeCharacters;</span>

						// 2 - read and decode blocks
<span class="fc" id="L749">						StringBuilder decoded = new StringBuilder();</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">						for (int j = firstBlock; j &lt;= lastBlock; j++) {</span>
<span class="fc" id="L751">							long readStartOffset = e.getBlockStartOffset(j);</span>
<span class="fc" id="L752">							int bytesToRead = (int) (e.getBlockEndOffset(j) - readStartOffset);</span>
<span class="fc" id="L753">							ByteBuffer buffer = ByteBuffer.allocate(bytesToRead);</span>
<span class="fc" id="L754">							int bytesRead = fileChannel.read(buffer, readStartOffset);</span>
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">							if (bytesRead &lt; bytesToRead) {</span>
								// Apparently, something went wrong.
<span class="nc" id="L757">								throw new RuntimeException(&quot;Not enough bytes read, &quot; + bytesRead</span>
										+ &quot; &lt; &quot; + bytesToRead);
							}
<span class="fc" id="L760">							decoded.append(decodeBlock(buffer.array(), 0, bytesRead));</span>
						}

						// 3 - take just what we need
<span class="fc" id="L764">						int firstChar = a % e.blockSizeCharacters;</span>
<span class="fc" id="L765">						String decodedStr = decoded.toString();</span>
						try {
<span class="fc" id="L767">							result[i] = decodedStr.substring(firstChar, firstChar + b - a);</span>
<span class="nc" id="L768">						} catch (StringIndexOutOfBoundsException e1) {</span>
<span class="nc" id="L769">							System.err.println(&quot;ERROR!\ndecodedStr.length() = &quot; + decodedStr.length() + &quot;\n&quot; +</span>
									&quot;firstChar = &quot; + firstChar + &quot;\na = &quot; + a + &quot;\nb = &quot; + b +
									&quot;\nfirstBlock = &quot; + firstBlock + &quot;\nlastBlock = &quot; + lastBlock);
<span class="nc" id="L772">							System.err.flush();</span>
<span class="nc" id="L773">							throw e1;</span>
<span class="fc" id="L774">						}</span>
					}
<span class="pc bpc" id="L776" title="6 of 8 branches missed.">				}</span>
<span class="pc bpc" id="L777" title="6 of 8 branches missed.">			}</span>
<span class="fc" id="L778">			return result;</span>
<span class="nc" id="L779">		} catch (Exception e) {</span>
<span class="nc" id="L780">			throw ExUtil.wrapRuntimeException(e);</span>
		}
	}

	@Override
	public synchronized void delete(int id) {
<span class="fc" id="L786">		TocEntry e = toc.get(id);</span>
<span class="fc" id="L787">		e.deleted = true;</span>
<span class="fc" id="L788">		tocModified = true;</span>
<span class="fc" id="L789">	}</span>

	@Override
	public Set&lt;Integer&gt; getDocIds() {
<span class="nc" id="L793">		return toc.keySet();</span>
	}

	@Override
	public boolean isDeleted(int id) {
<span class="nc" id="L798">		return toc.get(id).deleted;</span>
	}

	@Override
	public int getDocLength(int id) {
<span class="nc" id="L803">		return toc.get(id).entryLengthCharacters;</span>
	}

	@Override
	public Set&lt;Integer&gt; idSet() {
<span class="nc" id="L808">		return toc.keySet();</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>