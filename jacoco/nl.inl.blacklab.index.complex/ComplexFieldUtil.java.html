<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ComplexFieldUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.index.complex</a> &gt; <span class="el_source">ComplexFieldUtil.java</span></div><h1>ComplexFieldUtil.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2010, 2012 Institute for Dutch Lexicology
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package nl.inl.blacklab.index.complex;

import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

import nl.inl.blacklab.search.indexstructure.ComplexFieldDesc;
import nl.inl.blacklab.search.indexstructure.IndexStructure;
import nl.inl.blacklab.search.indexstructure.PropertyDesc;


/**
 * Some utility functions for dealing with complex field names.
 */
public class ComplexFieldUtil {

	public static final String FORWARD_INDEX_ID_BOOKKEEP_NAME = &quot;fiid&quot;;

	private static final String CONTENT_ID_BOOKKEEP_NAME = &quot;cid&quot;;

	private static final String LENGTH_TOKENS_BOOKKEEP_NAME = &quot;length_tokens&quot;;

	private static final String DEFAULT_MAIN_PROP_NAME = &quot;word&quot;;

	public static final String SENSITIVE_ALT_NAME = &quot;s&quot;;

	private static final String DEFAULT_MAIN_ALT_NAME = SENSITIVE_ALT_NAME;

	public static final String INSENSITIVE_ALT_NAME = &quot;i&quot;;

	public static final String CASE_INSENSITIVE_ALT_NAME = &quot;ci&quot;;

	public static final String DIACRITICS_INSENSITIVE_ALT_NAME = &quot;di&quot;;

	public static final String START_TAG_PROP_NAME = &quot;starttag&quot;;

	public static final String END_TAG_PROP_NAME = &quot;endtag&quot;;

<span class="fc" id="L54">	public static String WORD_PROP_NAME = &quot;word&quot;;</span>

	/** Property name for the spaces and punctuation between words */
	public static final String PUNCTUATION_PROP_NAME = &quot;punct&quot;;

	/** Property name for lemma/headword (optional, not every input format will have this) */
	public static final String LEMMA_PROP_NAME = &quot;lemma&quot;;

	/** Property name for part of speech (optional, not every input format will have this) */
	public static final String PART_OF_SPEECH_PROP_NAME = &quot;pos&quot;;

	/** For properties combined in a single Lucene field, this is the separator between the
	 *  name prefix of an indexed value and the actual value of the property */
	public static final String SUBPROPERTY_SEPARATOR = &quot;\u001F&quot;;

	/** Valid XML element names. Field and property names should generally conform to this. */
<span class="fc" id="L70">    static final Pattern REGEX_VALID_XML_ELEMENT_NAME = Pattern.compile(&quot;[a-zA-Z_][a-zA-Z0-9\\-_\\.]*&quot;);</span>

	/**
	 * String used to separate the base field name (say, contents) and the field property (pos,
	 * lemma, etc.)
	 */
	static String PROP_SEP;

	/**
	 * String used to separate the field/property name (say, contents_lemma) and the alternative
	 * (e.g. &quot;s&quot; for case-sensitive)
	 */
	static String ALT_SEP;

	/**
	 * String used to separate the field/property name (say, contents_lemma) and the alternative
	 * (e.g. &quot;s&quot; for case-sensitive)
	 */
	static String BOOKKEEPING_SEP;

	/** Length of the ALT separator */
	static int ALT_SEP_LEN;

	/** Length of the PROP separator */
	static int PROP_SEP_LEN;

	/** Length of the BOOKKEEPING separator */
	static int BOOKKEEPING_SEP_LEN;

	static {
		// Default: use new field naming scheme.
<span class="fc" id="L101">		setFieldNameSeparators(false);</span>
	}

	/** What are the names of the bookkeeping subfields (i.e. content id, forward index id, etc.) */
<span class="fc" id="L105">	private final static List&lt;String&gt; BOOKKEEPING_SUBFIELDS = Arrays.asList(</span>
		CONTENT_ID_BOOKKEEP_NAME,
		FORWARD_INDEX_ID_BOOKKEEP_NAME,
		LENGTH_TOKENS_BOOKKEEP_NAME
	);

<span class="nc" id="L111">	private ComplexFieldUtil() {</span>
<span class="nc" id="L112">	}</span>

<span class="pc" id="L114">	public enum BookkeepFieldType {</span>
<span class="fc" id="L115">		CONTENT_ID,</span>
<span class="fc" id="L116">		FORWARD_INDEX_ID,</span>
<span class="fc" id="L117">		LENGTH_TOKENS</span>
	}

	public static boolean isBookkeepingSubfield(String bookkeepName) {
<span class="fc" id="L121">		return BOOKKEEPING_SUBFIELDS.contains(bookkeepName);</span>
	}

	public static BookkeepFieldType whichBookkeepingSubfield(String bookkeepName) {
<span class="pc bpc" id="L125" title="2 of 4 branches missed.">		switch(BOOKKEEPING_SUBFIELDS.indexOf(bookkeepName)) {</span>
		case 0:
<span class="fc" id="L127">			return BookkeepFieldType.CONTENT_ID;</span>
		case 1:
<span class="nc" id="L129">			return BookkeepFieldType.FORWARD_INDEX_ID;</span>
		case 2:
<span class="fc" id="L131">			return BookkeepFieldType.LENGTH_TOKENS;</span>
		default:
<span class="nc" id="L133">			throw new IllegalArgumentException(&quot;Unknown bookkeeping field: &quot; + bookkeepName);</span>
		}
	}

	public static String contentIdField(String fieldName) {
<span class="fc" id="L138">		return bookkeepingField(fieldName, CONTENT_ID_BOOKKEEP_NAME);</span>
	}

	public static String forwardIndexIdField(String propFieldName) {
<span class="fc" id="L142">		return bookkeepingField(propFieldName, FORWARD_INDEX_ID_BOOKKEEP_NAME);</span>
	}

	public static String forwardIndexIdField(IndexStructure structure, String fieldName) {
<span class="nc" id="L146">		String propName = structure.getComplexFieldDesc(fieldName).getMainProperty().getName();</span>
<span class="nc" id="L147">		return forwardIndexIdField(propertyField(fieldName, propName));</span>
	}

	public static String lengthTokensField(String fieldName) {
<span class="fc" id="L151">		return bookkeepingField(fieldName, LENGTH_TOKENS_BOOKKEEP_NAME);</span>
	}

	public static String startTagPropertyField(String fieldName) {
<span class="nc" id="L155">		return propertyField(fieldName, START_TAG_PROP_NAME);</span>
	}

	public static String endTagPropertyField(String fieldName) {
<span class="nc" id="L159">		return propertyField(fieldName, END_TAG_PROP_NAME);</span>
	}

	/** Set what field name separators to use.
	 * @param avoidSpecialChars if true, use only standard identifier characters for the separators. If false, use special chars %, @, #.
	 */
	public static void setFieldNameSeparators(boolean avoidSpecialChars) {
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">		if (avoidSpecialChars) {</span>
			// Avoid using special characters in fieldnames, in case
			// this clashes with other Lucene-based software (such as e.g. Solr)
<span class="nc" id="L169">			PROP_SEP = &quot;_PR_&quot;;</span>
<span class="nc" id="L170">			ALT_SEP = &quot;_AL_&quot;;</span>
<span class="nc" id="L171">			BOOKKEEPING_SEP = &quot;_BK_&quot;;</span>
		} else {
			// Lucene doesn't have any restrictions on characters in field names;
			// use the short, symbolic ones.
<span class="fc" id="L175">			PROP_SEP = &quot;%&quot;;</span>
<span class="fc" id="L176">			ALT_SEP = &quot;@&quot;;</span>
<span class="fc" id="L177">			BOOKKEEPING_SEP = &quot;#&quot;;</span>
		}

<span class="fc" id="L180">		ALT_SEP_LEN = ALT_SEP.length();</span>
<span class="fc" id="L181">		PROP_SEP_LEN = PROP_SEP.length();</span>
<span class="fc" id="L182">		BOOKKEEPING_SEP_LEN = BOOKKEEPING_SEP.length();</span>
<span class="fc" id="L183">	}</span>

	/**
	 * Construct a complex field bookkeeping subfield name.
	 *
	 * @param fieldName
	 *            the base field name
	 * @param propName
	 *            the property name, or null if this is bookkeeping for the whole complex field
	 * @param bookkeepName
	 *            name of the bookkeeping value
	 * @return the combined complex field name
	 */
	public static String bookkeepingField(String fieldName, String propName, String bookkeepName) {
		String fieldPropName;
<span class="pc bpc" id="L198" title="1 of 4 branches missed.">		boolean propGiven = propName != null &amp;&amp; propName.length() &gt; 0;</span>
<span class="pc bpc" id="L199" title="2 of 4 branches missed.">		if (fieldName == null || fieldName.length() == 0) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">			if (propGiven) {</span>
<span class="nc" id="L201">				fieldPropName = propName;</span>
			} else
<span class="nc" id="L203">				throw new IllegalArgumentException(&quot;Must specify a base name, a property name or both: &quot; + fieldName + &quot;, &quot; + propName + &quot;, &quot; + bookkeepName);</span>
		} else {
<span class="fc bfc" id="L205" title="All 2 branches covered.">			fieldPropName = fieldName + (propGiven ? PROP_SEP + propName : &quot;&quot;);</span>
		}

<span class="pc bpc" id="L208" title="2 of 4 branches missed.">		if (bookkeepName == null || bookkeepName.length() == 0)</span>
<span class="nc" id="L209">			return fieldPropName;</span>
<span class="fc" id="L210">		return fieldPropName + BOOKKEEPING_SEP + bookkeepName;</span>
	}

	/**
	 * Construct a complex field bookkeeping subfield name.
	 *
	 * @param fieldName
	 *            the base field name
	 * @param bookkeepName
	 *            name of the bookkeeping value
	 * @return the combined complex field name
	 */
	public static String bookkeepingField(String fieldName, String bookkeepName) {
<span class="fc" id="L223">		return bookkeepingField(fieldName, null, bookkeepName);</span>
	}

	/**
	 * Construct a complex field property name.
	 *
	 * @param fieldName
	 *            the base field name
	 * @param propName
	 *            the property name
	 * @param altName
	 *            the alternative name
	 * @return the combined complex field name
	 */
	public static String propertyField(String fieldName, String propName, String altName) {
		String fieldPropName;
<span class="pc bpc" id="L239" title="2 of 4 branches missed.">		boolean propGiven = propName != null &amp;&amp; propName.length() &gt; 0;</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">		if (!propGiven) {</span>
<span class="nc" id="L241">			throw new IllegalArgumentException(&quot;Must specify a property name&quot;);</span>
		}
<span class="pc bpc" id="L243" title="1 of 4 branches missed.">		if (fieldName == null || fieldName.length() == 0) {</span>
<span class="fc" id="L244">			fieldPropName = propName;</span>
		} else {
<span class="fc" id="L246">			fieldPropName = fieldName + PROP_SEP + propName;</span>
		}

<span class="pc bpc" id="L249" title="1 of 4 branches missed.">		if (altName == null || altName.length() == 0) {</span>
<span class="fc" id="L250">			return fieldPropName;</span>
		}
<span class="fc" id="L252">		return fieldPropName + ALT_SEP + altName;</span>
	}

	/**
	 * Construct a complex field property name.
	 *
	 * @param fieldName
	 *            the base field name
	 * @param propName
	 *            the property name
	 * @return the combined complex field name
	 */
	public static String propertyField(String fieldName, String propName) {
<span class="fc" id="L265">		return propertyField(fieldName, propName, null);</span>
	}

	/**
	 * Construct a property alternative name from a field property name
	 * @param fieldPropName the field property name
	 * @param altName the alternative name
	 * @return the field property alternative name
	 */
	public static String propertyAlternative(String fieldPropName, String altName) {
<span class="nc bnc" id="L275" title="All 4 branches missed.">		if (altName == null || altName.length() == 0) {</span>
<span class="nc" id="L276">			throw new IllegalArgumentException(&quot;Must specify an alternative name&quot;);</span>
		}
<span class="nc" id="L278">		return fieldPropName + ALT_SEP + altName;</span>
	}

	/**
	 * Gets the different components of a complex field property (alternative) name.
	 *
	 * @param luceneFieldName
	 *   the Lucene index field name, with possibly a property and/or alternative added
	 * @return an array of size 1-4, containing the field name, and optionally the property name,
	 *   alternative name and bookkeeping field name.
	 *
	 *  Property name may be null if this is a main bookkeeping field.
	 *  Alternative name may be null if this is a bookkeeping field or if it indicates
	 *  the main property (not an alternative).
	 */
	public static String[] getNameComponents(String luceneFieldName) {

		/*
		Field names can be one of the following:

		(1) Property:              base%prop (e.g. word, lemma, pos)
		(2) Main bookkeeping:      base#cid
		(3) Property bookkeeping:  base%prop#fiid
		(4) Property alternative:  base%prop@alt

		(Old style, now unsupported:)

		(A) Main property:          base       (implicitly, &quot;word&quot;)
		(1) Additional property:    base__prop (e.g. lemma, pos)
		(B) Main bookkeeping:       base__fiid
		(3) Property bookkeeping:   base__prop__fiid
		(4) Property alternative:   base__prop_ALT_alt
		(C) Main prop alternative:  base_ALT_alt
		*/

		String baseName, propName, altName, bookkeepingName;

<span class="fc" id="L315">		int propSepPos = luceneFieldName.indexOf(PROP_SEP);</span>
<span class="fc" id="L316">		int altSepPos = luceneFieldName.indexOf(ALT_SEP);</span>
		int bookkeepingSepPos;
<span class="fc" id="L318">			bookkeepingSepPos = luceneFieldName.indexOf(BOOKKEEPING_SEP);</span>

		// Strip off property and possible alternative
<span class="fc bfc" id="L321" title="All 2 branches covered.">		if (propSepPos &gt;= 0) {</span>
			// Property given (1/3/4)
<span class="fc" id="L323">			baseName = luceneFieldName.substring(0, propSepPos);</span>
<span class="fc" id="L324">			int afterPropSepPos = propSepPos + PROP_SEP_LEN;</span>

<span class="fc bfc" id="L326" title="All 2 branches covered.">			if (altSepPos &gt;= 0) {</span>
				// Property and alternative given (4)
<span class="fc" id="L328">				propName = luceneFieldName.substring(afterPropSepPos, altSepPos);</span>
<span class="fc" id="L329">				altName = luceneFieldName.substring(altSepPos + ALT_SEP_LEN);</span>
<span class="fc" id="L330">				return new String[] {baseName, propName, altName};</span>
			}

			// Maybe it's a bookkeeping field?
<span class="pc bpc" id="L334" title="1 of 4 branches missed.">			if (bookkeepingSepPos &gt;= 0 &amp;&amp; bookkeepingSepPos &gt; propSepPos) {</span>
				// Property plus bookkeeping subfield given. (3)
<span class="fc" id="L336">				propName = luceneFieldName.substring(afterPropSepPos, bookkeepingSepPos);</span>
<span class="fc" id="L337">				bookkeepingName = luceneFieldName.substring(bookkeepingSepPos + BOOKKEEPING_SEP_LEN);</span>
<span class="fc" id="L338">				return new String[] {baseName, propName, null, bookkeepingName};</span>
			}

			// Plain property, no alternative or bookkeeping (1)
<span class="fc" id="L342">			propName = luceneFieldName.substring(afterPropSepPos);</span>
<span class="fc" id="L343">			return new String[] {baseName, propName};</span>
		}

		// No property given. Alternative?
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">		if (altSepPos &gt;= 0) {</span>
<span class="nc" id="L348">			throw new IllegalArgumentException(&quot;Basename+altname is not a valid field name! (&quot; + luceneFieldName + &quot;)&quot;);</span>
		}

<span class="fc bfc" id="L351" title="All 2 branches covered.">		if (bookkeepingSepPos &gt;= 0) {</span>
			// Main bookkeeping field (2)
<span class="fc" id="L353">			baseName = luceneFieldName.substring(0, bookkeepingSepPos);</span>
<span class="fc" id="L354">			altName = luceneFieldName.substring(bookkeepingSepPos + BOOKKEEPING_SEP_LEN);</span>
<span class="fc" id="L355">			return new String[] {baseName, null, null, altName};</span>
		}

		// Just the base name given (A).
		// This means it's a metadata field.
<span class="fc" id="L360">		return new String[] {luceneFieldName};</span>
	}

	/**
	 * Gets the base complex field name from a Lucene index field name. So &quot;contents&quot; and
	 * &quot;contents%pos&quot; would both yield &quot;contents&quot;.
	 *
	 * @param luceneFieldName
	 *            the Lucene index field name, with possibly a property added
	 * @return the base complex field name
	 */
	public static String getBaseName(String luceneFieldName) {
		// Strip off property and possible alternative
<span class="fc" id="L373">		int pos = luceneFieldName.indexOf(PROP_SEP);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">		if (pos &gt;= 0) {</span>
<span class="fc" id="L375">			return luceneFieldName.substring(0, pos);</span>
		}
<span class="fc" id="L377">		pos = luceneFieldName.indexOf(BOOKKEEPING_SEP);</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">		if (pos &gt;= 0) {</span>
<span class="nc" id="L379">			return luceneFieldName.substring(0, pos);</span>
		}
<span class="fc" id="L381">		pos = luceneFieldName.indexOf(ALT_SEP);</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">		if (pos &gt;= 0) {</span>
<span class="nc" id="L383">			throw new IllegalArgumentException(&quot;Illegal field name: &quot; + luceneFieldName);</span>
		}
<span class="fc" id="L385">		return luceneFieldName;</span>
	}

	/**
	 * Checks if the given fieldName actually points to an alternative property (for example, a
	 * case-sensitive version of a property).
	 *
	 * Example: the fieldName &quot;contents%lemma@s&quot; indicates the &quot;s&quot; alternative of the &quot;lemma&quot;
	 * property of the &quot;contents&quot; complex field.
	 *
	 * @param fieldPropAltName
	 *            the full fieldname, possibly including a property and/or alternative
	 * @param altName
	 *            the alternative to test for
	 * @return true if the fieldName indicates the specified alternative
	 */
	public static boolean isAlternative(String fieldPropAltName, String altName) {
<span class="fc bfc" id="L402" title="All 2 branches covered.">		if (altName.length() == 0) {</span>
			// No alternative, therefore no alternative separator
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">			return fieldPropAltName.indexOf(ALT_SEP) &lt; 0;</span>
		}

		// We're looking for an alternative
<span class="fc" id="L408">		String altSuffix = ALT_SEP + altName;</span>
<span class="fc" id="L409">		return fieldPropAltName.endsWith(altSuffix);</span>
	}

	public static String mainPropertyField(IndexStructure structure, String fieldName) {
<span class="fc" id="L413">		ComplexFieldDesc cf = structure.getComplexFieldDesc(fieldName);</span>
<span class="fc" id="L414">		PropertyDesc pr = cf.getMainProperty();</span>
<span class="fc" id="L415">		return propertyField(fieldName, pr.getName());</span>
	}

	public static String mainPropertyOffsetsField(IndexStructure structure, String fieldName) {
<span class="nc" id="L419">		ComplexFieldDesc cf = structure.getComplexFieldDesc(fieldName);</span>
<span class="nc" id="L420">		PropertyDesc pr = cf.getMainProperty();</span>
<span class="nc" id="L421">		return propertyField(fieldName, pr.getName(), pr.offsetsAlternative());</span>
	}

	public static String getDefaultMainPropName() {
<span class="fc" id="L425">		return DEFAULT_MAIN_PROP_NAME;</span>
	}

	public static String getDefaultMainAlternativeName() {
<span class="nc" id="L429">		return DEFAULT_MAIN_ALT_NAME;</span>
	}

	/**
	 * Are we using the naming scheme with longer separation codes with no special characters in them?
	 * @return true if we are, false if not
	 */
	public static boolean avoidSpecialCharsInFieldNames() {
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">		return PROP_SEP_LEN &gt; 1;</span>
	}

	/**
	 * Does this Lucene field name refer to a case-sensitive alternative?
	 *
	 * Case-sensitive alternatives are &quot;s&quot; (case- and diacritics-sensitive)
	 * and &quot;di&quot; (diacritics-insensitive but case-sensitive).
	 *
	 * @param fieldPropAltName Lucene field name including property and alt name
	 * @return true if the field name refers to a case-sensitive alternative
	 */
	public static boolean isCaseSensitive(String fieldPropAltName) {
		// both-sensitive or diacritics-insensitive
<span class="pc bpc" id="L451" title="2 of 4 branches missed.">		return fieldPropAltName.endsWith(ALT_SEP + &quot;s&quot;) || fieldPropAltName.endsWith(ALT_SEP + &quot;di&quot;);</span>
	}

	/**
	 * Does this Lucene field name refer to a diacritics-sensitive alternative?
	 *
	 * Diacritics-sensitive alternatives are &quot;s&quot; (case- and diacritics-sensitive)
	 * and &quot;ci&quot; (case-insensitive but diacritics-sensitive).
	 *
	 * @param fieldPropAltName Lucene field name including property and alt name
	 * @return true if the field name refers to a diacritics-sensitive alternative
	 */
	public static boolean isDiacriticsSensitive(String fieldPropAltName) {
		// both-sensitive or case-insensitive
<span class="pc bpc" id="L465" title="2 of 4 branches missed.">		return fieldPropAltName.endsWith(ALT_SEP + &quot;s&quot;) || fieldPropAltName.endsWith(ALT_SEP + &quot;ci&quot;);</span>
	}
	
	/**
	 * Is the specified name a valid XML element name?
	 * 
	 * Generally, field and property names should be valid XML element names,
	 * so we don't have to sanitize them when generating output XML.
	 * 
	 * @param name name to check
	 * @return true iff it's a valid XML element name
	 */
    public static boolean isValidXmlElementName(String name) {
<span class="fc" id="L478">        return REGEX_VALID_XML_ELEMENT_NAME.matcher(name).matches();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>