<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Searcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.search</a> &gt; <span class="el_source">Searcher.java</span></div><h1>Searcher.java</h1><pre class="source lang-java linenums">package nl.inl.blacklab.search;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.JarURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.text.Collator;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.jar.Attributes;
import java.util.jar.Manifest;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.index.CorruptIndexException;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.search.BooleanQuery;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.spans.SpanQuery;
import org.apache.lucene.store.LockObtainFailedException;

import nl.inl.blacklab.analysis.BLDutchAnalyzer;
import nl.inl.blacklab.analysis.BLNonTokenizingAnalyzer;
import nl.inl.blacklab.analysis.BLStandardAnalyzer;
import nl.inl.blacklab.analysis.BLWhitespaceAnalyzer;
import nl.inl.blacklab.externalstorage.ContentStore;
import nl.inl.blacklab.externalstorage.ContentStoresManager;
import nl.inl.blacklab.forwardindex.ForwardIndex;
import nl.inl.blacklab.forwardindex.Terms;
import nl.inl.blacklab.highlight.XmlHighlighter;
import nl.inl.blacklab.highlight.XmlHighlighter.HitCharSpan;
import nl.inl.blacklab.highlight.XmlHighlighter.UnbalancedTagsStrategy;
import nl.inl.blacklab.index.complex.ComplexFieldUtil;
import nl.inl.blacklab.index.config.ConfigInputFormat;
import nl.inl.blacklab.index.config.ConfigCorpus.TextDirection;
import nl.inl.blacklab.perdocument.DocResults;
import nl.inl.blacklab.search.indexstructure.IndexStructure;
import nl.inl.blacklab.search.lucene.BLSpanQuery;
import nl.inl.blacklab.search.lucene.SpanQueryFiltered;
import nl.inl.util.VersionFile;

public abstract class Searcher {

<span class="fc" id="L59">	protected static final Logger logger = LogManager.getLogger(Searcher.class);</span>

	/** Log detailed debug messages about opening an index? */
<span class="fc" id="L62">	public static boolean traceIndexOpening = false;</span>

	/** Log detailed debug messages about query optimization? */
<span class="fc" id="L65">	public static boolean traceOptimization = false;</span>

	/** Log debug messages about query execution at various stages, to analyze what makes a query slow? */
<span class="fc" id="L68">	public static boolean traceQueryExecution = false;</span>

	/** When setting how many hits to retrieve/count, this means &quot;no limit&quot;. */
	public final static int UNLIMITED_HITS = -1;

	public static final int DEFAULT_MAX_RETRIEVE = 1000000;

	public static final int DEFAULT_MAX_COUNT = Searcher.UNLIMITED_HITS;

	/** Complex field name for default contents field */
	public static final String DEFAULT_CONTENTS_FIELD_NAME = &quot;contents&quot;;

<span class="fc" id="L80">	public static final ConcordanceType DEFAULT_CONC_TYPE = ConcordanceType.CONTENT_STORE;</span>

<span class="fc" id="L82">	public static final String DEFAULT_CONC_WORD_PROP = ComplexFieldUtil.WORD_PROP_NAME;</span>

	public static final String DEFAULT_CONC_PUNCT_PROP = ComplexFieldUtil.PUNCTUATION_PROP_NAME;

<span class="fc" id="L86">	public static final Collection&lt;String&gt; DEFAULT_CONC_ATTR_PROP = null;</span>

	public static final int DEFAULT_CONTEXT_SIZE = 5;

	/** The collator to use for sorting. Defaults to English collator. */
<span class="fc" id="L91">	protected static Collator defaultCollator = Collator.getInstance(new Locale(&quot;en&quot;, &quot;GB&quot;));</span>

    /** Analyzer based on WhitespaceTokenizer */
<span class="fc" id="L94">	final protected static Analyzer whitespaceAnalyzer = new BLWhitespaceAnalyzer();</span>

	/** Analyzer for Dutch and other Latin script languages */
<span class="fc" id="L97">	final protected static Analyzer defaultAnalyzer = new BLDutchAnalyzer();</span>

	/** Analyzer based on StandardTokenizer */
<span class="fc" id="L100">	final protected static Analyzer standardAnalyzer = new BLStandardAnalyzer();</span>

	/** Analyzer that doesn't tokenize */
<span class="fc" id="L103">	final protected static Analyzer nonTokenizingAnalyzer = new BLNonTokenizingAnalyzer();</span>

<span class="fc" id="L105">	final protected static Map&lt;IndexReader, Searcher&gt; searcherFromIndexReader = new IdentityHashMap&lt;&gt;();</span>

	public static Searcher fromIndexReader(IndexReader reader) {
<span class="fc" id="L108">		return searcherFromIndexReader.get(reader);</span>
	}

	/**
	 * Open an index for writing (&quot;index mode&quot;: adding/deleting documents).
	 *
	 * Note that in index mode, searching operations may not take the latest
	 * changes into account. It is wisest to only use index mode for indexing,
	 * then close the Searcher and create a regular one for searching.
	 *
	 * @param indexDir the index directory
	 * @param createNewIndex if true, create a new index even if one existed there
	 * @return the searcher in index mode
	 * @throws IOException
	 */
	public static Searcher openForWriting(File indexDir, boolean createNewIndex) throws IOException {
<span class="nc" id="L124">		return new SearcherImpl(indexDir, true, createNewIndex, (File)null);</span>
	}

	/**
	 * Open an index for writing (&quot;index mode&quot;: adding/deleting documents).
	 *
	 * Note that in index mode, searching operations may not take the latest
	 * changes into account. It is wisest to only use index mode for indexing,
	 * then close the Searcher and create a regular one for searching.
	 *
	 * @param indexDir the index directory
	 * @param createNewIndex if true, create a new index even if one existed there
	 * @param indexTemplateFile JSON template to use for index structure / metadata
	 * @return the searcher in index mode
	 * @throws IOException
	 */
	public static Searcher openForWriting(File indexDir, boolean createNewIndex, File indexTemplateFile) throws IOException {
<span class="nc" id="L141">		return new SearcherImpl(indexDir, true, createNewIndex, indexTemplateFile);</span>
	}

    /**
     * Open an index for writing (&quot;index mode&quot;: adding/deleting documents).
     *
     * Note that in index mode, searching operations may not take the latest
     * changes into account. It is wisest to only use index mode for indexing,
     * then close the Searcher and create a regular one for searching.
     *
     * @param indexDir the index directory
     * @param createNewIndex if true, create a new index even if one existed there
     * @param config input format config to use as template for index structure / metadata
     *    (if creating new index)
     * @return the searcher in index mode
     * @throws IOException
     */
    public static Searcher openForWriting(File indexDir, boolean createNewIndex, ConfigInputFormat config) throws IOException {
<span class="fc" id="L159">        return new SearcherImpl(indexDir, true, createNewIndex, config);</span>
    }

	/**
	 * Create an empty index.
	 *
	 * @param indexDir where to create the index
	 * @return a Searcher for the new index, in index mode
	 * @throws IOException
	 */
	public static Searcher createIndex(File indexDir) throws IOException {
<span class="nc" id="L170">		return createIndex(indexDir, null, null, null, false, TextDirection.LEFT_TO_RIGHT);</span>
	}

	/**
	 * Create an empty index.
	 *
	 * @param indexDir where to create the index
	 * @param displayName the display name for the new index, or null to
	 *   assign one automatically (based on the directory name)
	 * @return a Searcher for the new index, in index mode
	 * @throws IOException
	 */
	public static Searcher createIndex(File indexDir, String displayName) throws IOException {
<span class="nc" id="L183">		return createIndex(indexDir, null, displayName, null, false, TextDirection.LEFT_TO_RIGHT);</span>
	}

    /**
     * Create an empty index.
     *
     * @param indexDir where to create the index
     * @param config format configuration for this index; used to base the index metadata on
     * @param displayName the display name for the new index, or null to
     *   assign one automatically (based on the directory name)
     * @param contentViewable is viewing of the document contents allowed?
     * @param textDirection text direction for this corpus
     * @param documentFormat a format identifier to store as the document format,
     *   or null for none. See the DocumentFormats class.
     * @return a Searcher for the new index, in index mode
     * @throws IOException
     */
    public static Searcher createIndex(File indexDir, ConfigInputFormat config, String displayName,
            String documentFormatId, boolean contentViewable, TextDirection textDirection) throws IOException {
<span class="nc" id="L202">        Searcher rv = openForWriting(indexDir, true, config);</span>
<span class="nc" id="L203">        IndexStructure struct = rv.getIndexStructure();</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (!StringUtils.isEmpty(displayName))</span>
<span class="nc" id="L205">            struct.setDisplayName(displayName);</span>
<span class="nc bnc" id="L206" title="All 4 branches missed.">        if (config != null &amp;&amp; config.getName() != null)</span>
<span class="nc" id="L207">            struct.setDocumentFormat(config.getName());</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        else if (!StringUtils.isEmpty(documentFormatId)){</span>
<span class="nc" id="L209">            struct.setDocumentFormat(documentFormatId);</span>
        }
<span class="nc" id="L211">        struct.setContentViewable(contentViewable);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (textDirection != null)</span>
<span class="nc" id="L213">            struct.setTextDirection(textDirection);</span>
<span class="nc" id="L214">        struct.writeMetadata();</span>
<span class="nc" id="L215">        return rv;</span>
    }

	/**
	 * Open an index for reading (&quot;search mode&quot;).
	 *
	 * @param indexDir the index directory
	 * @return the searcher
	 * @throws CorruptIndexException
	 * @throws IOException
	 */
	public static Searcher open(File indexDir) throws CorruptIndexException, IOException {
<span class="fc" id="L227">		return new SearcherImpl(indexDir, false, false, (File)null);</span>
	}

	/**
	 * Does the specified directory contain a BlackLab index?
	 * @param indexDir the directory
	 * @return true if it's a BlackLab index, false if not.
	 */
	public static boolean isIndex(File indexDir) {
		try {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">			if (VersionFile.exists(indexDir)) {</span>
<span class="fc" id="L238">				VersionFile vf = VersionFile.read(indexDir);</span>
<span class="fc" id="L239">				String version = vf.getVersion();</span>
<span class="pc bpc" id="L240" title="3 of 6 branches missed.">				if (vf.getType().equals(&quot;blacklab&quot;) &amp;&amp; (version.equals(&quot;1&quot;) || version.equals(&quot;2&quot;)))</span>
<span class="fc" id="L241">					return true;</span>
			}
<span class="nc" id="L243">			return false;</span>
<span class="nc" id="L244">		} catch (FileNotFoundException e) {</span>
<span class="nc" id="L245">			throw new RuntimeException(e);</span>
		}
	}

	/**
	 * Cut a few words from a string.
	 *
	 * Note, this just splits on whitespace and glues words
	 * back with space. Might not work very well in all cases,
	 * but it's not likely to be used anyway (we generally don't
	 * cut a few words from a metadata field).
	 *
	 * @param content the string to cut from
	 * @param startAtWord first word to include
	 * @param endAtWord first word not to include
	 * @return the cut string
	 */
	protected static String getWordsFromString(String content, int startAtWord,
			int endAtWord) {
<span class="nc bnc" id="L264" title="All 4 branches missed.">		if (startAtWord == -1 &amp;&amp; endAtWord == -1)</span>
<span class="nc" id="L265">			return content;</span>
		// We want specific words from the field; quick-n-dirty way to do this
		// (will probably never be used, but let's try to be generic)
<span class="nc" id="L268">		String[] words = content.split(&quot;\\s+&quot;);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">		if (startAtWord == -1)</span>
<span class="nc" id="L270">			startAtWord = 0;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">		if (endAtWord == -1)</span>
<span class="nc" id="L272">			endAtWord = words.length;</span>
<span class="nc" id="L273">		StringBuilder b = new StringBuilder();</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">		for (int i = startAtWord; i &lt; endAtWord; i++) {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">			if (b.length() &gt; 0)</span>
<span class="nc" id="L276">				b.append(&quot; &quot;);</span>
<span class="nc" id="L277">			b.append(words[i]);</span>
		}
<span class="nc" id="L279">		return b.toString();</span>
	}

	public static Collator getDefaultCollator() {
<span class="nc" id="L283">		return defaultCollator;</span>
	}

	public static void setDefaultCollator(Collator defaultCollator) {
<span class="nc" id="L287">		Searcher.defaultCollator = defaultCollator;</span>
<span class="nc" id="L288">	}</span>

	/**
	 * Return a timestamp for when BlackLab was built.
	 *
	 * @return build timestamp (format: yyyy-MM-dd HH:mm:ss), or UNKNOWN if
	 *   the timestamp could not be found for some reason (i.e. not running from a
	 *   JAR, or key not found in manifest).
	 */
	public static String getBlackLabBuildTime() {
<span class="fc" id="L298">		return getValueFromManifest(&quot;Build-Time&quot;, &quot;UNKNOWN&quot;);</span>
	}

	/**
	 * Return the BlackLab version.
	 *
	 * @return BlackLab version, or UNKNOWN if the version could not be found
	 *   for some reason (i.e. not running from a JAR, or key not found in manifest).
	 */
	public static String getBlackLabVersion() {
<span class="fc" id="L308">		return getValueFromManifest(&quot;Implementation-Version&quot;, &quot;UNKNOWN&quot;);</span>
	}

	/**
	 * Get a value from the manifest file, if available.
	 *
	 * @param key key to get the value for, e.g. &quot;Build-Time&quot;.
	 * @param defaultValue value to return if no manifest found or key not found
	 * @return value from the manifest, or the default value if not found
	 */
	static String getValueFromManifest(String key, String defaultValue) {
		try {
<span class="fc" id="L320">			URL res = Searcher.class.getResource(Searcher.class.getSimpleName() + &quot;.class&quot;);</span>
<span class="fc" id="L321">			URLConnection conn = res.openConnection();</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">			if (!(conn instanceof JarURLConnection)) {</span>
				// Not running from a JAR, no manifest to read
<span class="fc" id="L324">				return defaultValue;</span>
			}
<span class="nc" id="L326">			JarURLConnection jarConn = (JarURLConnection) res.openConnection();</span>
<span class="nc" id="L327">			Manifest mf = jarConn.getManifest();</span>
<span class="nc" id="L328">			String value = null;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">			if (mf != null) {</span>
<span class="nc" id="L330">				Attributes atts = mf.getMainAttributes();</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">				if (atts != null) {</span>
<span class="nc" id="L332">					value = atts.getValue(key);</span>
				}
			}
<span class="nc bnc" id="L335" title="All 2 branches missed.">			return value == null ? defaultValue : value;</span>
<span class="nc" id="L336">		} catch (IOException e) {</span>
<span class="nc" id="L337">			throw new RuntimeException(&quot;Could not read '&quot; + key + &quot;' from manifest&quot;, e);</span>
		}
	}

	/**
	 * Instantiate analyzer based on an analyzer alias.
	 *
	 * @param analyzerName type of analyzer (default|whitespace|standard|nontokenizing)
	 * @return the analyzer, or null if the name wasn't recognized
	 */
	static Analyzer getAnalyzerInstance(String analyzerName) {
<span class="fc" id="L348">		analyzerName = analyzerName.toLowerCase();</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">		if (analyzerName.equals(&quot;whitespace&quot;)) {</span>
<span class="nc" id="L350">			return whitespaceAnalyzer;</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">		} else if (analyzerName.equals(&quot;default&quot;)) {</span>
<span class="fc" id="L352">			return defaultAnalyzer;</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">		} else if (analyzerName.equals(&quot;standard&quot;)) {</span>
<span class="nc" id="L354">			return standardAnalyzer;</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">		} else if (analyzerName.matches(&quot;(non|un)tokeniz(ing|ed)&quot;)) {</span>
<span class="fc" id="L356">			return nonTokenizingAnalyzer;</span>
		}
<span class="nc" id="L358">		return null;</span>
	}

	public static void setTraceIndexOpening(boolean traceIndexOpening) {
<span class="nc" id="L362">	    logger.debug(&quot;Trace index opening: &quot; + traceIndexOpening);</span>
<span class="nc" id="L363">		Searcher.traceIndexOpening = traceIndexOpening;</span>
<span class="nc" id="L364">	}</span>

	public static void setTraceOptimization(boolean traceOptimization) {
<span class="nc" id="L367">        logger.debug(&quot;Trace optimization: &quot; + traceOptimization);</span>
<span class="nc" id="L368">		Searcher.traceOptimization = traceOptimization;</span>
<span class="nc" id="L369">	}</span>

	public static void setTraceQueryExecution(boolean traceQueryExecution) {
<span class="nc" id="L372">        logger.debug(&quot;Trace query execution: &quot; + traceQueryExecution);</span>
<span class="nc" id="L373">		Searcher.traceQueryExecution = traceQueryExecution;</span>
<span class="nc" id="L374">	}</span>


	/**
	 * @return config directories, in decreasing order of priority
	 * @deprecated use {@link ConfigReader#getDefaultConfigDirs()}
	 */
	@Deprecated // Since 1.7, jan 2018
    public static List&lt;File&gt; getConfigDirs() {
<span class="nc" id="L383">        return ConfigReader.getDefaultConfigDirs();</span>
    }

	//-------------------------------------------------------------------------

	/** The collator to use for sorting. Defaults to English collator. */
<span class="fc" id="L389">	private Collator collator = Searcher.defaultCollator;</span>

	/** Analyzer used for indexing our metadata fields */
<span class="fc" id="L392">	protected Analyzer analyzer = new BLStandardAnalyzer();</span>

	/** Structure of our index */
	protected IndexStructure indexStructure;

<span class="fc" id="L397">	protected ContentStoresManager contentStores = new ContentStoresManager();</span>

	/**
	 * ForwardIndices allow us to quickly find what token occurs at a specific position. This speeds
	 * up grouping and sorting. There may be several indices on a complex field, e.g.: word form,
	 * lemma, part of speech.
	 *
	 * Indexed by property name.
	 */
<span class="fc" id="L406">	protected Map&lt;String, ForwardIndex&gt; forwardIndices = new HashMap&lt;&gt;();</span>

	protected HitsSettings hitsSettings;

	/**
	 * The default settings for all new Hits objects.
	 *
	 * You may change these settings; this will affect all new Hits objects.
	 *
	 * @return settings object
	 */
	public HitsSettings hitsSettings() {
<span class="fc" id="L418">		return hitsSettings;</span>
	}

<span class="fc" id="L421">	public Searcher() {</span>
<span class="fc" id="L422">		hitsSettings = new HitsSettings();</span>
<span class="fc" id="L423">	}</span>

//	/**
//	 * Stop retrieving hits after this number.
//	 * (HitsSettings.UNLIMITED = don't stop retrieving)
//	 */
//	protected int defaultMaxHitsToRetrieve = DEFAULT_MAX_RETRIEVE;
//
//	/**
//	 * Stop counting hits after this number.
//	 * (HitsSettings.UNLIMITED = don't stop counting)
//	 */
//	protected int defaultMaxHitsToCount = DEFAULT_MAX_COUNT;
//
//	/** Do we want to retrieve concordances from the forward index instead of from the
//	 *  content store? Generating them from the forward index is more
//	 *  efficient.
//	 *
//	 *  This is set to FORWARD_INDEX for all modern indices.
//	 *  (to be precise, it's set to true iff a punctuation forward index is present)
//	 *
//	 *  This setting controls the default. You don't have to set this to CONTENT_STORE if
//	 *  you *sometimes* want concordances from the content store; you can specifically
//	 *  request those when you need them.
//	 */
//	private ConcordanceType defaultConcsType = DEFAULT_CONC_TYPE;
//
	/**
	 * Name of the main contents field (used as default parameter value for many methods)
	 */
<span class="fc" id="L453">	protected String mainContentsFieldName = DEFAULT_CONTENTS_FIELD_NAME;</span>
//
//	/** Forward index to use as text context of &amp;lt;w/&amp;gt; tags in concordances (words; null = no text content) */
//	private String concWordFI = DEFAULT_CONC_WORD_PROP;
//
//	/** Forward index to use as text context between &amp;lt;w/&amp;gt; tags in concordances (punctuation+whitespace; null = just a space) */
//	private String concPunctFI = DEFAULT_CONC_PUNCT_PROP;
//
//	/** Forward indices to use as attributes of &amp;lt;w/&amp;gt; tags in concordances (null = the rest) */
//	private Collection&lt;String&gt; concAttrFI = DEFAULT_CONC_ATTR_PROP; // all other FIs are attributes
//
//	/** Default number of words around a hit */
//	protected int defaultContextSize = DEFAULT_CONTEXT_SIZE;

	/** Should we default to case-sensitive searching? [false] */
<span class="fc" id="L468">	protected boolean defaultCaseSensitive = false;</span>

	/** Should we default to diacritics-sensitive searching? [false] */
<span class="fc" id="L471">	protected boolean defaultDiacriticsSensitive = false;</span>

	/** How we fix well-formedness for snippets of XML: by adding or removing unbalanced tags */
<span class="fc" id="L474">	private UnbalancedTagsStrategy defaultUnbalancedTagsStrategy = UnbalancedTagsStrategy.ADD_TAG;</span>

	/** If true, we want to add/delete documents. If false, we're just searching. */
<span class="fc" id="L477">	protected boolean indexMode = false;</span>

	/** @return the default maximum number of hits to retrieve.
	 * @deprecated use hitsSettings().maxHitsToRetrieve()
	 */
	@Deprecated
	public int getDefaultMaxHitsToRetrieve() {
<span class="nc" id="L484">		return hitsSettings().maxHitsToRetrieve();</span>
	}

	/** Set the default maximum number of hits to retrieve
	 * @param n the number of hits, or HitsSettings.UNLIMITED for no limit
	 * @deprecated use hitsSettings().setMaxHitsToRetrieve()
	 */
	@Deprecated
	public void setDefaultMaxHitsToRetrieve(int n) {
<span class="nc" id="L493">		hitsSettings().setMaxHitsToRetrieve(n);</span>
<span class="nc" id="L494">	}</span>

	/** @return the default maximum number of hits to count.
	 * @deprecated use hitsSettings().maxHitsToCount()
	 */
	@Deprecated
	public int getDefaultMaxHitsToCount() {
<span class="nc" id="L501">		return hitsSettings().maxHitsToCount();</span>
	}

	/** Set the default maximum number of hits to count
	 * @param n the number of hits, or HitsSettings.UNLIMITED for no limit
	 * @deprecated use hitsSettings().setMaxHitsToCount()
	 */
	@Deprecated
	public void setDefaultMaxHitsToCount(int n) {
<span class="nc" id="L510">		hitsSettings().setMaxHitsToCount(n);</span>
<span class="nc" id="L511">	}</span>

	/**
	 * How do we fix well-formedness for snippets of XML?
	 * @return the setting: either adding or removing unbalanced tags
	 */
	public UnbalancedTagsStrategy getDefaultUnbalancedTagsStrategy() {
<span class="nc" id="L518">		return defaultUnbalancedTagsStrategy;</span>
	}

	/**
	 * Set how to fix well-formedness for snippets of XML.
	 * @param strategy the setting: either adding or removing unbalanced tags
	 */
	public void setDefaultUnbalancedTagsStrategy(UnbalancedTagsStrategy strategy) {
<span class="nc" id="L526">		this.defaultUnbalancedTagsStrategy = strategy;</span>
<span class="nc" id="L527">	}</span>

	/**
	 * @return the default concordance type
	 * @deprecated use hitsSettings().concordanceType()
	 */
	@Deprecated
	public ConcordanceType getDefaultConcordanceType() {
<span class="nc" id="L535">		return hitsSettings().concordanceType();</span>
	}

	/**
	 * @param type the default concordance type
	 * @deprecated use hitsSettings().setConcordanceType()
	 */
	@Deprecated
	public void setDefaultConcordanceType(ConcordanceType type) {
<span class="nc" id="L544">		hitsSettings().setConcordanceType(type);</span>
<span class="nc" id="L545">	}</span>

	/**
	 * Set the collator used for sorting.
	 *
	 * The default collator is for English.
	 *
	 * @param collator
	 *            the collator
	 */
	public void setCollator(Collator collator) {
<span class="nc" id="L556">		this.collator = collator;</span>
<span class="nc" id="L557">	}</span>

	/**
	 * Get the collator being used for sorting.
	 *
	 * @return the collator
	 */
	public Collator getCollator() {
<span class="fc" id="L565">		return collator;</span>
	}


	/**
	 * Are we making concordances using the forward index (true) or using
	 * the content store (false)? Forward index is more efficient but returns
	 * concordances that don't include XML tags.
	 *
	 * @return true iff we use the forward index for making concordances.
	 * @deprecated use hitsSettings().concordanceType()
	 */
	@Deprecated
	public boolean getMakeConcordancesFromForwardIndex() {
<span class="nc bnc" id="L579" title="All 2 branches missed.">		return getDefaultConcordanceType() == ConcordanceType.FORWARD_INDEX;</span>
	}

	/**
	 * Do we want to retrieve concordances from the forward index instead of from the
	 * content store? This may be more efficient, particularly for small result sets
	 * (because it eliminates seek time and decompression time), but concordances won't
	 * include XML tags.
	 *
	 * Also, if there is no punctuation forward index (&quot;punct&quot;), concordances won't include
	 * punctuation.
	 *
	 * @param concordancesFromForwardIndex true if we want to use the forward index to make
	 * concordances.
	 * @deprecated use hitsSettings().setConcordanceType()
	 */
	@Deprecated
	public void setMakeConcordancesFromForwardIndex(boolean concordancesFromForwardIndex) {
<span class="nc bnc" id="L597" title="All 2 branches missed.">		setDefaultConcordanceType(concordancesFromForwardIndex ? ConcordanceType.FORWARD_INDEX : ConcordanceType.CONTENT_STORE);</span>
<span class="nc" id="L598">	}</span>

	/**
	 * Is this a newly created, empty index?
	 * @return true if it is, false if not
	 */
	public abstract boolean isEmpty();

	/**
	 * Call this to roll back any changes made to the index this session.
	 * Calling close() will automatically commit any changes. If you call this
	 * method, then call close(), no changes will be committed.
	 */
	public abstract void rollback();

	/**
	 * Finalize the Searcher object. This closes the IndexSearcher and (depending on the constructor
	 * used) may also close the index reader.
	 */
	public void close() {
<span class="fc" id="L618">		contentStores.close();</span>

		// Close the forward indices
<span class="fc bfc" id="L621" title="All 2 branches covered.">		for (ForwardIndex fi: forwardIndices.values()) {</span>
<span class="fc" id="L622">			fi.close();</span>
<span class="fc" id="L623">		}</span>

<span class="fc" id="L625">	}</span>

	/**
	 * Get information about the structure of the BlackLab index.
	 *
	 * @return the structure object
	 */
	public IndexStructure getIndexStructure() {
<span class="fc" id="L633">		return indexStructure;</span>
	}

	/**
	 * Retrieve a Lucene Document object from the index.
	 *
	 * NOTE: you must check if the document isn't deleted using Search.isDeleted()
	 * first! Lucene 4.0+ allows you to retrieve deleted documents, making you
	 * responsible for checking whether documents are deleted or not.
	 * (This doesn't apply to search results; searches should never produce deleted
	 *  documents. It does apply when you're e.g. iterating over all documents in the index)
	 *
	 * @param doc
	 *            the document id
	 * @return the Lucene Document
	 * @throws RuntimeException if the document doesn't exist (use maxDoc() and isDeleted() to check first!)
	 */
	public abstract Document document(int doc);

	/**
	 * Get a set of all (non-deleted) Lucene document ids.
	 * @return set of ids
	 */
	public abstract Set&lt;Integer&gt; docIdSet();

	/** A task to perform on a Lucene document. */
	public interface LuceneDocTask {
		void perform(Document doc);
	}

	/**
	 * Perform a task on each (non-deleted) Lucene Document.
	 * @param task task to perform
	 */
	public void forEachDocument(LuceneDocTask task) {
<span class="nc bnc" id="L668" title="All 2 branches missed.">		for (Integer docId: docIdSet()) {</span>
<span class="nc" id="L669">			task.perform(document(docId));</span>
<span class="nc" id="L670">		}</span>
<span class="nc" id="L671">	}</span>

	/**
	 * Checks if a document has been deleted from the index
	 * @param doc the document id
	 * @return true iff it has been deleted
	 */
	public abstract boolean isDeleted(int doc);

	/**
	 * Returns one more than the highest document id
	 * @return one more than the highest document id
	 */
	public abstract int maxDoc();

	@Deprecated
	public BLSpanQuery filterDocuments(SpanQuery query, org.apache.lucene.search.Filter filter) {
<span class="nc bnc" id="L688" title="All 2 branches missed.">		if (!(query instanceof BLSpanQuery))</span>
<span class="nc" id="L689">			throw new IllegalArgumentException(&quot;Supplied query must be a BLSpanQuery!&quot;);</span>
<span class="nc" id="L690">		return new SpanQueryFiltered((BLSpanQuery) query, filter);</span>
	}

	@Deprecated
	public BLSpanQuery createSpanQuery(TextPattern pattern, String fieldName, org.apache.lucene.search.Filter filter) {
<span class="pc bpc" id="L695" title="3 of 4 branches missed.">		if (filter == null || filter instanceof org.apache.lucene.search.QueryWrapperFilter) {</span>
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">			Query filterQuery = filter == null ? null : ((org.apache.lucene.search.QueryWrapperFilter) filter).getQuery();</span>
<span class="fc" id="L697">			return createSpanQuery(pattern, fieldName, filterQuery);</span>
		}
<span class="nc" id="L699">		throw new UnsupportedOperationException(&quot;Filter must be a QueryWrapperFilter!&quot;);</span>
	}

	@Deprecated
	public BLSpanQuery createSpanQuery(TextPattern pattern, org.apache.lucene.search.Filter filter) {
<span class="nc" id="L704">		return createSpanQuery(pattern, getMainContentsFieldName(), filter);</span>
	}

	/**
	 * @deprecated use version that takes a filter, and pass null for no filter
	 */
	@SuppressWarnings(&quot;javadoc&quot;)
	@Deprecated
	public BLSpanQuery createSpanQuery(TextPattern pattern, String fieldName) {
<span class="nc" id="L713">		return createSpanQuery(pattern, fieldName, (Query)null);</span>
	}

	/**
	 * @deprecated use version that takes a filter, and pass null for no filter
	 */
	@SuppressWarnings(&quot;javadoc&quot;)
	@Deprecated
	public BLSpanQuery createSpanQuery(TextPattern pattern) {
<span class="nc" id="L722">		return createSpanQuery(pattern, getMainContentsFieldName(), (Query)null);</span>
	}

	public BLSpanQuery createSpanQuery(TextPattern pattern, String fieldName, Query filter) {
		// Convert to SpanQuery
		//pattern = pattern.rewrite();
<span class="fc" id="L728">		BLSpanQuery spanQuery = pattern.translate(getDefaultExecutionContext(fieldName));</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">		if (filter != null)</span>
<span class="fc" id="L730">			spanQuery = new SpanQueryFiltered(spanQuery, filter);</span>
<span class="fc" id="L731">		return spanQuery;</span>
	}

	/**
	 * Find hits for a pattern in a field.
	 *
	 * @param query
	 *            the pattern to find
	 * @param fieldNameConc
	 *            field to use for concordances
	 * @return the hits found
	 * @throws BooleanQuery.TooManyClauses
	 *             if a wildcard or regular expression term is overly broad
	 */
	public Hits find(SpanQuery query, String fieldNameConc) throws BooleanQuery.TooManyClauses {
<span class="nc bnc" id="L746" title="All 2 branches missed.">		if (!(query instanceof BLSpanQuery))</span>
<span class="nc" id="L747">			throw new IllegalArgumentException(&quot;Supplied query must be a BLSpanQuery!&quot;);</span>
<span class="nc" id="L748">		Hits hits = Hits.fromSpanQuery(this, query);</span>
<span class="nc" id="L749">		hits.settings.setConcordanceField(fieldNameConc);</span>
<span class="nc" id="L750">		return hits;</span>
	}

	/**
	 * Find hits for a pattern in a field.
	 *
	 * @param query
	 *            the pattern to find
	 * @return the hits found
	 * @throws BooleanQuery.TooManyClauses
	 *             if a wildcard or regular expression term is overly broad
	 */
	public Hits find(BLSpanQuery query) throws BooleanQuery.TooManyClauses {
<span class="fc" id="L763">		return Hits.fromSpanQuery(this, query);</span>
	}

	/**
	 * Find hits for a pattern in a field.
	 *
	 * @param pattern
	 *            the pattern to find
	 * @param fieldName
	 *            field to find pattern in
	 * @param filter
	 *            determines which documents to search
	 *
	 * @return the hits found
	 * @throws BooleanQuery.TooManyClauses
	 *             if a wildcard or regular expression term is overly broad
	 */
	public Hits find(TextPattern pattern, String fieldName, Query filter)
			throws BooleanQuery.TooManyClauses {
<span class="fc" id="L782">		Hits hits = Hits.fromSpanQuery(this, createSpanQuery(pattern, fieldName, filter));</span>
<span class="fc" id="L783">		hits.settings.setConcordanceField(fieldName);</span>
<span class="fc" id="L784">		return hits;</span>
	}

	public Hits find(TextPattern pattern, Query filter) {
<span class="fc" id="L788">		return find(pattern, getMainContentsFieldName(), filter);</span>
	}

	/**
	 * @deprecated use version that takes a Query as a filter
	 */
	@SuppressWarnings(&quot;javadoc&quot;)
	@Deprecated
	public Hits find(TextPattern pattern, String fieldName, org.apache.lucene.search.Filter filter) {
<span class="nc bnc" id="L797" title="All 4 branches missed.">		if (filter == null || filter instanceof org.apache.lucene.search.QueryWrapperFilter) {</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">			Query filterQuery = filter == null ? null : ((org.apache.lucene.search.QueryWrapperFilter) filter).getQuery();</span>
<span class="nc" id="L799">			return find(createSpanQuery(pattern, fieldName, filterQuery), fieldName);</span>
		}
<span class="nc" id="L801">		throw new UnsupportedOperationException(&quot;Filter must be a QueryWrapperFilter!&quot;);</span>
	}

	/**
	 * Find hits for a pattern and filter them.
	 *
	 * @param pattern
	 *            the pattern to find
	 * @param filter
	 *            determines which documents to search
	 *
	 * @return the hits found
	 * @throws BooleanQuery.TooManyClauses
	 *             if a wildcard or regular expression term is overly broad
	 * @deprecated use version that takes a Query as a filter
	 */
	@Deprecated
	public Hits find(TextPattern pattern, org.apache.lucene.search.Filter filter) throws BooleanQuery.TooManyClauses {
<span class="nc" id="L819">		return find(pattern, getMainContentsFieldName(), filter);</span>
	}

	/**
	 * Find hits for a pattern in a field.
	 *
	 * @param pattern
	 *            the pattern to find
	 * @param fieldName
	 *            which field to find the pattern in
	 *
	 * @return the hits found
	 * @throws BooleanQuery.TooManyClauses
	 *             if a wildcard or regular expression term is overly broad
	 */
	public Hits find(TextPattern pattern, String fieldName) throws BooleanQuery.TooManyClauses {
<span class="nc" id="L835">		return find(pattern, fieldName, null);</span>
	}

	/**
	 * Find hits for a pattern.
	 *
	 * @param pattern
	 *            the pattern to find
	 *
	 * @return the hits found
	 * @throws BooleanQuery.TooManyClauses
	 *             if a wildcard or regular expression term is overly broad
	 */
	public Hits find(TextPattern pattern) throws BooleanQuery.TooManyClauses {
<span class="nc" id="L849">		return find(pattern, getMainContentsFieldName(), null);</span>
	}

	public QueryExplanation explain(TextPattern pattern) throws BooleanQuery.TooManyClauses {
<span class="fc" id="L853">		return explain(pattern, getMainContentsFieldName());</span>
	}

	/**
	 * Explain how a TextPattern is converted to a SpanQuery and rewritten to an
	 * optimized version to be executed by Lucene.
	 *
	 * @param pattern the pattern to explain
	 * @param fieldName which field to find the pattern in
	 * @return the explanation
	 * @throws BooleanQuery.TooManyClauses
	 *             if a wildcard or regular expression term is overly broad
	 */
	public QueryExplanation explain(TextPattern pattern, String fieldName) throws BooleanQuery.TooManyClauses {
<span class="fc" id="L867">		return explain(createSpanQuery(pattern, fieldName, null), fieldName);</span>
	}

	/**
	 * Explain how a SpanQuery is rewritten to an optimized version to be executed by Lucene.
	 *
	 * @param query the query to explain
	 * @param fieldName which field to find the pattern in
	 * @return the explanation
	 * @throws BooleanQuery.TooManyClauses
	 *             if a wildcard or regular expression term is overly broad
	 */
	public QueryExplanation explain(BLSpanQuery query, String fieldName) throws BooleanQuery.TooManyClauses {
		try {
<span class="fc" id="L881">			IndexReader indexReader = getIndexReader();</span>
<span class="fc" id="L882">			return new QueryExplanation(query, query.optimize(indexReader).rewrite(indexReader));</span>
<span class="nc" id="L883">		} catch (IOException e) {</span>
<span class="nc" id="L884">			throw new RuntimeException(e);</span>
		}
	}

	/**
	 * Get character positions from word positions.
	 *
	 * Places character positions in the same arrays as the word positions were specified in.
	 *
	 * @param doc
	 *            the document from which to find character positions
	 * @param fieldName
	 *            the field from which to find character positions
	 * @param startsOfWords
	 *            word positions for which we want starting character positions (i.e. the position
	 *            of the first letter of that word)
	 * @param endsOfWords
	 *            word positions for which we want ending character positions (i.e. the position of
	 *            the last letter of that word)
	 * @param fillInDefaultsIfNotFound
	 *            if true, if any illegal word positions are specified (say, past the end of the
	 *            document), a sane default value is chosen (in this case, the last character of the
	 *            last word found). Otherwise, throws an exception.
	 */
	public abstract void getCharacterOffsets(int doc, String fieldName, int[] startsOfWords, int[] endsOfWords,
			boolean fillInDefaultsIfNotFound);

	public DocContentsFromForwardIndex getContentFromForwardIndex(int docId, String fieldName, int startAtWord, int endAtWord) {
<span class="nc" id="L912">		Hit hit = new Hit(docId, startAtWord, endAtWord);</span>
<span class="nc" id="L913">		Hits hits = Hits.fromList(this, Arrays.asList(hit));</span>
<span class="nc" id="L914">		hits.settings.setConcordanceField(fieldName);</span>
<span class="nc" id="L915">		Kwic kwic = hits.getKwic(hit, 0);</span>
<span class="nc" id="L916">		return kwic.getDocContents();</span>
	}

	/**
	 * Get part of the contents of a field from a Lucene Document.
	 *
	 * This takes into account that some fields are stored externally in content stores
	 * instead of in the Lucene index.
	 *
	 * @param docId
	 *            the Lucene Document id
	 * @param fieldName
	 *            the name of the field
	 * @param startAtChar where to start getting the content (-1 for start of document, 0 for first char)
	 * @param endAtChar where to end getting the content (-1 for end of document)
	 * @return the field content
	 */
	public String getContentByCharPos(int docId, String fieldName, int startAtChar, int endAtChar) {
<span class="nc" id="L934">		Document d = document(docId);</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">		if (!contentStores.exists(fieldName)) {</span>
			// No special content accessor set; assume a stored field
<span class="nc" id="L937">			return d.get(fieldName).substring(startAtChar, endAtChar);</span>
		}
<span class="nc" id="L939">		return contentStores.getSubstrings(fieldName, d, new int[] { startAtChar }, new int[] { endAtChar })[0];</span>
	}

	/**
	 * Get part of the contents of a field from a Lucene Document.
	 *
	 * This takes into account that some fields are stored externally in content stores
	 * instead of in the Lucene index.
	 *
	 * @param docId
	 *            the Lucene Document id
	 * @param fieldName
	 *            the name of the field
	 * @param startAtWord where to start getting the content (-1 for start of document, 0 for first word)
	 * @param endAtWord where to end getting the content (-1 for end of document)
	 * @return the field content
	 */
	public String getContent(int docId, String fieldName, int startAtWord, int endAtWord) {
<span class="nc" id="L957">		Document d = document(docId);</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">		if (!contentStores.exists(fieldName)) {</span>
			// No special content accessor set; assume a stored field
<span class="nc" id="L960">			String content = d.get(fieldName);</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">			if (content == null)</span>
<span class="nc" id="L962">				throw new IllegalArgumentException(&quot;Field not found: &quot; + fieldName);</span>
<span class="nc" id="L963">			return getWordsFromString(content, startAtWord, endAtWord);</span>
		}

<span class="nc" id="L966">		int[] startEnd = startEndWordToCharPos(docId, fieldName, startAtWord, endAtWord);</span>
<span class="nc" id="L967">		return contentStores.getSubstrings(fieldName, d, new int[] { startEnd[0] }, new int[] { startEnd[1] })[0];</span>
	}

	/**
	 * Get character positions from a list of hits.
	 *
	 * @param doc
	 *            the document from which to find character positions
	 * @param fieldName
	 *            the field from which to find character positions
	 * @param hits
	 *            the hits for which we wish to find character positions
	 * @return a list of HitSpan objects containing the character positions for the hits.
	 */
	private List&lt;HitCharSpan&gt; getCharacterOffsets(int doc, String fieldName, Hits hits) {
<span class="nc" id="L982">		int[] starts = new int[hits.size()];</span>
<span class="nc" id="L983">		int[] ends = new int[hits.size()];</span>
<span class="nc" id="L984">		Iterator&lt;Hit&gt; hitsIt = hits.iterator();</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">		for (int i = 0; i &lt; starts.length; i++) {</span>
<span class="nc" id="L986">			Hit hit = hitsIt.next(); // hits.get(i);</span>
<span class="nc" id="L987">			starts[i] = hit.start;</span>
<span class="nc" id="L988">			ends[i] = hit.end - 1; // end actually points to the first word not in the hit, so</span>
									// subtract one
		}

<span class="nc" id="L992">		getCharacterOffsets(doc, fieldName, starts, ends, true);</span>

<span class="nc" id="L994">		List&lt;HitCharSpan&gt; hitspans = new ArrayList&lt;&gt;(starts.length);</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">		for (int i = 0; i &lt; starts.length; i++) {</span>
<span class="nc" id="L996">			hitspans.add(new HitCharSpan(starts[i], ends[i]));</span>
		}
<span class="nc" id="L998">		return hitspans;</span>
	}

	/**
	 * Convert start/end word positions to char positions.
	 *
	 * @param docId     Lucene Document id
	 * @param fieldName name of the field
	 * @param startAtWord where to start getting the content (-1 for start of document, 0 for first word)
	 * @param endAtWord where to end getting the content (-1 for end of document)
	 * @return the start and end char position as a two element int array
	 *   (with any -1's preserved)
	 */
	private int[] startEndWordToCharPos(int docId, String fieldName,
			int startAtWord, int endAtWord) {
<span class="nc bnc" id="L1013" title="All 4 branches missed.">		if (startAtWord == -1 &amp;&amp; endAtWord == -1) {</span>
			// No need to translate anything
<span class="nc" id="L1015">			return new int[] {-1, -1};</span>
		}

		// Translate word pos to char pos and retrieve content
		// NOTE: this boolean stuff is a bit iffy, but is necessary because
		// getCharacterOffsets doesn't handle -1 to mean start/end of doc.
		// We should probably fix that some time.
<span class="nc bnc" id="L1022" title="All 2 branches missed.">		boolean startAtStartOfDoc = startAtWord == -1;</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">		boolean endAtEndOfDoc = endAtWord == -1;</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">		int[] starts = new int[] {startAtStartOfDoc ? 0 : startAtWord};</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">		int[] ends = new int[] {endAtEndOfDoc ? starts[0] : endAtWord};</span>
<span class="nc" id="L1026">		getCharacterOffsets(docId, fieldName, starts, ends, true);</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">		if (startAtStartOfDoc)</span>
<span class="nc" id="L1028">			starts[0] = -1;</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">		if (endAtEndOfDoc)</span>
<span class="nc" id="L1030">			ends[0] = -1;</span>
<span class="nc" id="L1031">		int[] startEnd = new int[] {starts[0], ends[0]};</span>
<span class="nc" id="L1032">		return startEnd;</span>
	}

	/**
	 * Get the contents of a field from a Lucene Document.
	 *
	 * This takes into account that some fields are stored externally in content stores
	 * instead of in the Lucene index.
	 *
	 * @param d
	 *            the Document
	 * @param fieldName
	 *            the name of the field
	 * @return the field content
	 */
	public String getContent(Document d, String fieldName) {
<span class="nc bnc" id="L1048" title="All 2 branches missed.">		if (!contentStores.exists(fieldName)) {</span>
			// No special content accessor set; assume a stored field
<span class="nc" id="L1050">			return d.get(fieldName);</span>
		}
		// Content accessor set. Use it to retrieve the content.
<span class="nc" id="L1053">		return contentStores.getSubstrings(fieldName, d, new int[] { -1 }, new int[] { -1 })[0];</span>
	}

	/**
	 * Get the document contents (original XML).
	 *
	 * @param d
	 *            the Document
	 * @return the field content
	 */
	public String getContent(Document d) {
<span class="nc" id="L1064">		return getContent(d, getMainContentsFieldName());</span>
	}

	/**
	 * Get the contents of a field from a Lucene Document.
	 *
	 * This takes into account that some fields are stored externally in content stores
	 * instead of in the Lucene index.
	 *
	 * @param docId
	 *            the Document id
	 * @param fieldName
	 *            the name of the field
	 * @return the field content
	 */
	public String getContent(int docId, String fieldName) {
<span class="nc" id="L1080">		return getContent(docId, fieldName, -1, -1);</span>
	}

	/**
	 * Get the document contents (original XML).
	 *
	 * @param docId
	 *            the Document id
	 * @return the field content
	 */
	public String getContent(int docId) {
<span class="nc" id="L1091">		return getContent(docId, mainContentsFieldName, -1, -1);</span>
	}

	/**
	 * Get the Lucene index reader we're using.
	 *
	 * @return the Lucene index reader
	 */
	public abstract IndexReader getIndexReader();

	/**
	 * Highlight part of field content with the specified hits,
	 * and make sure it's well-formed.
	 *
	 * Uses &amp;lt;hl&amp;gt;&amp;lt;/hl&amp;gt; tags to highlight the content.
	 *
	 * @param docId
	 *            document to highlight a field from
	 * @param fieldName
	 *            field to highlight
	 * @param hits
	 *            the hits
	 * @param startAtWord where to start highlighting (first word returned)
	 * @param endAtWord where to end highlighting (first word not returned)
	 * @return the highlighted content
	 */
	public String highlightContent(int docId, String fieldName, Hits hits, int startAtWord, int endAtWord) {
		// Get the field content
<span class="nc bnc" id="L1119" title="All 2 branches missed.">		int endAtWordForCharPos = endAtWord &lt; 0 ? endAtWord : endAtWord - 1; // if whole content, don't subtract one</span>
<span class="nc" id="L1120">		int[] startEndCharPos = startEndWordToCharPos(docId, fieldName, startAtWord, endAtWordForCharPos);</span>
<span class="nc" id="L1121">		int startAtChar = startEndCharPos[0];</span>
<span class="nc" id="L1122">		int endAtChar = startEndCharPos[1];</span>
<span class="nc" id="L1123">		String content = getContentByCharPos(docId, fieldName, startAtChar, endAtChar);</span>

<span class="nc bnc" id="L1125" title="All 6 branches missed.">		if (hits == null &amp;&amp; startAtWord == -1 &amp;&amp; endAtWord == -1) {</span>
			// No hits to highlight, and we've fetched the whole document, so it is
			// well-formed already. Just return as-is.
<span class="nc" id="L1128">			return content;</span>
		}

		// Find the character offsets for the hits and highlight
<span class="nc" id="L1132">		List&lt;HitCharSpan&gt; hitspans = null;</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">		if (hits != null) // if hits == null, we still want the highlighter to make it well-formed</span>
<span class="nc" id="L1134">			hitspans = getCharacterOffsets(docId, fieldName, hits);</span>
<span class="nc" id="L1135">		XmlHighlighter hl = new XmlHighlighter();</span>
<span class="nc" id="L1136">		hl.setUnbalancedTagsStrategy(getDefaultUnbalancedTagsStrategy());</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">		if (startAtChar == -1)</span>
<span class="nc" id="L1138">			startAtChar = 0;</span>
<span class="nc" id="L1139">		return hl.highlight(content, hitspans, startAtChar);</span>
	}


	/**
	 * Highlight field content with the specified hits.
	 *
	 * Uses &amp;lt;hl&amp;gt;&amp;lt;/hl&amp;gt; tags to highlight the content.
	 *
	 * @param docId
	 *            document to highlight a field from
	 * @param fieldName
	 *            field to highlight
	 * @param hits
	 *            the hits
	 * @return the highlighted content
	 */
	public String highlightContent(int docId, String fieldName, Hits hits) {
<span class="nc" id="L1157">		return highlightContent(docId, fieldName, hits, -1, -1);</span>
	}

	/**
	 * Highlight field content with the specified hits.
	 *
	 * Uses &amp;lt;hl&amp;gt;&amp;lt;/hl&amp;gt; tags to highlight the content.
	 *
	 * @param docId
	 *            document to highlight a field from
	 * @param hits
	 *            the hits
	 * @return the highlighted content
	 */
	public String highlightContent(int docId, Hits hits) {
<span class="nc" id="L1172">		return highlightContent(docId, getMainContentsFieldName(), hits, -1, -1);</span>
	}

	/**
	 * Get the content store for a field name.
	 *
	 * @param fieldName the field name
	 * @return the content store, or null if there is no content store for this field
	 */
	public ContentStore getContentStore(String fieldName) {
<span class="fc" id="L1182">		synchronized (contentStores) {</span>
<span class="fc" id="L1183">			ContentStore cs = contentStores.get(fieldName);</span>
<span class="pc bpc" id="L1184" title="1 of 4 branches missed.">			if (indexMode &amp;&amp; cs == null) {</span>
				// Index mode. Create new content store or open existing one.
<span class="fc" id="L1186">				return openContentStore(fieldName);</span>
			}
<span class="fc" id="L1188">			return cs;</span>
<span class="nc" id="L1189">		}</span>
	}

	/**
	 * Register a ContentStore as a content accessor.
	 *
	 * This tells the Searcher how the content of different fields may be accessed. This is used for
	 * making concordances, for example. Some fields are stored in the Lucene index, while others
	 * may be stored on the file system, a database, etc.
	 *
	 * A ContentStore is a filesystem-based way to access the contents.
	 *
	 * @param fieldName
	 *            the field for which this is the content accessor
	 * @param contentStore
	 *            the ContentStore object by which to access the content
	 *
	 */
	protected void registerContentStore(String fieldName, ContentStore contentStore) {
<span class="fc" id="L1208">		contentStores.put(fieldName, contentStore);</span>
<span class="fc" id="L1209">	}</span>

	protected abstract ContentStore openContentStore(String fieldName);

	/**
	 * Tries to get the ForwardIndex object for the specified fieldname.
	 *
	 * Looks for an already-opened forward index first. If none is found, and if we're in
	 * &quot;create index&quot; mode, may create a new forward index. Otherwise, looks for an existing forward
	 * index and opens that.
	 *
	 * @param fieldPropName
	 *            the field for which we want the forward index
	 * @return the ForwardIndex if found/created, or null otherwise
	 */
	public ForwardIndex getForwardIndex(String fieldPropName) {
<span class="fc" id="L1225">		synchronized (forwardIndices) {</span>
<span class="fc" id="L1226">			ForwardIndex forwardIndex = forwardIndices.get(fieldPropName);</span>
<span class="fc bfc" id="L1227" title="All 2 branches covered.">			if (forwardIndex == null) {</span>
<span class="fc" id="L1228">				forwardIndex = openForwardIndex(fieldPropName);</span>
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">				if (forwardIndex != null)</span>
<span class="fc" id="L1230">					addForwardIndex(fieldPropName, forwardIndex);</span>
			}
<span class="fc" id="L1232">			return forwardIndex;</span>
<span class="nc" id="L1233">		}</span>
	}

	protected void addForwardIndex(String fieldPropName, ForwardIndex forwardIndex) {
<span class="fc" id="L1237">		forwardIndices.put(fieldPropName, forwardIndex);</span>
<span class="fc" id="L1238">	}</span>

	protected abstract ForwardIndex openForwardIndex(String fieldPropName);

	/**
	 * Get a number of substrings from a certain field in a certain document.
	 *
	 * For larger documents, this is faster than retrieving the whole content first and then cutting
	 * substrings from that.
	 *
	 * @param d
	 *            the document
	 * @param fieldName
	 *            the field
	 * @param starts
	 *            start positions of the substring we want
	 * @param ends
	 *            end positions of the substring we want; correspond to the starts array.
	 * @return the substrings
	 */
	private String[] getSubstringsFromDocument(Document d, String fieldName, int[] starts,
			int[] ends) {
<span class="nc bnc" id="L1260" title="All 2 branches missed.">		if (!contentStores.exists(fieldName)) {</span>
			String[] content;
			// No special content accessor set; assume a non-complex stored field
<span class="nc" id="L1263">			String luceneName = fieldName; // &lt;- non-complex, so this works</span>
<span class="nc" id="L1264">			String fieldContent = d.get(luceneName);</span>
<span class="nc" id="L1265">			content = new String[starts.length];</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">			for (int i = 0; i &lt; starts.length; i++) {</span>
<span class="nc" id="L1267">				content[i] = fieldContent.substring(starts[i], ends[i]);</span>
			}
<span class="nc" id="L1269">			return content;</span>
		}
		// Content accessor set. Use it to retrieve the content.
<span class="nc" id="L1272">		return contentStores.getSubstrings(fieldName, d, starts, ends);</span>
	}

	/**
	 * Determine the concordance strings for a number of concordances, given the relevant character
	 * positions.
	 *
	 * Every concordance requires four character positions: concordance start and end, and hit start
	 * and end. Visualising it ('fox' is the hit word):
	 *
	 * [A] the quick brown [B] fox [C] jumps over the [D]
	 *
	 * The startsOfWords array contains the [A] and [B] positions for each concordance. The
	 * endsOfWords array contains the [C] and [D] positions for each concordance.
	 *
	 * @param doc
	 *            the Lucene document number
	 * @param fieldName
	 *            name of the field
	 * @param startsOfWords
	 *            the array of starts of words ([A] and [B] positions)
	 * @param endsOfWords
	 *            the array of ends of words ([C] and [D] positions)
	 * @param hl
	 * @return the list of concordances
	 */
	public List&lt;Concordance&gt; makeConcordancesFromContentStore(int doc, String fieldName, int[] startsOfWords,
			int[] endsOfWords, XmlHighlighter hl) {
		// Determine starts and ends
<span class="nc" id="L1301">		int n = startsOfWords.length / 2;</span>
<span class="nc" id="L1302">		int[] starts = new int[n];</span>
<span class="nc" id="L1303">		int[] ends = new int[n];</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">		for (int i = 0, j = 0; i &lt; startsOfWords.length; i += 2, j++) {</span>
<span class="nc" id="L1305">			starts[j] = startsOfWords[i];</span>
<span class="nc" id="L1306">			ends[j] = endsOfWords[i + 1];</span>
		}

		// Retrieve 'em all
<span class="nc" id="L1310">		Document d = document(doc);</span>
<span class="nc" id="L1311">		String[] content = getSubstringsFromDocument(d, fieldName, starts, ends);</span>

		// Cut 'em up
<span class="nc" id="L1314">		List&lt;Concordance&gt; rv = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">		for (int i = 0, j = 0; i &lt; startsOfWords.length; i += 2, j++) {</span>
			// Put the concordance in the Hit object
<span class="nc" id="L1317">			int absLeft = startsOfWords[i];</span>
<span class="nc" id="L1318">			int absRight = endsOfWords[i + 1];</span>
<span class="nc" id="L1319">			int relHitLeft = startsOfWords[i + 1] - absLeft;</span>
<span class="nc" id="L1320">			int relHitRight = endsOfWords[i] - absLeft;</span>
<span class="nc" id="L1321">			String currentContent = content[j];</span>

			// Determine context and build concordance.
			// Note that hit text may be empty for hits of length zero,
			// such as a search for open tags (which have a location but zero length,
			// like a search for a word has a length 1)
<span class="nc bnc" id="L1327" title="All 2 branches missed.">			String hitText = relHitRight &lt; relHitLeft ? &quot;&quot; : currentContent.substring(relHitLeft,</span>
					relHitRight);
<span class="nc" id="L1329">			String leftContext = currentContent.substring(0, relHitLeft);</span>
<span class="nc" id="L1330">			String rightContext = currentContent.substring(relHitRight, absRight - absLeft);</span>

			// Make each fragment well-formed
<span class="nc" id="L1333">			hitText = hl.makeWellFormed(hitText);</span>
<span class="nc" id="L1334">			leftContext = hl.makeWellFormed(leftContext);</span>
<span class="nc" id="L1335">			rightContext = hl.makeWellFormed(rightContext);</span>

<span class="nc" id="L1337">			rv.add(new Concordance(new String[] { leftContext, hitText, rightContext }));</span>
		}
<span class="nc" id="L1339">		return rv;</span>
	}


	/**
	 * Indicate how to use the forward indices to build concordances.
	 *
	 * Call this method to set the default for hit sets; call the method in Hits
	 * to change it for a single hit set.
	 *
	 * @param wordFI FI to use as the text content of the &amp;lt;w/&amp;gt; tags (default &quot;word&quot;; null for no text content)
	 * @param punctFI FI to use as the text content between &amp;lt;w/&amp;gt; tags (default &quot;punct&quot;; null for just a space)
	 * @param attrFI FIs to use as the attributes of the &amp;lt;w/&amp;gt; tags (null for all other FIs)
	 * @deprecated use hitsSettings().setConcordanceProperties()
	 */
	@Deprecated
	public void setForwardIndexConcordanceParameters(String wordFI, String punctFI, Collection&lt;String&gt; attrFI) {
<span class="nc" id="L1356">		setConcordanceXmlProperties(wordFI, punctFI, attrFI);</span>
<span class="nc" id="L1357">	}</span>

	/**
	 * Indicate how to use the forward indices to build concordances.
	 *
	 * Only applies if you're building concordances from the forward index.
	 *
	 * Call this method to set the default for hit sets; call the method in Hits
	 * to change it for a single hit set.
	 *
	 * @param wordFI FI to use as the text content of the &amp;lt;w/&amp;gt; tags (default &quot;word&quot;; null for no text content)
	 * @param punctFI FI to use as the text content between &amp;lt;w/&amp;gt; tags (default &quot;punct&quot;; null for just a space)
	 * @param attrFI FIs to use as the attributes of the &amp;lt;w/&amp;gt; tags (null for all other FIs)
	 * @deprecated use hitsSettings().setConcordanceProperties()
	 */
	@Deprecated
	public void setConcordanceXmlProperties(String wordFI, String punctFI,
			Collection&lt;String&gt; attrFI) {
<span class="nc" id="L1375">		hitsSettings().setConcordanceProperties(wordFI, punctFI, attrFI);</span>
<span class="nc" id="L1376">	}</span>


	/**
	 * Get the default context size used for building concordances
	 *
	 * @return the context size
	 * @deprecated use hitsSettings().contextSize()
	 */
	@Deprecated
	public int getDefaultContextSize() {
<span class="nc" id="L1387">		return hitsSettings().contextSize();</span>
	}

	/**
	 * Set the default context size to use for building concordances
	 *
	 * @param defaultContextSize
	 *            the context size
	 * @deprecated use hitsSettings().setContextSize()
	 */
	@Deprecated
	public void setDefaultContextSize(int defaultContextSize) {
<span class="nc" id="L1399">		hitsSettings().setContextSize(defaultContextSize);</span>
<span class="nc" id="L1400">	}</span>

	/**
	 * Factory method to create a directory content store.
	 *
	 * @param indexXmlDir
	 *            the content store directory
	 * @param create if true, create a new content store even if one exists
	 * @return the content store
	 */
	public ContentStore openContentStore(File indexXmlDir, boolean create) {
<span class="fc" id="L1411">		return ContentStore.open(indexXmlDir, create);</span>
	}

	/**
	 * Get the Terms object for the specified field.
	 *
	 * The Terms object is part of the ForwardIndex module and provides a mapping from term id to
	 * term String, and between term id and term sort position. It is used while sorting and
	 * grouping hits (by mapping the context term ids to term sort position ids), and later used to
	 * display the group name (by mapping the sort position ids back to Strings)
	 *
	 * @param fieldPropName
	 *            the field for which we want the Terms object
	 * @return the Terms object
	 * @throws RuntimeException
	 *             if this field does not have a forward index, and hence no Terms object.
	 */
	public Terms getTerms(String fieldPropName) {
<span class="fc" id="L1429">		ForwardIndex forwardIndex = getForwardIndex(fieldPropName);</span>
<span class="pc bpc" id="L1430" title="1 of 2 branches missed.">		if (forwardIndex == null) {</span>
<span class="nc" id="L1431">			throw new IllegalArgumentException(&quot;Field &quot; + fieldPropName + &quot; has no forward index!&quot;);</span>
		}
<span class="fc" id="L1433">		return forwardIndex.getTerms();</span>
	}

	/**
	 * Get the Terms object for the main contents field.
	 *
	 * The Terms object is part of the ForwardIndex module and provides a mapping from term id to
	 * term String, and between term id and term sort position. It is used while sorting and
	 * grouping hits (by mapping the context term ids to term sort position ids), and later used to
	 * display the group name (by mapping the sort position ids back to Strings)
	 *
	 * @return the Terms object
	 * @throws RuntimeException
	 *             if this field does not have a forward index, and hence no Terms object.
	 */
	public Terms getTerms() {
<span class="nc" id="L1449">		return getTerms(ComplexFieldUtil.mainPropertyField(getIndexStructure(), getMainContentsFieldName()));</span>
	}

	public boolean isDefaultSearchCaseSensitive() {
<span class="nc" id="L1453">		return defaultCaseSensitive;</span>
	}

	public boolean isDefaultSearchDiacriticsSensitive() {
<span class="nc" id="L1457">		return defaultDiacriticsSensitive;</span>
	}

	public void setDefaultSearchSensitive(boolean b) {
<span class="nc" id="L1461">		defaultCaseSensitive = defaultDiacriticsSensitive = b;</span>
<span class="nc" id="L1462">	}</span>

	public void setDefaultSearchSensitive(boolean caseSensitive, boolean diacriticsSensitive) {
<span class="nc" id="L1465">		defaultCaseSensitive = caseSensitive;</span>
<span class="nc" id="L1466">		defaultDiacriticsSensitive = diacriticsSensitive;</span>
<span class="nc" id="L1467">	}</span>

	/**
	 * Get the default initial query execution context.
	 *
	 * @param fieldName
	 *            the field to search
	 * @return the query execution context
	 */
	public abstract QueryExecutionContext getDefaultExecutionContext(String fieldName);

	/**
	 * Get the default initial query execution context.
	 *
	 * Uses the default contents field.
	 *
	 * @return the query execution context
	 */
	public QueryExecutionContext getDefaultExecutionContext() {
<span class="nc" id="L1486">		return getDefaultExecutionContext(getMainContentsFieldName());</span>
	}

	public abstract String getIndexName();

	public abstract IndexWriter openIndexWriter(File indexDir, boolean create, Analyzer useAnalyzer)
			throws IOException, CorruptIndexException, LockObtainFailedException;

	public abstract IndexWriter getWriter();

	public abstract File getIndexDirectory();

	/** Deletes documents matching a query from the BlackLab index.
	 *
	 * This deletes the documents from the Lucene index, the forward indices and the content store(s).
	 * @param q the query
	 */
	public abstract void delete(Query q);

	/**
	 * Get the analyzer for indexing and searching.
	 * @return the analyzer
	 */
	public Analyzer getAnalyzer() {
<span class="nc" id="L1510">		return analyzer;</span>
	}

	/**
	 * Perform a document query only (no hits)
	 * @param documentFilterQuery the document-level query
	 * @return the matching documents
	 */
	public DocResults queryDocuments(Query documentFilterQuery) {
<span class="nc" id="L1519">		return DocResults._fromQuery(this, documentFilterQuery);</span>
	}

	/**
	 * Return the list of terms that occur in a field.
	 *
	 * @param fieldName the field
	 * @param maxResults maximum number to return (or HitsSettings.UNLIMITED (== -1) for no limit)
	 * @return the matching terms
	 */
	public abstract List&lt;String&gt; getFieldTerms(String fieldName, int maxResults);

	public String getMainContentsFieldName() {
<span class="fc" id="L1532">		return mainContentsFieldName;</span>
	}

	/**
	 * @return the word property used for concordances
	 * @deprecated use hitsSettings().concWordProp()
	 */
	@Deprecated
	public String getConcWordFI() {
<span class="nc" id="L1541">		return hitsSettings().concWordProp();</span>
	}

	/**
	 * @return the punctuation property used for concordances
	 * @deprecated use hitsSettings().concPunctProp()
	 */
	@Deprecated
	public String getConcPunctFI() {
<span class="nc" id="L1550">		return hitsSettings().concPunctProp();</span>
	}

	/**
	 * @return the extra attribute properties used for concordances
	 * @deprecated use hitsSettings().concAttrProps()
	 */
	@Deprecated
	public Collection&lt;String&gt; getConcAttrFI() {
<span class="nc" id="L1559">		return hitsSettings().concAttrProps();</span>
	}

	public abstract IndexSearcher getIndexSearcher();

	protected void deleteFromForwardIndices(Document d) {
		// Delete this document in all forward indices
<span class="nc bnc" id="L1566" title="All 2 branches missed.">		for (Map.Entry&lt;String, ForwardIndex&gt; e: forwardIndices.entrySet()) {</span>
<span class="nc" id="L1567">			String fieldName = e.getKey();</span>
<span class="nc" id="L1568">			ForwardIndex fi = e.getValue();</span>
<span class="nc" id="L1569">			int fiid = Integer.parseInt(d.get(ComplexFieldUtil</span>
<span class="nc" id="L1570">					.forwardIndexIdField(fieldName)));</span>
<span class="nc" id="L1571">			fi.deleteDocument(fiid);</span>
<span class="nc" id="L1572">		}</span>
<span class="nc" id="L1573">	}</span>

	public Map&lt;String, ForwardIndex&gt; getForwardIndices() {
<span class="fc" id="L1576">		return forwardIndices;</span>
	}

	public boolean canDoNfaMatching() {
<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">		if (forwardIndices.size() == 0)</span>
<span class="nc" id="L1581">			return false;</span>
<span class="fc" id="L1582">		ForwardIndex fi = forwardIndices.values().iterator().next();</span>
<span class="fc" id="L1583">		return fi.canDoNfaMatching();</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>