<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ForwardIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.forwardindex</a> &gt; <span class="el_source">ForwardIndex.java</span></div><h1>ForwardIndex.java</h1><pre class="source lang-java linenums">package nl.inl.blacklab.forwardindex;

import java.io.File;
import java.text.Collator;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import org.apache.lucene.index.IndexReader;

import nl.inl.util.VersionFile;

/**
 * A component that can quickly tell you what word occurs at a specific position of a specific document.
 */
<span class="fc" id="L16">public abstract class ForwardIndex {</span>

	/*
	 * File format version history:
	 * 1. Initial version.
	 * 2. Added sort index to terms file.
	 * 3. New terms and docs file format; added reverse sort index and case-insensitive index to terms file.
	 */

	/**
	 * Indicate how to translate Lucene document ids to forward index ids
	 * (by looking them up in the index).
	 *
	 * Caches the forward index id field.
	 *
	 * @param reader the index
	 * @param lucenePropFieldName the forward index if field
	 */
	public abstract void setIdTranslateInfo(IndexReader reader, String lucenePropFieldName);

	/**
	 * Convert a Lucene document id to the corresponding forward index id.
	 * @param docId the Lucene doc id
	 * @return the forward index id
	 */
	public abstract int luceneDocIdToFiid(int docId);

	/**
	 * Close the forward index.
	 * Writes the table of contents to disk if modified.
	 */
	public abstract void close();

	/**
	 * Store the given content and assign an id to it.
	 *
	 * Note that if more than one token occurs at any position, we only store the first in the
	 * forward index.
	 *
	 * @param content
	 *            the content to store
	 * @param posIncr the associated position increments, or null if position increment is always 1.
	 * @return the id assigned to the content
	 */
	public abstract int addDocument(List&lt;String&gt; content, List&lt;Integer&gt; posIncr);

	/**
	 * Store the given content and assign an id to it
	 *
	 * @param content
	 *            the content to store
	 * @return the id assigned to the content
	 */
	public int addDocument(List&lt;String&gt; content) {
<span class="fc" id="L70">		return addDocument(content, null);</span>
	}

	/**
	 * Delete a document from the forward index
	 *
	 * @param fiid id of the document to delete
	 */
	public abstract void deleteDocument(int fiid);

	/**
	 * Retrieve one or more substrings from the specified content.
	 *
	 * This is more efficient than retrieving the whole content, or retrieving parts in separate
	 * calls, because the file is only opened once and random access is used to read only the
	 * required parts.
	 *
	 * NOTE: if offset and length are both -1, retrieves the whole content. This is used by the
	 * retrieve(id) method.
	 *
	 * @param fiid
	 *            forward index document id
	 * @param start
	 *            the starting points of the substrings (in words)
	 * @param end
	 *            the end points (i.e. first token beyond) of the substrings (in words)
	 * @return the parts
	 * @deprecated use retrievePartsInt and getTerms().get(id)
	 */
	@Deprecated
	public synchronized List&lt;String[]&gt; retrieveParts(int fiid, int[] start, int[] end) {

		// First, retrieve the token ids
<span class="nc" id="L103">		List&lt;int[]&gt; resultInt = retrievePartsInt(fiid, start, end);</span>

		// Translate them to strings using the terms index
<span class="nc" id="L106">		List&lt;String[]&gt; result = new ArrayList&lt;&gt;(resultInt.size());</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">		for (int[] snippetInt: resultInt) {</span>
<span class="nc" id="L108">			String[] snippet = new String[snippetInt.length];</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">			for (int j = 0; j &lt; snippetInt.length; j++) {</span>
<span class="nc" id="L110">				snippet[j] = getTerms().get(snippetInt[j]);</span>
			}
<span class="nc" id="L112">			result.add(snippet);</span>
<span class="nc" id="L113">		}</span>
<span class="nc" id="L114">		return result;</span>
	}

	/**
	 * Retrieve one or more parts from the specified content, in the form of token sort order ids.
	 *
	 * This is more efficient than retrieving the whole content, or retrieving parts in separate
	 * calls, because the file is only opened once and random access is used to read only the
	 * required parts.
	 *
	 * @param fiid
	 *            forward index document id
	 * @param start
	 *            the starting points of the parts to retrieve (in words)
	 * @param end
	 *            the end points (i.e. first token beyond) of the parts to retrieve (in words)
	 * @param sensitive
	 *            whether to get the case-sensitive sort order or not
	 * @return the parts
	 * @deprecated
	 */
	@Deprecated
	public synchronized List&lt;int[]&gt; retrievePartsSortOrder(int fiid, int[] start, int[] end, boolean sensitive) {
		// First, retrieve the token ids
<span class="nc" id="L138">		List&lt;int[]&gt; resultInt = retrievePartsInt(fiid, start, end);</span>

		// Translate them to sort orders
<span class="nc bnc" id="L141" title="All 2 branches missed.">		for (int[] snippetInt: resultInt) {</span>
<span class="nc" id="L142">			getTerms().toSortOrder(snippetInt, snippetInt, sensitive);</span>
<span class="nc" id="L143">		}</span>
<span class="nc" id="L144">		return resultInt;</span>
	}

	/**
	 * Retrieve one or more parts from the specified content, in the form of token ids.
	 *
	 * This is more efficient than retrieving the whole content, or retrieving parts in separate
	 * calls, because the file is only opened once and random access is used to read only the
	 * required parts.
	 *
	 * NOTE: if offset and length are both -1, retrieves the whole content. This is used by the
	 * retrieve(id) method.
	 *
	 * NOTE2: Mapped file IO on Windows has some issues that sometimes cause an OutOfMemoryError on
	 * the FileChannel.map() call (which makes no sense, because memory mapping only uses address
	 * space, it doesn't try to read the whole file). Possibly this could be solved by using 64-bit
	 * Java, but we haven't tried. For now we just disable memory mapping on Windows.
	 *
	 * @param fiid
	 *            forward index document id
	 * @param start
	 *            the starting points of the parts to retrieve (in words)
	 *            (-1 for start of document)
	 * @param end
	 *            the end points (i.e. first token beyond) of the parts to retrieve (in words)
	 *            (-1 for end of document)
	 * @return the parts
	 */
	public abstract List&lt;int[]&gt; retrievePartsInt(int fiid, int[] start, int[] end);

	/**
	 * Get the Terms object in order to translate ids to token strings
	 * @return the Terms object
	 */
	public abstract Terms getTerms();

	/**
	 * @return the number of documents in the forward index
	 */
	public abstract int getNumDocs();

	/**
	 * @return the amount of space in free blocks in the forward index.
	 */
	public abstract long getFreeSpace();

	/**
	 * @return the number of free blocks in the forward index.
	 */
	public abstract int getFreeBlocks();

	/**
	 * @return total size in bytes of the tokens file.
	 */
	public abstract long getTotalSize();

	/**
	 * Gets the length (in tokens) of a document
	 * @param fiid forward index id of a document
	 * @return length of the document
	 */
	public abstract int getDocLength(int fiid);

	/**
	 * Current forward index format version
	 */
	private static final String CURRENT_VERSION = &quot;5&quot;;

	/** Different versions of insensitive collator */
<span class="pc" id="L213">	public static enum CollatorVersion {</span>
<span class="fc" id="L214">		V1,  // ignored dash and space</span>
<span class="fc" id="L215">		V2   // doesn't ignore dash and space</span>
	}

	/**
	 * Open a forward index.
	 *
	 * Automatically figures out the forward index version and
	 * instantiates the right class.
	 *
	 * @param dir forward index directory
	 * @param indexMode true iff we're in index mode (writing to
	 *   the forward index); otherwise it will be read-only.
	 * @param collator collator to use for sorting
	 * @param create if true, create a new forward index
	 * @return the forward index object
	 */
	public static ForwardIndex open(File dir, boolean indexMode, Collator collator, boolean create) {

<span class="fc bfc" id="L233" title="All 2 branches covered.">		if (!dir.exists()) {</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">			if (!create)</span>
<span class="nc" id="L235">				throw new IllegalArgumentException(&quot;ForwardIndex doesn't exist: &quot; + dir);</span>
<span class="fc" id="L236">			dir.mkdir();</span>
		}

		// Version check
<span class="fc" id="L240">		String version = CURRENT_VERSION;</span>
<span class="pc bpc" id="L241" title="1 of 4 branches missed.">		if (!indexMode || !create) {</span>
			// We're opening an existing forward index. Check version.
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">			if (!VersionFile.isTypeVersion(dir, &quot;fi&quot;, CURRENT_VERSION)) {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">				if (VersionFile.isTypeVersion(dir, &quot;fi&quot;, &quot;4&quot;)) {</span>
<span class="nc" id="L245">					version = &quot;4&quot;;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">				} else if (VersionFile.isTypeVersion(dir, &quot;fi&quot;, &quot;3&quot;)) {</span>
<span class="nc" id="L247">					version = &quot;3&quot;;</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">				} else if (VersionFile.isTypeVersion(dir, &quot;fi&quot;, &quot;2&quot;)) {</span>
<span class="nc" id="L249">					version = &quot;2&quot;;</span>
				} else {
<span class="nc" id="L251">					throw new IllegalArgumentException(&quot;Not a forward index or wrong version: &quot;</span>
<span class="nc" id="L252">							+ VersionFile.report(dir) + &quot; (fi &quot; + CURRENT_VERSION + &quot; expected)&quot;);</span>
				}
			}
		} else {
			// We're creating a forward index. Write version.
<span class="fc" id="L257">			VersionFile.write(dir, &quot;fi&quot;, CURRENT_VERSION);</span>
		}

		ForwardIndex fi;
<span class="fc" id="L261">		boolean largeTermsFileSupport = true;</span>
<span class="fc" id="L262">		CollatorVersion collVersion = CollatorVersion.V2;</span>
<span class="pc bpc" id="L263" title="14 of 17 branches missed.">		switch(version) {</span>
		case &quot;2&quot;:
<span class="nc" id="L265">			throw new UnsupportedOperationException(&quot;Forward index version (2) too old for this BlackLab version. Please re-index.&quot;);</span>
		case &quot;3&quot;:
<span class="nc" id="L267">			largeTermsFileSupport = false;</span>
<span class="nc" id="L268">			collVersion = CollatorVersion.V1;</span>
<span class="nc" id="L269">			break;</span>
		case &quot;4&quot;:
<span class="nc" id="L271">			collVersion = CollatorVersion.V1;</span>
<span class="nc" id="L272">			break;</span>
		case &quot;5&quot;:
			break;
		}
<span class="fc" id="L276">		Collators collators = new Collators(collator, collVersion);</span>
<span class="fc" id="L277">		fi = new ForwardIndexImplV3(dir, indexMode, collators, create, largeTermsFileSupport);</span>
<span class="fc" id="L278">		return fi;</span>
	}

	protected abstract void setLargeTermsFileSupport(boolean b);

	/** @return the set of all forward index ids */
	public abstract Set&lt;Integer&gt; idSet();

	/** A task to perform on a document in the forward index. */
	public interface ForwardIndexDocTask {
		public abstract void perform(int fiid, int[] tokenIds);
	}

	/** Perform a task on each document in the forward index.
	 * @param task the task to perform
	 */
	public void forEachDocument(ForwardIndexDocTask task) {
<span class="nc bnc" id="L295" title="All 2 branches missed.">		for (Integer fiid: idSet()) {</span>
<span class="nc" id="L296">			int[] tokenIds = retrievePartsInt(fiid, new int[] {-1}, new int[] {-1}).get(0);</span>
<span class="nc" id="L297">			task.perform(fiid, tokenIds);</span>
<span class="nc" id="L298">		}</span>
<span class="nc" id="L299">	}</span>

	public int getToken(int fiid, int pos) {
		// Slow/naive implementation, subclasses should override
<span class="nc" id="L303">		return retrievePartsInt(fiid, new int[] {pos}, new int[] {pos + 1}).get(0)[0];</span>
	}

	public abstract boolean canDoNfaMatching();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>