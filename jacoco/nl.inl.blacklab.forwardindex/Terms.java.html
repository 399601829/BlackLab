<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Terms.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.forwardindex</a> &gt; <span class="el_source">Terms.java</span></div><h1>Terms.java</h1><pre class="source lang-java linenums">package nl.inl.blacklab.forwardindex;

import java.io.File;
import java.nio.charset.Charset;

import org.eclipse.collections.api.set.primitive.MutableIntSet;

/**
 * Keeps a list of unique terms and their sort positions.
 */
<span class="fc" id="L11">public abstract class Terms {</span>

	public static final int NO_TERM = -1;

<span class="fc" id="L15">	static final Charset DEFAULT_CHARSET = Charset.forName(&quot;utf-8&quot;);</span>

	/**
	 * Get the existing index number of a term, or add it to the term list
	 * and assign it a new index number.
	 *
	 * In index mode, this is fast. In search mode, this is slower, because
	 * we have to do a binary search through the memory-mapped terms file.
	 * However, this is only done rarely.
	 *
	 * If you care about this being fast, call
	 * buildTermIndex() at the start of your application.
	 *
	 * @param term the term to get the index number for
	 * @return the term's index number
	 */
	public abstract int indexOf(String term);

	/**
	 * Get the index number(s) of terms matching a string.
	 *
	 * This is used in search mode when translating queries into NFAs. Depending on
	 * case-sensitivity settings, a single term string may match multiple terms.
	 *
	 * @param results (out) index numbers for the matching term(s)
	 * @param term the term to get the index number for
	 * @param caseSensitive compare case-sensitively? (currently switches both case- and diacritics-sensitivity)
	 * @param diacSensitive compare diacritics-sensitively? (currently ignored)
	 */
	public abstract void indexOf(MutableIntSet results, String term, boolean caseSensitive, boolean diacSensitive);

	/**
	 * Build the index from term to term id. Depending on the terms
	 * implementation, this may speed up the first call to indexOf().
	 */
	public void buildTermIndex() {
		// May be implemented by child class
<span class="nc" id="L52">	}</span>

	/**
	 * Clear the Terms object.
	 */
	public abstract void clear();

	/**
	 * Write the terms file
	 * @param termsFile where to write the terms file
	 */
	public abstract void write(File termsFile);

	/**
	 * Get a term by id. Only works in search mode.
	 * @param id the term id
	 * @return the corresponding term
	 */
	public abstract String get(Integer id);

	/**
	 * @return the number of terms in this object
	 */
	public abstract int numberOfTerms();

	/**
	 * Get the sort position for a term based on its term id
	 * @param id the term id
	 * @param sensitive whether we want the sensitive or insensitive sort position
	 * @return the sort position
	 */
	public abstract int idToSortPosition(int id, boolean sensitive);

	/**
	 * Convert an array of term ids to sort positions
	 * @param termId the term ids
	 * @param sortOrder the sort positions
	 * @param sensitive whether we want the sensitive or insensitive sort positions
	 */
	public void toSortOrder(int[] termId, int[] sortOrder, boolean sensitive) {
<span class="nc bnc" id="L92" title="All 2 branches missed.">		for (int i = 0; i &lt; termId.length; i++) {</span>
<span class="nc" id="L93">			sortOrder[i] = idToSortPosition(termId[i], sensitive);</span>
		}
<span class="nc" id="L95">	}</span>

	/**
	 * Compare two terms (from their term ids) based on their sort positions
	 * @param termId1 id of the first term
	 * @param termId2 id of the second term
	 * @param sensitive whether we want to compare sensitively or insensitively
	 * @return the comparison result (negative if term1 &lt; term2, zero if equal, positive if term1 &gt; term2)
	 */
	public int compareSortPosition(int termId1, int termId2, boolean sensitive) {
<span class="nc" id="L105">		return idToSortPosition(termId1, sensitive) - idToSortPosition(termId2, sensitive);</span>
	}

	protected abstract void setBlockBasedFile(boolean useBlockBasedTermsFile);

	public static Terms open(boolean indexMode, Collators collators, File termsFile, boolean useBlockBasedTermsFile) {
<span class="fc" id="L111">		return new TermsImplV3(indexMode, collators, termsFile, useBlockBasedTermsFile);</span>
	}

	public abstract boolean termsEqual(int[] termId, boolean caseSensitive, boolean diacSensitive);

    public int deserializeToken(String term) {
        int termId;
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (term.equals(&quot;~&quot;))</span>
<span class="fc" id="L119">            termId = Terms.NO_TERM; // no token, effectively a &quot;null&quot; value</span>
        else {
<span class="fc bfc" id="L121" title="All 2 branches covered.">            if (term.startsWith(&quot;~~&quot;)) {</span>
                // tilde in first position has to be escaped
                // because of how null value is encoded
<span class="fc" id="L124">                term = term.substring(1);</span>
            }
<span class="fc" id="L126">            termId = indexOf(term);</span>
        }
<span class="fc" id="L128">        return termId;</span>
    }

    public String serializeTerm(int valueTokenId) {
        String token;
<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (valueTokenId &lt; 0)</span>
<span class="fc" id="L134">            token = &quot;~&quot;; // no token, effectively a &quot;null&quot; value</span>
        else {
<span class="fc" id="L136">            token = get(valueTokenId);</span>
<span class="fc bfc" id="L137" title="All 4 branches covered.">            if (token.length() &gt; 0 &amp;&amp; token.charAt(0) == '~') {</span>
                // tilde in first position has to be escaped
                // because of how null value is encoded
<span class="fc" id="L140">                token = &quot;~&quot; + token;</span>
            }
        }
<span class="fc" id="L143">        return token;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>