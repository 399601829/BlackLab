<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DocIndexer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.index</a> &gt; <span class="el_source">DocIndexer.java</span></div><h1>DocIndexer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2010, 2012 Institute for Dutch Lexicology
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package nl.inl.blacklab.index;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.Field.Store;
import org.apache.lucene.document.IntField;

import nl.inl.blacklab.index.complex.ComplexFieldProperty.SensitivitySetting;
import nl.inl.blacklab.index.complex.ComplexFieldUtil;
import nl.inl.blacklab.search.BLRuntimeException;
import nl.inl.blacklab.search.indexstructure.FieldType;
import nl.inl.blacklab.search.indexstructure.IndexStructure;
import nl.inl.blacklab.search.indexstructure.MetadataFieldDesc;
import nl.inl.util.UnicodeStream;

/**
 * Indexes a file.
 */
<span class="fc" id="L52">public abstract class DocIndexer implements AutoCloseable {</span>

<span class="fc" id="L54">    protected static final Logger logger = LogManager.getLogger(DocIndexer.class);</span>

    protected Indexer indexer;

    /** Do we want to omit norms? (Default: yes) */
<span class="fc" id="L59">    protected boolean omitNorms = true;</span>

    /**
     * File we're currently parsing. This can be useful for storing the original filename in the
     * index.
     */
    protected String documentName;

    /**
     * The Lucene Document we're currently constructing (corresponds to the
     * document we're indexing)
     */
    protected Document currentLuceneDoc;

    /**
     * Parameters passed to this indexer
     */
<span class="fc" id="L76">    protected Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;();</span>

<span class="fc" id="L78">    Set&lt;String&gt; numericFields = new HashSet&lt;&gt;();</span>

    public Document getCurrentLuceneDoc() {
<span class="nc" id="L81">        return currentLuceneDoc;</span>
    }

	/**
	 * Thrown when the maximum number of documents has been reached
	 */
<span class="nc" id="L87">	public static class MaxDocsReachedException extends BLRuntimeException {</span>
		//
	}

    /**
     * Returns our Indexer object
     * @return the Indexer object
     */
    public Indexer getIndexer() {
<span class="nc" id="L96">        return indexer;</span>
    }

    /**
     * Set the indexer object. Called by Indexer when the DocIndexer is instantiated.
     *
     * @param indexer our indexer object
     */
    public void setIndexer(Indexer indexer) {
<span class="fc" id="L105">        this.indexer = indexer;</span>

<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if (indexer != null) {</span>
            // Get our parameters from the indexer
<span class="fc" id="L109">            Map&lt;String, String&gt; indexerParameters = indexer.getIndexerParameters();</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">            if (indexerParameters != null)</span>
<span class="nc" id="L111">                setParameters(indexerParameters);</span>
        }
<span class="fc" id="L113">    }</span>

    /**
     * Set the file name of the document to index.
     *
     * @param documentName name of the document
     */
    public void setDocumentName(String documentName) {
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        this.documentName = documentName == null ? &quot;?&quot; : documentName;</span>
<span class="fc" id="L122">    }</span>

    /**
     * Set the document to index.
     *
     * NOTE: you should generally prefer calling the File or byte[] versions
     * of this method, as those can be more efficient (e.g. when using DocIndexer that
     * parses using VTD-XML).
     *
     * @param reader document
     */
	public abstract void setDocument(Reader reader);

    /**
     * Set the document to index.
     *
     * @param is document contents
     * @param cs charset to use if no BOM found, or null for the default (utf-8)
     */
    public void setDocument(InputStream is, Charset cs) {
        try {
<span class="nc" id="L143">            setDocument(new InputStreamReader(new UnicodeStream(is, cs)));</span>
<span class="nc" id="L144">        } catch (IOException e) {</span>
<span class="nc" id="L145">            throw new RuntimeException(e);</span>
<span class="nc" id="L146">        }</span>
<span class="nc" id="L147">    }</span>

    /**
     * Set the document to index.
     *
     * @param contents document contents
     * @param cs charset to use if no BOM found, or null for the default (utf-8)
     */
    public void setDocument(byte[] contents, Charset cs) {
<span class="nc" id="L156">        setDocument(new ByteArrayInputStream(contents), cs);</span>
<span class="nc" id="L157">    }</span>

    /**
     * Set the document to index.
     *
     * @param file file to index
     * @param charset charset to use if no BOM found, or null for the default (utf-8)
     * @throws FileNotFoundException if not found
     */
    public void setDocument(File file, Charset charset) throws FileNotFoundException {
<span class="nc" id="L167">        setDocument(new FileInputStream(file), charset);</span>
<span class="nc" id="L168">    }</span>

    /**
	 * Index documents contained in a file.
	 *
	 * @throws Exception
	 */
	public abstract void index() throws Exception;

    /**
     * Check if the specified parameter has a value
     * @param name parameter name
     * @return true iff the parameter has a value
     * @deprecated use a DocIndexerConfig-based indexer
     */
    @Deprecated
    public boolean hasParameter(String name) {
<span class="nc" id="L185">        return parameters.containsKey(name);</span>
    }

    /**
     * Set a parameter for this indexer (such as which type of metadata block to process)
     * @param name parameter name
     * @param value parameter value
     * @deprecated use a DocIndexerConfig-based indexer
     */
    @Deprecated
    public void setParameter(String name, String value) {
<span class="nc" id="L196">        parameters.put(name, value);</span>
<span class="nc" id="L197">    }</span>

    /**
     * Set a number of parameters for this indexer
     * @param param the parameter names and values
     * @deprecated use a DocIndexerConfig-based indexer
     */
    @Deprecated
    public void setParameters(Map&lt;String, String&gt; param) {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; e: param.entrySet()) {</span>
<span class="nc" id="L207">            parameters.put(e.getKey(), e.getValue());</span>
<span class="nc" id="L208">        }</span>
<span class="nc" id="L209">    }</span>

    /**
     * Get a parameter that was set for this indexer
     * @param name parameter name
     * @param defaultValue parameter default value
     * @return the parameter value (or the default value if it was not specified)
     * @deprecated use ConfigInputFormat, IndexStructure
     */
    @Deprecated
    public String getParameter(String name, String defaultValue) {
<span class="fc" id="L220">        String value = parameters.get(name);</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (value == null)</span>
<span class="fc" id="L222">            return defaultValue;</span>
<span class="nc" id="L223">        return value;</span>
    }

    /**
     * Get a parameter that was set for this indexer
     * @param name parameter name
     * @return the parameter value (or null if it was not specified)
     * @deprecated use a DocIndexerConfig-based indexer
     */
    @Deprecated
    public String getParameter(String name) {
<span class="fc" id="L234">        return getParameter(name, null);</span>
    }

    /**
     * Get a parameter that was set for this indexer
     * @param name parameter name
     * @param defaultValue parameter default value
     * @return the parameter value (or the default value if it was not specified)
     * @deprecated use a DocIndexerConfig-based indexer
     */
    @Deprecated
    public boolean getParameter(String name, boolean defaultValue) {
<span class="nc" id="L246">        String value = parameters.get(name);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (value == null)</span>
<span class="nc" id="L248">            return defaultValue;</span>
<span class="nc" id="L249">        value = value.trim().toLowerCase();</span>
<span class="nc bnc" id="L250" title="All 6 branches missed.">        return value.equals(&quot;true&quot;) || value.equals(&quot;1&quot;) || value.equals(&quot;yes&quot;);</span>
    }

    /**
     * Get a parameter that was set for this indexer
     * @param name parameter name
     * @param defaultValue parameter default value
     * @return the parameter value (or the default value if it was not specified)
     * @deprecated use a DocIndexerConfig-based indexer
     */
    @Deprecated
    public int getParameter(String name, int defaultValue) {
<span class="nc" id="L262">        String value = parameters.get(name);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (value == null)</span>
<span class="nc" id="L264">            return defaultValue;</span>
        try {
<span class="nc" id="L266">            return Integer.parseInt(value);</span>
<span class="nc" id="L267">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L268">            return defaultValue;</span>
        }
    }

    protected boolean tokenizeField(String name) {
        // (Also check the old (Lucene 3.x) term, &quot;analyzed&quot;)
<span class="nc bnc" id="L274" title="All 2 branches missed.">        String parName = hasParameter(name + &quot;_tokenized&quot;) ? name + &quot;_tokenized&quot; : name + &quot;_analyzed&quot;;</span>
<span class="nc" id="L275">        return getParameter(parName, true);</span>
    }

    /**
     * Return the fieldtype to use for the specified field.
     * @param fieldName the field name
     * @return the fieldtype
     * @deprecated use a DocIndexerConfig-based indexer
     */
    @Deprecated
    public FieldType getMetadataFieldTypeFromIndexerProperties(String fieldName) {
        // (Also check the old (Lucene 3.x) term, &quot;analyzed&quot;)
<span class="nc bnc" id="L287" title="All 2 branches missed.">        String parName = hasParameter(fieldName + &quot;_tokenized&quot;) ? fieldName + &quot;_tokenized&quot; : fieldName + &quot;_analyzed&quot;;</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (getParameter(parName, true))</span>
<span class="nc" id="L289">            return FieldType.TOKENIZED;</span>
<span class="nc" id="L290">        return FieldType.UNTOKENIZED;</span>
    }

    protected org.apache.lucene.document.FieldType luceneTypeFromIndexStructType(FieldType type) {
<span class="nc bnc" id="L294" title="All 4 branches missed.">        switch (type) {</span>
        case NUMERIC:
<span class="nc" id="L296">            throw new IllegalArgumentException(&quot;Numeric types should be indexed using IntField, etc.&quot;);</span>
        case TOKENIZED:
<span class="nc" id="L298">            return indexer.getMetadataFieldType(true);</span>
        case UNTOKENIZED:
<span class="nc" id="L300">            return indexer.getMetadataFieldType(false);</span>
        default:
<span class="nc" id="L302">            throw new IllegalArgumentException(&quot;Unknown field type: &quot; + type);</span>
        }
    }

    /**
     * Enables or disables norms. Norms are disabled by default.
     *
     * The method name was chosen to match Lucene's Field.setOmitNorms().
     * Norms are only required if you want to use document-length-normalized scoring.
     *
     * @param b if true, doesn't store norms; if false, does store norms
     */
    public void setOmitNorms(boolean b) {
<span class="nc" id="L315">        omitNorms = b;</span>
<span class="nc" id="L316">    }</span>

    public void addNumericFields(Collection&lt;String&gt; fields) {
<span class="nc" id="L319">        numericFields.addAll(fields);</span>
<span class="nc" id="L320">    }</span>

    boolean continueIndexing() {
<span class="nc" id="L323">        return indexer.continueIndexing();</span>
    }

    protected void warn(String msg) {
<span class="nc" id="L327">        indexer.getListener().warning(msg);</span>
<span class="nc" id="L328">    }</span>

    public void addMetadataField(String name, String value) {
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (!ComplexFieldUtil.isValidXmlElementName(name))</span>
<span class="nc" id="L332">            logger.warn(&quot;Field name '&quot; + name + &quot;' is discouraged (field/property names should be valid XML element names)&quot;);</span>

<span class="nc bnc" id="L334" title="All 4 branches missed.">        if (name == null || value == null)</span>
<span class="nc" id="L335">            warn(&quot;Incomplete metadata field: &quot; + name + &quot;=&quot; + value);</span>

<span class="nc" id="L337">        IndexStructure struct = indexer.getSearcher().getIndexStructure();</span>
<span class="nc" id="L338">        struct.registerMetadataField(name);</span>

<span class="nc" id="L340">        MetadataFieldDesc desc = struct.getMetadataFieldDesc(name);</span>
<span class="nc" id="L341">        FieldType type = desc.getType();</span>
<span class="nc" id="L342">        desc.addValue(value);</span>

        // There used to be another way of specifying metadata field type,
        // via indexer.properties. This is still supported, but deprecated.
<span class="nc" id="L346">        FieldType shouldBeType = getMetadataFieldTypeFromIndexerProperties(name);</span>
<span class="nc bnc" id="L347" title="All 4 branches missed.">        if (type == FieldType.TOKENIZED</span>
                &amp;&amp; shouldBeType != FieldType.TOKENIZED) {
            // indexer.properties overriding default type
<span class="nc" id="L350">            type = shouldBeType;</span>
        }

<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (type != FieldType.NUMERIC) {</span>
<span class="nc" id="L354">            currentLuceneDoc.add(new Field(name, value, luceneTypeFromIndexStructType(type)));</span>
        }
<span class="nc bnc" id="L356" title="All 4 branches missed.">        if (type == FieldType.NUMERIC || numericFields.contains(name)) {</span>
<span class="nc" id="L357">            String numFieldName = name;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (type != FieldType.NUMERIC) {</span>
<span class="nc" id="L359">                numFieldName += &quot;Numeric&quot;;</span>
            }
            // Index these fields as numeric too, for faster range queries
            // (we do both because fields sometimes aren't exclusively numeric)
<span class="nc" id="L363">            int n = 0;</span>
            try {
<span class="nc" id="L365">                n = Integer.parseInt(value);</span>
<span class="nc" id="L366">            } catch (NumberFormatException e) {</span>
                // This just happens sometimes, e.g. given multiple years, or
                // descriptive text like &quot;around 1900&quot;. OK to ignore.
<span class="nc" id="L369">            }</span>
<span class="nc" id="L370">            IntField nf = new IntField(numFieldName, n, Store.YES);</span>
<span class="nc" id="L371">            currentLuceneDoc.add(nf);</span>
        }
<span class="nc" id="L373">    }</span>

    /**
     * If any metadata fields were supplied in the indexer parameters,
     * add them now.
     *
     * NOTE: we always add these untokenized (because they're usually just
     * indications of which data set a set of files belongs to), but that
     * means they don't get lowercased or de-accented. Because metadata queries
     * are always desensitized, you can't use uppercase or accented letters in
     * these values or they will never be found. This should be addressed.
     */
    protected void addMetadataFieldsFromParameters() {
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        for (Entry&lt;String, String&gt; e: parameters.entrySet()) {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (e.getKey().startsWith(&quot;meta-&quot;)) {</span>
<span class="nc" id="L388">                String fieldName = e.getKey().substring(5);</span>
<span class="nc" id="L389">                String fieldValue = e.getValue();</span>
<span class="nc" id="L390">                currentLuceneDoc.add(new Field(fieldName, fieldValue, indexer.getMetadataFieldType(false)));</span>
            }
<span class="nc" id="L392">        }</span>
<span class="fc" id="L393">    }</span>

    @Deprecated
    public SensitivitySetting getSensitivitySetting(String propName) {
        // See if it's specified in a parameter
<span class="fc" id="L398">        String strSensitivity = getParameter(propName + &quot;_sensitivity&quot;);</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">        if (strSensitivity != null) {</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">            if (strSensitivity.equals(&quot;i&quot;))</span>
<span class="nc" id="L401">                return SensitivitySetting.ONLY_INSENSITIVE;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if (strSensitivity.equals(&quot;s&quot;))</span>
<span class="nc" id="L403">                return SensitivitySetting.ONLY_SENSITIVE;</span>
<span class="nc bnc" id="L404" title="All 4 branches missed.">            if (strSensitivity.equals(&quot;si&quot;) || strSensitivity.equals(&quot;is&quot;))</span>
<span class="nc" id="L405">                return SensitivitySetting.SENSITIVE_AND_INSENSITIVE;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            if (strSensitivity.equals(&quot;all&quot;))</span>
<span class="nc" id="L407">                return SensitivitySetting.CASE_AND_DIACRITICS_SEPARATE;</span>
        }

        // Not in parameter (or unrecognized value), use default based on
        // propName
<span class="fc bfc" id="L412" title="All 2 branches covered.">        if (propName.equals(ComplexFieldUtil.getDefaultMainPropName())</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">                || propName.equals(ComplexFieldUtil.LEMMA_PROP_NAME)) {</span>
            // Word: default to sensitive/insensitive
<span class="fc" id="L415">            return SensitivitySetting.SENSITIVE_AND_INSENSITIVE;</span>
        }
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (propName.equals(ComplexFieldUtil.PUNCTUATION_PROP_NAME)) {</span>
            // Punctuation: default to only insensitive
<span class="fc" id="L419">            return SensitivitySetting.ONLY_INSENSITIVE;</span>
        }
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">        if (propName.equals(ComplexFieldUtil.START_TAG_PROP_NAME)</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                || propName.equals(ComplexFieldUtil.END_TAG_PROP_NAME)) {</span>
            // XML tag properties: default to only sensitive
<span class="fc" id="L424">            return SensitivitySetting.ONLY_SENSITIVE;</span>
        }

        // Unrecognized; default to only insensitive
<span class="nc" id="L428">        return SensitivitySetting.ONLY_INSENSITIVE;</span>
    }

	protected abstract int getCharacterPosition();

    /**
     * Report the amount of new characters processed since the last call
     */
    public abstract void reportCharsProcessed();

    /**
     * Report the amounf of new tokens processed since the last call
     */
    public abstract void reportTokensProcessed();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>