<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DocumentFormats.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.index</a> &gt; <span class="el_source">DocumentFormats.java</span></div><h1>DocumentFormats.java</h1><pre class="source lang-java linenums">package nl.inl.blacklab.index;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.Reader;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;

import nl.inl.blacklab.index.DocIndexerFactory.Format;
import nl.inl.blacklab.index.config.ConfigInputFormat;
import nl.inl.blacklab.index.config.InputFormatConfigException;

/**
 * Document format registry, for resolving a DocIndexer class given a
 * format identifier (common abbreviation or (qualified) class name).
 */
<span class="nc" id="L21">public class DocumentFormats {</span>

<span class="fc" id="L23">	private static final List&lt;DocIndexerFactory&gt; factories = new ArrayList&lt;&gt;();</span>

	// We keep a handle to these factories to allow programs on top of blacklab to easily add
	// new configs and DocIndexer classes through the DocumentFormats class instead of
	// requiring them to always register a new factory for the format
	private static final DocIndexerFactoryClass builtinClassFactory;
	private static final DocIndexerFactoryConfig builtinConfigFactory;

    static {
<span class="fc" id="L32">		builtinClassFactory = new DocIndexerFactoryClass();</span>
<span class="fc" id="L33">		builtinConfigFactory = new DocIndexerFactoryConfig();</span>

		// Last registered factory has priority (to allow users to override types)
		// So register config-based factory after class-based factory
<span class="fc" id="L37">		registerFactory(builtinClassFactory);</span>
<span class="fc" id="L38">		registerFactory(builtinConfigFactory);</span>
<span class="fc" id="L39">    }</span>

    /**
     * Register a new factory.
     * Factories are responsible for creating the docIndexer instances that will perform the indexing of documents.
     * newer factories have priority over older factories in case of name conflicts.
     *
     * If an exception occurs during initialization of the factory, the factory will not be added, and the exception is rethrown.
     * @param fac
     * @throws RuntimeException rethrows exceptions occuring during factory initialization
     */
    public static void registerFactory(DocIndexerFactory fac) {
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">    	if (factories.contains(fac))</span>
<span class="nc" id="L52">    		return;</span>

    	try {
<span class="fc" id="L55">    		factories.add(fac);</span>
<span class="fc" id="L56">    		fac.init();</span>
<span class="nc" id="L57">    	} catch (Exception e) {</span>
<span class="nc" id="L58">    		factories.remove(fac);</span>
<span class="nc" id="L59">    		throw e;</span>
<span class="fc" id="L60">    	}</span>
<span class="fc" id="L61">    }</span>

    // Convenience method to avoid applications always having to create a DocIndexerFactory instance
    public static void registerFormat(String formatIdentifier, Class&lt;? extends DocIndexerAbstract&gt; docIndexerClass) {
<span class="fc" id="L65">    	builtinClassFactory.addFormat(formatIdentifier, docIndexerClass);</span>
<span class="fc" id="L66">    }</span>

    // Convenience method to avoid applications always having to create a DocIndexerFactory instance
    public static void registerFormat(ConfigInputFormat config) {
<span class="nc" id="L70">    	builtinConfigFactory.addFormat(config);</span>
<span class="nc" id="L71">    }</span>

    // Convenience method to avoid applications always having to create a DocIndexerFactory instance
    public static void registerFormatsInDirectories(List&lt;File&gt; dirs) throws InputFormatConfigException {
<span class="nc" id="L75">    	builtinConfigFactory.addFormatsInDirectories(dirs);</span>
<span class="nc" id="L76">    }</span>

    /**
     * Returns the factory which will be used to create the DocIndexer registered under this formatIdentifier.
     * This method isn't used in BlackLab itself, but it could be useful for client applications.
     *
     * @param formatIdentifier
     * @return the factory if a valid formatIdentifier is provided, null otherwise
     */
    public static DocIndexerFactory getFactory(String formatIdentifier) {
<span class="pc bpc" id="L86" title="2 of 4 branches missed.">        if (formatIdentifier == null || formatIdentifier.isEmpty())</span>
<span class="nc" id="L87">        	return null;</span>

<span class="pc bpc" id="L89" title="1 of 2 branches missed.">    	for (int i = factories.size()-1; i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">    		if (factories.get(i).isSupported(formatIdentifier))</span>
<span class="fc" id="L91">    			return factories.get(i);</span>
    	}
<span class="nc" id="L93">    	return null;</span>
	}

    /**
	 * Check if a particular string denotes a valid document format.
	 *
	 * @param formatIdentifier format identifier, e.g. &quot;tei&quot; or &quot;com.example.MyIndexer&quot;
	 * @return true iff a registered factory supports this format
	 */
	public static boolean isSupported(String formatIdentifier) {
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">		return getFactory(formatIdentifier) != null;</span>
	}

	/**
	 * Returns an alphabetically sorted list of registered document formats.
	 * Note that though this list will not contain duplicates, duplicates might exist internally (see {@link DocumentFormats#getFormats()}).
	 *
	 * @return the list of registered formatIdentifiers
	 * @deprecated use getFormats()
	 */
    @Deprecated
	public static List&lt;String&gt; list() {
<span class="nc" id="L115">		HashSet&lt;String&gt; s = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">		for (Format d : getFormats())</span>
<span class="nc" id="L117">			s.add(d.getId());</span>

<span class="nc" id="L119">		List&lt;String&gt; l = new ArrayList&lt;&gt;(s);</span>
<span class="nc" id="L120">		Collections.sort(l);</span>
<span class="nc" id="L121">		return l;</span>
	}

    /**
     * Returns a list of all registered document formats for all factories,
     * ordered by descending priority.
     * Note that this list might contain duplicates if multiple factories support the same formatIdentifier,
     * such as when registering extra instances of the builtin factories.
     * In this case, the first of those entries is the one that is actually used.
     *
     * @return the list of registered abbreviations
     */
	public static List&lt;Format&gt; getFormats() {
<span class="fc" id="L134">	        List&lt;Format&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">	    	for (DocIndexerFactory fac : factories)</span>
<span class="fc" id="L136">	    		ret.addAll(fac.getFormats());</span>
<span class="fc" id="L137">	    	Collections.reverse(ret);</span>
<span class="fc" id="L138">	    	return ret;</span>
    	}

	/**
	 * Returns a format descriptor for a specific format
	 * @param formatIdentifier
	 * @return the descriptor, or null if not supported by any factory
	 */
	public static Format getFormat(String formatIdentifier) {
<span class="fc" id="L147">		DocIndexerFactory factory = getFactory(formatIdentifier);</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">		return factory != null ? factory.getFormat(formatIdentifier) : null;</span>
	}

	// Convenience
	public static DocIndexer get(String formatIdentifier, Indexer indexer, String documentName, Reader reader)
			throws UnsupportedOperationException {
<span class="nc" id="L154">		DocIndexerFactory fac = getFactory(formatIdentifier);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">		return fac != null ? fac.get(formatIdentifier, indexer, documentName, reader) : null;</span>
	}

	// Convenience
	public static DocIndexer get(String formatIdentifier, Indexer indexer, String documentName, InputStream is, Charset cs)
			throws UnsupportedOperationException {
<span class="fc" id="L161">		DocIndexerFactory fac = getFactory(formatIdentifier);</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">		return fac != null ? fac.get(formatIdentifier, indexer, documentName, is, cs) : null;</span>
	}

	// Convenience
	public static DocIndexer get(String formatIdentifier, Indexer indexer, String documentName, File f, Charset cs)
			throws UnsupportedOperationException, FileNotFoundException {
<span class="nc" id="L168">		DocIndexerFactory fac = getFactory(formatIdentifier);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">		return fac != null ? fac.get(formatIdentifier, indexer, documentName, f, cs) : null;</span>
	}

	// Convenience
	public static DocIndexer get(String formatIdentifier, Indexer indexer, String documentName, byte[] b, Charset cs)
			throws UnsupportedOperationException {
<span class="nc" id="L175">		DocIndexerFactory fac = getFactory(formatIdentifier);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">		return fac != null ? fac.get(formatIdentifier, indexer, documentName, b, cs) : null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>