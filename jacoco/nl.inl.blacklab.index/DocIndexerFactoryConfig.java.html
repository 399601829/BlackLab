<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DocIndexerFactoryConfig.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BlackLab</a> &gt; <a href="index.source.html" class="el_package">nl.inl.blacklab.index</a> &gt; <span class="el_source">DocIndexerFactoryConfig.java</span></div><h1>DocIndexerFactoryConfig.java</h1><pre class="source lang-java linenums">package nl.inl.blacklab.index;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.function.Function;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import nl.inl.blacklab.index.config.ConfigInputFormat;
import nl.inl.blacklab.index.config.DocIndexerConfig;
import nl.inl.blacklab.index.config.InputFormatConfigException;
import nl.inl.blacklab.index.config.InputFormatReader;
import nl.inl.blacklab.search.ConfigReader;
import nl.inl.util.FileUtil;
import nl.inl.util.FileUtil.FileTask;

/**
 * A DocIndexerFactory implementation that automatically adds configurations in the formats/ dir in the jar
 * and scans the default config directories for subdirectories called &quot;config&quot;, then loads any configurations within those directories.
 * Instances of this class can be used to add additional configs within customized directories.
 */
public class DocIndexerFactoryConfig implements DocIndexerFactory {
<span class="fc" id="L37">	static final Logger logger = LogManager.getLogger(DocIndexerConfig.class);</span>

<span class="fc" id="L39">	protected boolean isInitialized = false;</span>

<span class="fc" id="L41">	protected Map&lt;String, File&gt; unloaded = new HashMap&lt;&gt;(); // Entries here are short-lived, the list should be clean as long as there is no scanDirectories call running</span>
<span class="fc" id="L42">	protected Map&lt;String, ConfigInputFormat&gt; supported = new HashMap&lt;&gt;();</span>


	/**
	 * Return a config from the supported list, or load it if it's in the unloaded list.
	 * &lt;br&gt;&lt;br&gt;
	 * Why this function? Formats can depend on each other,
	 * and this is a mechanism to allow formats to get/lazy-load other formats registered with this factory.
	 * Why lazy-loading? Formats only refer to other formats by their name, not their file location, so we need to find them all before we actually load them.
	 * Those found config files are kept in the {@link DocIndexerFactoryConfig#unloaded} map until they are loaded
	 */
<span class="fc" id="L53">	protected Function&lt;String, Optional&lt;ConfigInputFormat&gt;&gt; finder = formatIdentifier -&gt; {</span>
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">		if(!isSupported(formatIdentifier)) // Give our wrapping DocIndexerFactory a chance to load a new format (in case it's a derived class)</span>
<span class="nc" id="L55">			return Optional.empty();</span>

<span class="pc bpc" id="L57" title="1 of 2 branches missed.">		if (unloaded.containsKey(formatIdentifier)) {</span>
<span class="nc" id="L58">			File f = unloaded.get(formatIdentifier);</span>
<span class="nc" id="L59">			unloaded.remove(formatIdentifier); // remove before load to avoid infinite recursion on circular dependencies</span>
<span class="nc" id="L60">			return load(formatIdentifier, f);</span>
		}

		// If unknown return null, can't help it.
<span class="fc" id="L64">		return Optional.ofNullable(supported.get(formatIdentifier));</span>
	};


<span class="fc" id="L68">    public DocIndexerFactoryConfig() {</span>
		// Init called externally.
<span class="fc" id="L70">    }</span>

	@Override
	public void init() throws InputFormatConfigException {
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">		if (isInitialized)</span>
<span class="nc" id="L75">			return;</span>
<span class="fc" id="L76">		isInitialized = true;</span>

		// Note that these names should not collide with the abbreviations used by DocIndexerFactoryClass, or this will override those classes.
<span class="fc" id="L79">		String[] formats = { &quot;chat&quot;, &quot;cmdi&quot;, &quot;csv&quot;, &quot;eaf&quot;, &quot;folia&quot;, &quot;sketch-wpl&quot;, &quot;tcf&quot;, &quot;tei-p4&quot;, &quot;tei&quot;, &quot;tsv-frog&quot;, &quot;tsv&quot;, &quot;txt&quot; };</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">		for (String formatIdentifier: formats) {</span>
<span class="pc" id="L81">			try (InputStream is = DocumentFormats.class	.getClassLoader().getResourceAsStream(&quot;formats/&quot; + formatIdentifier + &quot;.blf.yaml&quot;)) {</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">				if (is == null)</span>
					continue; // not found

<span class="pc" id="L85">				try (Reader reader = new BufferedReader(new InputStreamReader(is))) {</span>
<span class="fc" id="L86">					ConfigInputFormat format = new ConfigInputFormat(formatIdentifier);</span>

<span class="fc" id="L88">					format.setReadFromFile(new File(&quot;$BLACKLAB_JAR/formats/&quot; + formatIdentifier + &quot;.blf.yaml&quot;));</span>
<span class="fc" id="L89">					InputFormatReader.read(reader, false, format, finder);</span>
<span class="fc" id="L90">					addFormat(format);</span>
<span class="pc bpc" id="L91" title="6 of 8 branches missed.">				}</span>
<span class="pc bpc" id="L92" title="10 of 12 branches missed.">			} catch (IOException e) {</span>
<span class="nc" id="L93">				throw new RuntimeException(e);</span>
<span class="fc" id="L94">			}</span>
		}

<span class="fc" id="L97">		List&lt;File&gt; configDirs = ConfigReader.getDefaultConfigDirs();</span>
<span class="fc" id="L98">		List&lt;File&gt; formatsDirs = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">		for (File dir: configDirs) {</span>
<span class="fc" id="L100">			formatsDirs.add(new File(dir, &quot;formats&quot;));</span>
<span class="fc" id="L101">		}</span>
<span class="fc" id="L102">		addFormatsInDirectories(formatsDirs);</span>

		// Load any configs that may have been added using addFormatsInDirectories, from before we were initialized
<span class="fc" id="L105">		loadUnloaded();</span>
<span class="fc" id="L106">	}</span>

	@Override
	public boolean isSupported(String formatIdentifier) {
		// Do not load yet, this is called during discovery of new formats (to detect duplicates)
		// We shouldn't load any new format until we've discovered them all,
		// so that if a format depends on another yet to be loaded format, we know where to find it
<span class="fc bfc" id="L113" title="All 4 branches covered.">		return (supported.containsKey(formatIdentifier) || unloaded.containsKey(formatIdentifier));</span>
	}

	@Override
	public List&lt;Format&gt; getFormats() {
<span class="fc" id="L118">		List&lt;Format&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">		for (Entry&lt;String, ConfigInputFormat&gt; e: this.supported.entrySet()) {</span>
<span class="fc" id="L120">			ConfigInputFormat config = e.getValue();</span>
<span class="fc" id="L121">            Format desc = new Format(config.getName(), config.getDisplayName(), config.getDescription(), config.getHelpUrl());</span>
<span class="fc" id="L122">			desc.setConfig(config);</span>
<span class="fc" id="L123">			desc.setVisible(config.isVisible());</span>
<span class="fc" id="L124">			ret.add(desc);</span>
<span class="fc" id="L125">		}</span>

<span class="fc" id="L127">		return ret;</span>
	}

	@Override
	public Format getFormat(String formatIdentifier) {
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">		if (!isSupported(formatIdentifier))</span>
<span class="nc" id="L133">			return null;</span>

<span class="fc" id="L135">		ConfigInputFormat config = this.supported.get(formatIdentifier);</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">		if (config == null) {</span>
<span class="fc" id="L137">		    loadUnloaded();</span>
<span class="fc" id="L138">		    config = this.supported.get(formatIdentifier);</span>
		}
<span class="fc" id="L140">		Format desc = new Format(config.getName(), config.getDisplayName(), config.getDescription(), config.getHelpUrl());</span>
<span class="fc" id="L141">		desc.setConfig(config);</span>
<span class="fc" id="L142">		desc.setVisible(config.isVisible());</span>
<span class="fc" id="L143">		return desc;</span>
	}

	protected void addFormat(ConfigInputFormat format) throws InputFormatConfigException {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">		if (isSupported(format.getName()))</span>
<span class="nc" id="L148">			throw new IllegalArgumentException(&quot;A config format with this name already exists.&quot;);</span>

<span class="fc" id="L150">		format.validate();</span>
<span class="fc" id="L151">		supported.put(format.getName(), format);</span>
<span class="fc" id="L152">	}</span>

	/**
	 * Locate all config files (files ending with .blf.yaml, .blf.yml, .blf.json) within the list of directories and load them.
	 * Formats will use their filename (excluding the .blf.* extension) as a unique identifier. Duplicate formats are ignored.
	 * Note that the actual loading of the configs is deferred until this factory is initialized by registering it with {@link DocumentFormats}, if not already done.
	 *
	 * This is a one-time scan, so configs placed in these directories after this scan will not be picked up.
	 * &lt;br&gt;&lt;br&gt;
	 * If any of the config files depend on other config files, the locations of those dependencies must also be provided in this list of directories.
	 * If config A refers to config B, then the directory where config B is located must also be present in the dirs list.
	 * @param dirs
	 * @throws InputFormatConfigException when one of the formats could not be loaded
	 */
	public void addFormatsInDirectories(List&lt;File&gt; dirs) throws InputFormatConfigException {
		// Finds all new configs and add them to the &quot;unloaded&quot; list
<span class="fc" id="L168">		FileTask configLocator = new FileTask() {</span>
			@Override
            public void process(File f) {
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">                if (f.getName().matches(&quot;^[\\-\\w]+\\.blf\\.(ya?ml|json)$&quot;)) {</span>
<span class="fc" id="L172">                	String formatIdentifier = ConfigInputFormat.stripExtensions(f.getName());</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                    if (isSupported(formatIdentifier)) {</span>
<span class="nc" id="L174">                    	logger.info(&quot;Skipping config format &quot; + f + &quot;; a format with this name already exists.&quot;);</span>
<span class="nc" id="L175">                    	return;</span>
                    }

<span class="pc bpc" id="L178" title="2 of 4 branches missed.">                    if (!Files.isReadable(f.toPath()) || !Files.isRegularFile(f.toPath())) {</span>
<span class="nc" id="L179">                    	logger.trace(&quot;Skipping unreadable config file &quot; + f);</span>
<span class="nc" id="L180">                    	return;</span>
                    }

<span class="fc" id="L183">                	unloaded.put(formatIdentifier, f);</span>
                }
<span class="fc" id="L185">            }</span>
		};

		// Run the configLocation on the directory - not recursive
<span class="fc bfc" id="L189" title="All 2 branches covered.">		for(File dir : dirs) {</span>
<span class="pc bpc" id="L190" title="1 of 4 branches missed.">			if (Files.isReadable(dir.toPath()) &amp;&amp; Files.isDirectory(dir.toPath())) {</span>
<span class="fc" id="L191">				FileUtil.processTree(dir, &quot;*&quot;, false, configLocator);</span>
			}
<span class="fc" id="L193">		}</span>

		// Don't load until we're initialized,
		// or the configs won't be able to depend on one of the default configs (which are not loaded until after initialization)
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">		if (isInitialized)</span>
<span class="fc" id="L198">			loadUnloaded();</span>
<span class="fc" id="L199">	}</span>

	protected Optional&lt;ConfigInputFormat&gt; load(String formatIdentifier, File f) {
		try {
<span class="fc" id="L203">			ConfigInputFormat format = new ConfigInputFormat(formatIdentifier);</span>
<span class="fc" id="L204">			InputFormatReader.read(f, format, finder);</span>
<span class="fc" id="L205">			format.setReadFromFile(f);</span>

<span class="fc" id="L207">			addFormat(format);</span>
<span class="fc" id="L208">			return Optional.of(format);</span>
<span class="nc" id="L209">		} catch (IOException e) {</span>
<span class="nc" id="L210">			return Optional.empty();</span>
		}
	}

	protected void loadUnloaded() {
		// use !isEmpty so we can remove entries during iteration (using the finder above) without messing up iterators
<span class="fc bfc" id="L216" title="All 2 branches covered.">		while (!unloaded.isEmpty()) {</span>
<span class="fc" id="L217">			Entry&lt;String, File&gt; e = unloaded.entrySet().iterator().next();</span>
<span class="fc" id="L218">			unloaded.remove(e.getKey());</span>

			try {
<span class="fc" id="L221">				load(e.getKey(), e.getValue());</span>
<span class="nc" id="L222">			} catch (InputFormatConfigException ex) {</span>
<span class="nc" id="L223">				logger.warn(&quot;Cannot load user format &quot; + e.getValue() + &quot;: &quot; + ex.getMessage());</span>
				// an invalid format somehow got saved, or something else went wrong, just ignore this file then
<span class="fc" id="L225">			}</span>
<span class="fc" id="L226">		}</span>
<span class="fc" id="L227">	}</span>

    @Override
    public DocIndexerConfig get(String formatIdentifier, Indexer indexer, String documentName, Reader reader) {
<span class="nc bnc" id="L231" title="All 2 branches missed.">       if (!isSupported(formatIdentifier))</span>
<span class="nc" id="L232">        	throw new UnsupportedOperationException(&quot;Unknown format '&quot;+formatIdentifier+&quot;', call isSupported(formatIdentifier) before attempting to get()&quot;);</span>

<span class="nc" id="L234">    	DocIndexerConfig d = DocIndexerConfig.fromConfig(supported.get(formatIdentifier));</span>
<span class="nc" id="L235">        d.setIndexer(indexer);</span>
<span class="nc" id="L236">        d.setDocumentName(documentName);</span>
<span class="nc" id="L237">        d.setDocument(reader);</span>
<span class="nc" id="L238">        return d;</span>
    }

    @Override
    public DocIndexerConfig get(String formatIdentifier, Indexer indexer, String documentName, InputStream is, Charset cs) {
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (!isSupported(formatIdentifier))</span>
<span class="nc" id="L244">        	throw new UnsupportedOperationException(&quot;Unknown format '&quot;+formatIdentifier+&quot;', call isSupported(formatIdentifier) before attempting to get()&quot;);</span>

<span class="nc" id="L246">        DocIndexerConfig d = DocIndexerConfig.fromConfig(supported.get(formatIdentifier));</span>
<span class="nc" id="L247">        d.setIndexer(indexer);</span>
<span class="nc" id="L248">        d.setDocumentName(documentName);</span>
<span class="nc" id="L249">        d.setDocument(is, cs);</span>
<span class="nc" id="L250">        return d;</span>
    }

    @Override
    public DocIndexerConfig get(String formatIdentifier, Indexer indexer, String documentName, File f, Charset cs) throws FileNotFoundException {
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (!isSupported(formatIdentifier))</span>
<span class="nc" id="L256">        	throw new UnsupportedOperationException(&quot;Unknown format '&quot;+formatIdentifier+&quot;', call isSupported(formatIdentifier) before attempting to get()&quot;);</span>

<span class="nc" id="L258">        DocIndexerConfig d = DocIndexerConfig.fromConfig(supported.get(formatIdentifier));</span>
<span class="nc" id="L259">        d.setIndexer(indexer);</span>
<span class="nc" id="L260">        d.setDocumentName(documentName);</span>
<span class="nc" id="L261">        d.setDocument(f, cs);</span>
<span class="nc" id="L262">        return d;</span>
    }

    @Override
    public DocIndexerConfig get(String formatIdentifier, Indexer indexer, String documentName, byte[] b, Charset cs) {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (!isSupported(formatIdentifier))</span>
<span class="nc" id="L268">        	throw new UnsupportedOperationException(&quot;Unknown format '&quot;+formatIdentifier+&quot;', call isSupported(formatIdentifier) before attempting to get()&quot;);</span>

<span class="nc" id="L270">        DocIndexerConfig d = DocIndexerConfig.fromConfig(supported.get(formatIdentifier));</span>
<span class="nc" id="L271">        d.setIndexer(indexer);</span>
<span class="nc" id="L272">        d.setDocumentName(documentName);</span>
<span class="nc" id="L273">        d.setDocument(b, cs);</span>
<span class="nc" id="L274">        return d;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>