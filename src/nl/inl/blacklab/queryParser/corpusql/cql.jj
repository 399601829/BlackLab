/*******************************************************************************
 * Copyright (c) 2010, 2012 Institute for Dutch Lexicology.
 * All rights reserved.
 *******************************************************************************/
/*

Corpus Query Language (CQL) parser definition.

javacc is used to generate Java code from this parser definition.

*/

options 
{
	STATIC=false;
	JAVA_UNICODE_ESCAPE=true;
	//USER_CHAR_STREAM=true;
}

PARSER_BEGIN(CorpusQueryLanguageParser)

package nl.inl.blacklab.queryParser.corpusql;

import nl.inl.blacklab.search.TextPattern;
import nl.inl.blacklab.search.TextPatternAnd;
import nl.inl.blacklab.search.TextPatternContaining;
import nl.inl.blacklab.search.TextPatternEndsAt;
import nl.inl.blacklab.search.TextPatternNot;
import nl.inl.blacklab.search.TextPatternOr;
import nl.inl.blacklab.search.TextPatternProperty;
import nl.inl.blacklab.search.TextPatternRegex;
import nl.inl.blacklab.search.TextPatternStartsAt;
import nl.inl.blacklab.search.TextPatternTags;
import nl.inl.blacklab.search.TextPatternWithin;
import nl.inl.blacklab.search.sequences.TextPatternAnyToken;
import nl.inl.blacklab.search.sequences.TextPatternRepetition;
import nl.inl.blacklab.search.sequences.TextPatternSequence;

@SuppressWarnings("all")

public class CorpusQueryLanguageParser {

    public static void main(String[] args) throws Exception 
    {
		CorpusQueryLanguageParser parser = new CorpusQueryLanguageParser(new java.io.StringReader(args[0]));
		parser.query();
    }
    
    private int num(Token t)
    {
    	return Integer.parseInt(t.toString());
    }
    
    private String chopEnds(String regex)
    {
    	if (regex.length() >= 2)
    		return regex.substring(1, regex.length() - 1);
    	throw new RuntimeException("Cannot chop slashes");
    }
    
    private TextPattern simplePattern(String str)
    {
        if (str.charAt(0) != '^')
            str = "^" + str;
        if (str.charAt(str.length() - 1) != '$')
            str += "$";
        
        return TextPatternRegex.getAppropriatePattern(str); 
    }
    
    private String defaultProperty = "word";
    
    public void setDefaultProperty(String property) {
        defaultProperty = property;
    }

    public String getDefaultProperty() {
        return defaultProperty;
    }

    private TextPattern propertyClause(String prop, TextPattern value)
    {
    	if (prop.equals(defaultProperty))
    		return value; // default property
    	return new TextPatternProperty(prop, value);
    }
    
}

PARSER_END(CorpusQueryLanguageParser)

// Skip whitespace and comment
SKIP:  
{
	" " 
|	"\t" 
|	"\n" 
|	"\r"
}

/* Comments are 'special tokens': they are not reported, but are available
   for use by the next reported token */
SPECIAL_TOKEN:
{
	<SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
|	<MULTI_LINE_COMMENT: "/*" (~["*"] | "*" ~["/"])* "*/">
}

// Token definitions
TOKEN [IGNORE_CASE]:
{
    <WITHIN: "within" >
|   <CONTAINING: "containing" >
|	<NAME: ["A"-"Z","a"-"z","_"] (["A"-"Z","a"-"z","_","0"-"9"])* >
|	<NUMBER: (["0"-"9"])+ >
|	<QUOTED_STRING: "\"" (~["\"","\\"] | "\\" ~[] )* "\"" >
}

// --- Grammar rules start here --- 

/* a query */
TextPattern query(): 
{
	TextPattern a = null;
} 
{
    a=complexQuery() <EOF>
    {
        return a;
    }
}

TextPattern complexQuery():
{
    TextPattern a = null, b = null;
    Token op = null;
} 
{
    a=simpleQuery() [ op=queryOperator() b=complexQuery() ]
    {
        if (op == null)
            return a;
        if (op.toString().equals("within")) {
            // a within b
            return new TextPatternWithin(a, b);
        }
        
        // a containing b
        return new TextPatternContaining(a, b);
    }
}

Token queryOperator():
{
    Token t = null;
}
{
    (t=<WITHIN> | t=<CONTAINING>)
    {
        return t;
    }
}

/* a simple query (not including containing, within, etc.) */
TextPattern simpleQuery(): 
{
    TextPattern query = null;
} 
{
    LOOKAHEAD(3) /* to distinguish between open tag and self-closing tag */
    query=sequence()
    {
        return query;
    }
|   query=selfClosingTag()
    {
        return query;
    }
}

/* a sequence of token constraints */
TextPattern sequence(): 
{
	TextPattern first = null;
	TextPattern result = null;
    Token t = null, t2 = null;
} 
{
    [ t=startTag() ] first=sequencePart() [ LOOKAHEAD(2) result=sequenceRest(first) ] [ LOOKAHEAD(2) t2=endTag() ]
	{
		if (result == null)
			result = first;
        if (t != null)
        {
            result = new TextPatternStartsAt(result, new TextPatternTags(t.toString()));
        }
        if (t2 != null)
        {
            result = new TextPatternEndsAt(result, new TextPatternTags(t2.toString()));
        }
		return result;
	}
}

/* a self-closing tag such as <s/> (for finding XML elements) */
TextPattern selfClosingTag():
{
    Token t;
}
{
    "<" t=<NAME> "/" ">"
    {
        return new TextPatternTags(t.toString());
    }
}

/* a start tag such as <s> (for finding XML elements) */
Token startTag():
{
    Token t;
}
{
    "<" t=<NAME> ">"
    {
        return t;
    }
}

/* an end tag such as </s> (for finding XML elements) */
Token endTag():
{
    Token t;
}
{
    "<" "/" t=<NAME> ">"
    {
        return t;
    }
}

/* continuation of a sequence (after the first part) */
TextPattern sequenceRest(TextPattern first):
{
	Token op = null;
	TextPattern rest = null;
/*	Integer[] minMax = null;*/
}
{
	rest=sequence()
	{
		if (rest == null)
			return first;
		return new TextPatternSequence(first, rest);
	}
/*|	minMax=matchall() rest=sequence()
	{
		return new TextPatternSequence(first, new TextPatternAnyToken(minMax[0], minMax[1]), rest);
	}*/
|	"|" rest=sequence()
	{
		return new TextPatternOr(first, rest);
	}
}

/* a repetition specifier */
Integer[] repetitionAmount():
{
	Token t = null, t2 = null;
	Integer[] minMax = new Integer[2];
}
{
	"*"                                 { minMax[0] = 0; minMax[1] = -1; return minMax; }
|	"+"                                 { minMax[0] = 1; minMax[1] = -1; return minMax; }
|	"?"                                 { minMax[0] = 0; minMax[1] = 1; return minMax; }
|	LOOKAHEAD(3) "{" t=<NUMBER> "}"     { minMax[0] = minMax[1] = num(t); return minMax; }
|	"{" t=<NUMBER> "," [ t2=<NUMBER> ] "}"
	{
		minMax[0] = num(t);
		if (t2 == null)
			minMax[1] = -1;
		else
			minMax[1] = num(t2);
		return minMax; 
	}
}

/* boolean operator: and, or or implication */
Token booleanOperator():
{
	Token t = null;
}
{
	(t="&" | t="|" | t="->")  { return t; }
}

/* sequence part: one part in a sequence, possibly with a repetition operator */
TextPattern sequencePart(): 
{
	TextPattern m = null;
	Integer[] rep = null;
}
{
	( m=position() | "(" m=complexQuery() ")" ) [ LOOKAHEAD(6) rep=repetitionAmount() ]
	{
		if (rep != null)
		{
            if (m instanceof TextPatternAnyToken)
            {
                TextPatternAnyToken any = (TextPatternAnyToken)m;
                m = any.repeat(rep[0], rep[1]);
            } else
                m = new TextPatternRepetition(m, rep[0], rep[1]);
		}
		return m;
	}
}

/* position: a simple attribute value or complex attribute expression between square brackets */
TextPattern position():
{
	TextPattern m = null;
}
{
	m=positionWord()         { return m; }
|	"[" [ m=positionLong() ] "]"
    {
        if (m == null)
            return new TextPatternAnyToken(1, 1);
        return m;
    }
}

/* position word: no brackets, just a single token constraint for the default attribute (usually word form) */
TextPattern positionWord():
{
	Token t = null;
}
{
	t=<QUOTED_STRING>      { return simplePattern(chopEnds(t.toString())); }
}

/* expression inside square brackets: an attribute clause, or multiple 
   attribute clauses combined with boolean operators */
TextPattern positionLong():
{
	TextPattern a = null, c = null;
	Token b = null;
}
{
	a=positionLongPart() [ b=booleanOperator() c=positionLong() ]
	{
		if (b == null)
			return a;
        if (b.toString().equals("->"))
            throw new UnsupportedOperationException("Implication operator not yet supported");
		if (b.toString().equals("&"))
			return new TextPatternAnd(a, c);
		return new TextPatternOr(a, c);
	}
}

/* attribute clause: an attribute/value pair, attribute expression between parens, or a negated attribute/value pair */
TextPattern positionLongPart():
{
	TextPattern m = null;
}
{
	LOOKAHEAD(3)
	m=attValuePair()              { return m; }
|	"(" m=positionLong() ")"      { return m; }
|	"!" m=positionLongPart()      { return new TextPatternNot(m); }
}

/* attribute/value pair, with equals or not equals sign, or possibly just a value (default attribute) */
TextPattern attValuePair():
{
	TextPattern v = null;
	Token t = null;
}
{
	LOOKAHEAD(2)
	t=<NAME> "=" v=valuePart()      { return propertyClause(t.toString(), v); }
|	t=<NAME> "!=" v=valuePart()      { return new TextPatternNot(propertyClause(t.toString(), v)); }
|	v=valuePart()                   { return v; }
}

/* value expression: a value or multiple values combined with boolean operators */
TextPattern value():
{
	TextPattern a = null, c = null;
	Token b = null;
}
{
	LOOKAHEAD(3) a=valuePart() b=booleanOperator() c=value()
	{
        if (b.toString().equals("->"))
            throw new UnsupportedOperationException("Implication operator not yet supported");
		if (b.toString().equals("&"))
			return new TextPatternAnd(a, c);
		return new TextPatternOr(a, c);
	}
|	a=valuePart()                   { return a; }
}

/* value: a quoted string, a value expression between parens, or a negated value */
TextPattern valuePart():
{
	TextPattern m = null;
	Token t = null;
}
{
	t=<QUOTED_STRING>              { return simplePattern(chopEnds(t.toString())); }
|	"(" m=value() ")"              { return m; }

}

